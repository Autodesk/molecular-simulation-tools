/**
 * Created by andrewkimoto on 12/2/16.
 */
var Autodesk = Autodesk || {};
//top level object for all molviewers
Autodesk.$ADSKMOLVIEW = function(container, options) {
    var headless = Autodesk.Viewing.Private.getParameterByName('headless');
    var self = this;
    options = options || {};
    options.headless = (typeof options.headless === 'boolean' ? options.headless : headless === "true");
    //unique id for the app instance.
    this.appID = THREE.Math.generateUUID();
    this.container = container;
    this.ApiConnector = new Autodesk.Nano.ApiConnector(this);
    this.Loader = new Autodesk.Viewing.MolViewerLoader(this);
    this.StateManager = new Autodesk.Nano.StateManager(this); //create new StateManager
    this.The3DNanoMan = null;

    // TODO handle options set here vs. from url parameters
    // Currently options in url parameters overwrite those set by passed options
    if (options && options.headless) { //headless molecule viewer
        this.MoleculeViewer = new Autodesk.MoleculeViewer(this, container, options);
    } else {
        this.MoleculeViewer = new Autodesk.GuiMoleculeViewer(this, container, options);
    }
    this.MolMan = new Autodesk.Viewing.MolViewer.MolViewerMan(this.MoleculeViewer, this.ApiConnector, null, this.StateManager, this.Loader, null);
    this.MolMan.view3DMan = new Autodesk.Nano.MolViewer.ViewManager3D(this.MoleculeViewer,this.MolMan);
    this.MolViewer = new Autodesk.Viewing.MolViewer(this.MoleculeViewer, this.MolMan, this.container);
    this.TheNanoMan = new Autodesk.Nano.InstanceManager(this.MoleculeViewer); //create master instance manager

    //we need to set these properties here to handle dependencies
    this.StateManager.molMan = this.MolMan;
    this.StateManager.molViewer = this.MolViewer;
    this.MoleculeViewer.TheMolMan = this.MolMan;

    this.AnnotateMan = new Autodesk.Viewing.MolViewer.AnnotateMan(this);
    this.MeasureMan = new Autodesk.Viewing.MolViewer.MeasureMan(this);
    this.MolViewer.measureMan = this.MeasureMan;
    this.MolViewer.annotateMan = this.AnnotateMan;

    if (options && !options.headless) { //headless molecule viewer
        this.ViewManager = new Autodesk.Viewing.MolViewer.ViewManager2D(this);
        this.MolMan.viewManager = this.ViewManager;
    }

    // placeholder for all stubbed methods
    function stub () {
        throw new Error('Not yet implemented!');
    }


    /*
     Generates a snapshot URL, by sending front-end state to the viewer's backend.
     This snapshot encodes the entire state of the viewer.
     Calls back (err, url) when snapshot URL is generated.

     */

    function generateSnapshotURL (cb) {
        var self = this;
        if (!self.MoleculeViewer.ViewManager) {
            console.log('The generateSnapshotURL method is not valid for use in headless mode');
            return false;
        }
        var valid = self.MoleculeViewer.ViewManager.getTopView('StateView').validateState();

        if (valid) { //current state === active button state
            self.MoleculeViewer.ApiConnector.saveSession();
        }
        else {
            cb(new Error('Error! Viewer state not valid.'), null);
        }

        function handleViewerLink (ev) {
            self.MoleculeViewer.removeEventListener(Autodesk.Nano.SESSION_SAVED_EVENT,handleViewerLink);
            cb(null, ev.url);
        }
        self.MoleculeViewer.addEventListener(Autodesk.Nano.SESSION_SAVED_EVENT,handleViewerLink);
    }

    /*
     Exports molecule.
     calls back on (err, outputs)
     where outputs is a list of URLs to output files
     */
    function exportMolecule (cb) {
        var self = this;
        var id = self.MolMan.molModels[self.MolMan.currentMolModelID].id;
        var socketID = self.MolMan.molModels[self.MolMan.currentMolModelID].nextSocketID();
        var protocol = window.location.protocol;
        // var url = '';
        self.MoleculeViewer.Loader.getUrlFromPdbId(id, socketID)
            .then(function(data) {
                // url = data.replace(/molecule\/molecule\.svf/,'molecule.cif.gz')
                cb(null, data.outputs);
            })
            .catch(function(err) {
                cb(err, null);
            });
    }

    /*
     Gets viewer state, as a JS object.

     This object can be passed to `setState(obj)`.
     */
    function getState () {
        var self = this;
        return self.MoleculeViewer.molViewer.getMolViewerState();
    }

    /*
     Set viewer state from a state object.

     TODO This only works one time per session. Must investigate.
     */
    function setState (obj) {
        var self = this;
        return self.MolMan.fromJSONObj(obj);
    }


    /*
     Calls back on a buffer.
     Image buffer is a screenshot at width `w` and height `h`
     */
    function screenshot (w, h, cb) {
        var self = this;
        return self.MoleculeViewer.getScreenShotBuffer(w, h, cb);
    }

    /*
      Upload an mmCIF file

      Takes a mmCIF string and calls back
     */

    function uploadCIF (cifData) {
        var self = this;
        self.ApiConnector.uploadCIF(cifData);
    }

    /*
     Import PDB.

     Takes a pdb ID and calls back (err, pdbID)

     */
    function importPDB (pdbID, cb) {
        var self = this;
        var url = '/pdbcheck/' + pdbID.toUpperCase();
        var xhr = new window.XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.setRequestHeader("Connection-ID", self.Loader.getConnectionID());
        xhr.onload = function(e) {
            var err;
            if (this.status == 200) {
                var response = e.currentTarget.responseXML;
                if(!self.Loader.options.headless) {
                    var hv = self.ViewManager.getTopView('HeaderView');
                    self.ViewManager.getTopView('BrowserView').updateTitleFromString(pdbID);
                    self.ViewManager.getTopView('HeaderView').toggleMobileMenu();
                }

                if(1){
                    self.MolViewer.resetViewer();
                }
                self.MolMan.createMolModel(pdbID);
                if(typeof cb === 'function') {
                    cb(null, pdbID);
                }

            } else if (this.status == 516) {
                err = 'Enter a valid PDB ID (e.g. 1C7D)';
                cb(err, null);
            } else {
                err = 'Server error when attempting to validate PDB ID.';
                cb(err, null);
            }
        };
        xhr.send();
    }

    function setAssembly(assemblyID) {
        var self = this;
        if (typeof assemblyID === 'number') {
            assemblyID = assemblyID + '';
        }
        if (assemblyID === null || self.MolMan.molModels[self.MolMan.currentMolModelID].assemblies[assemblyID]) {
            self.MolMan.molModels[self.MolMan.currentMolModelID].switchToAssembly(assemblyID);
        } else {
            console.log('Assembly ',assemblyID, ' does not exist.');
        }

    }


    // selection methods ---------------------------------------------

    /*
     Returns object of the form:

     { instance_id: [atom_index, ...] ... }

     TODO Support multiple models.
     */
    function getSelection() {
        var self = this;
        var selected = {};
        var i, s;
        for (i in self.MolMan.selectedInstances) {
            if(self.MolMan.selectedInstances.hasOwnProperty(i)) {
                s = self.MolMan.selectedInstances[i].atomSelectionState.getSelected();
                selected[i] = s;
            }
        }
        return selected;
    }

    /*

     takes a selection string and turns it into a =what= object

     ex.
     '1' => { what: { instance: ['1'] }}
     '1.A' => { what: { chain: ['A'] }}
     '1.A.A-4' => { what: { residueID: [ "A-4" ] }}
     '1.A.A-4.84' => { what: { atomID: [ "84" ] }}
     */
    function stringToWhat (str) {
        var strs = str.split('.');
        switch (strs.length) {
            case 1:
                return { instance: [ strs[0] ] };
            case 2:
                return { chain: [ strs[1] ] };
            case 3:
                return { residueID: [ strs[2] ] };
            case 4:
                return { atomID: [ strs[3] ] };
        }
    }

    // wrapper for selection-dependent functions
    function selectionF (selection, cb) {
        var self = this;
        if (selection)
            select.call(self, selection);
        var val = cb();
        if (selection)
            clearSelection.call(self);
        return val;
    }


    /*
     Selects atoms.
     Returns selection state.
     Takes an object of the form:

     {instance_id: [atom_index, ...] ...}

     This is the same format as `getSelection()`'s return values -
     those return values can be passed into this method.

     TODO Support multiple models.
     */
    function select (str) {
        var self = this;
        var what = stringToWhat(str);
        var instanceId = str.split('.')[0];
        var instanceIndex = parseInt(instanceId)-1;
        var instance = self.MolMan.instances[instanceIndex];
        var model = instance.molModel;
        var sel = {
            instance: instance,
            what: what
        };
        model.select([sel], true);
        return getSelection.call(self);
    }

    /*
     Clears current selection.
     Returns nothing.
     */
    function clearSelection () {
        var self = this;
        return self.MolMan.clearSelection();
    }

    // selection-based getters / setters ------------------------------------

    /*
     Get the center of the current selection.
     Returns a THREE.Vector3 { x, y, z}.
     Refer to THREE.js docs for more information on Vector3.
     */
    function getCenter (selection) {
        var self = this;
        return selectionF.call(self,selection, function () {
            var sel = getSelection.call(self);
            var instance;
            //var keys = Object.keys(sel);
            //MZ NEED TO REDO
            function getSelectionCenter (instanceId) {
                return self.MolMan.getInstance(instanceId).getSelectedAtomsCenter();
            }
            function averageOf (vectors) {
                var sum = vectors.reduce(function (acc, vec) {
                    return acc.add(vec);
                }, new THREE.Vector3());
                return new THREE.Vector3(
                    sum.x / vectors.length,
                    sum.y / vectors.length,
                    sum.z / vectors.length
                );
            }
            var centers = [];
            for (instance in sel) {
                if (sel.hasOwnProperty(instance)) {
                    centers.push(getSelectionCenter(instance));
                }
            }
            return averageOf(centers);
        });
    }

    /*
     Set the color of the current selection, for a particular represenatation.
     If nothing is selected, the change will be global.
     If the string `color` is invalid, the method will throw an error.

     TODO Support arbitrary colors by passing in hexidecimal values.
     TODO When this method is called, the selected color in the UI doesn't update right away. Need to deselect + reselect to get it to update.

     Representations:

     - 'surface'
     - 'stick'
     - 'ribbon'

     Colors:

     - 'entity'
     - 'residue'
     - 'secondary'
     - 'bfactor'
     - 'index'
     - 'atom'

     - 'green'
     - 'yellow'
     - 'orange'
     - 'red'
     - 'blue'
     - 'white'
     - 'gray'
     - 'black'

     */
    function setColor (representation, color, selection) {
        var self = this;
        return selectionF.call(self, selection, function () {

            function scheme (c) {
                var schemes = [
                    'entity',
                    'residue',
                    'secondary',
                    'bfactor',
                    'index',
                    'atom'
                ];
                if (schemes.indexOf(c) > -1)
                    return c;
                return null;
            }

            function colorToIndex (c) {
                var colors = {
                    'green'        : 1,
                    'yellow'       : 2,
                    'orange'       : 3,
                    'red'          : 4,
                    'blue'         : 5,
                    'white'        : 6,
                    'gray'         : 7,
                    'black'        : 8,
                    'green2'       : 9,
                    'green-brown'  : 10,
                    'brown'        : 11,
                    'purple'       : 12,
                    'violet'       : 13,
                    'magenta'      : 14,
                    'teal'         : 15,
                    'yellow-green' : 16

                };
                return colors[c];
            }

            var colorScheme = scheme(color);
            if (colorScheme)
                return self.MolMan.setColorFromSelection(representation, colorScheme);

            var colorIndex = colorToIndex(color);
            if (colorIndex)
                return self.MolMan.setColorFromSelection(representation, 'custom', colorIndex);

            throw new Error('Error! Not a valid color or color scheme: ' + color);

        });
    }

    // Set representation of selected items.
    // (representations are 'surface', 'stick', 'ribbon')
    function setRepresentation (representation, isVisible, selection) {
        var self = this;
        return selectionF.call(self, selection, function () {
            return self.MolMan.setVisibleFromSelection(representation, isVisible);
        });
    }

    /*
     Sets opacity (0-1) of selected items, at a given representation.
     */
    function setSurfaceOpacity (opacity, selection) {
        var self = this;
        return selectionF.call(self, selection, function () {
            return self.MolMan.setOpacityFromSelection(0, 'surface', opacity, true);
        });
    }

    // annotation methods ---------------------------------------------------

    /*
     Draws an annotation `ann` at the current selection.
     Returns the added annotation.
     Annotation has a method `remove()`, which will remove that annotation from the view.
     Annotation also has a method `updateValue(string)`, which updates the displayed value
     of the annotation (and the underlying object).
     ,*/
    function annotate (ann, selection) {
        var self = this;
        var selectionObj = getSelection.call(self,selection);
        var annotateObj;
        var returnObj;
        var selAtom;
        var isEmpty = function(obj) {
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    return false;
                }
            }
            return true;
        };

        // use selection string if passed, otherwise use current selection
        if (selection) {
            clearSelection.call(self);
            selectionObj = select.call(self, selection);
        }

        if (isEmpty(selectionObj)) {
            return new Error('Nothing selected and no selection string passed'); // no selection object and no selection string
        }

        //set up annotation object
        annotateObj = {
            id: 'C' + THREE.Math.generateUUID(),
            type: 'annotation',
            string: ann,
            xyzPoint: null,
            xyzOrigPoint: null,
            selectedInstances: null,
            entityID: null,
            xOffset: 0,
            yOffset: 0,
            label: null,
            clientWidth: 0,
            clientHeight: 0,
            x: 0,
            y: 0,
            width: null,
            height: null
        };

        self.AnnotateMan.annotationType = 'annotation';
        self.AnnotateMan.activate();

        self.AnnotateMan.addAnnotation(annotateObj,true);
        self.AnnotateMan.deactivateAnnotateMode();

        returnObj = self.AnnotateMan.getAnnotationById(annotateObj.id);
        returnObj.remove = function() {self.AnnotateMan.removeAnnotationById(annotateObj.id);};
        returnObj.updateValue = function(string) {
            var textArea = this.label.childNodes[1];
            this.string = string;
            textArea.value = string;
            //fix height to match new value;
            textArea.style.height = '20px';
            textArea.style.height = textArea.scrollHeight + 'px';
        };
        return returnObj;
    }

    // Remove all annotations from the view.
    function removeAllAnnotations () {
        var self = this;
        self.AnnotateMan.clearAnnotations();
    }

    // geometry methods ------------------------------------------------------

    // This is the viewer implementation
    // It contains a Three.js scene impl.scene
    // And a method impl.sceneUpdated(bool), which forces a scene update.
    var impl = this.MoleculeViewer.impl;

    // We keep a list of meshes that have been added to the scene.
    // This allows us to remove all added shapes with `meshes.forEach(scene.remove)`
    var meshes = [];

    function removeAllGeometries () {
        return meshes.forEach(function (m) {
            m.remove();
        });
    }

    /*
     Make a basic ThreeJS material with a hexidecimal color.

     Ex--

     var mat = material(0x0000ff)

     ,*/
    function material (hex) {
        return new THREE.MeshBasicMaterial({
            color: hex
        });
    }

    /*
     Make a basic ThreeJS material with a hexidecimal color.

     Ex--

     var mat = material(0x0000ff)

     ,*/
    function phongMaterial (hex) {
        return new THREE.MeshPhongMaterial({
            color: hex
        });
    }

    /*
     Draw a Three.js mesh, with a given Three.js Vector3 `pos`.
     This is a low-level method for rendering arbitrary 3D meshes.
     Refer to Three.JS documentation for more information on meshes.
     */
    function drawMesh (mesh, pos) {
        var self = this;
        function forceUpdate () {
            return self.MoleculeViewer.impl.sceneUpdated(true);
        }

        if (pos)
            mesh.position.set(pos.x, pos.y, pos.z);
        self.MoleculeViewer.impl.scene.add(mesh);
        meshes.push(mesh);
        forceUpdate();

        // add a `remove()` method to the mesh object
        // calling this will remove the mesh from the scene
        mesh.remove = function remove () {
            self.MoleculeViewer.impl.scene.remove(mesh);
            forceUpdate();
        };

        // return the mesh object
        return mesh;

    }

    /*
     Draw a Three.js geometry, with a given Three.js Vector3 `pos` and Three.js material `mat`.
     This is a low-level method for rendering arbitrary 3D geometries.
     Refer to Three.JS documentation for more information on geometries.
     */

    function drawGeom (geom, pos, mat) {
        var mesh = new THREE.Mesh(geom, mat);
        return drawMesh.call(this,mesh, pos);
    }

    /*
     Draws a cube with the given width, height, and depth.
     Pos is a Three.JS Vector { x, y, z }
     Mat is a Three.JS material.

     Ex. -

     var myPos = TheMoleculeViewer.autocam.getCurrentView().position
     var myMat = new THREE.MeshBasicMaterial( {color: 0x0000ff} )
     var cube = api.drawCube(100,100,300, myPos, myMat)

     Now there's a cube on the scene! You can remove it with:

     cube.remove()

     */

    function drawCube (w, h, d, pos, mat) {
        var geom = new THREE.BoxGeometry(w, h, d);
        return drawGeom.call(this,geom, pos, mat);
    }

    /*
     Draw sphere with given radius at Three.js Vector3 `pos` and Three.js material `material.`

     (For usage example, refer to drawCube).
     */
    function drawSphere (r, pos, mat) {
        var geom = new THREE.SphereGeometry(r, 16, 16);
        return drawGeom.call(this,geom, pos, mat);
    }

    /*
     Draw circle with given radius at Three.js Vector3 `pos` and Three.js material `material.`

     (For usage example, refer to drawCube).
     */
    function drawCircle (r, pos, mat) {
        var geom = new THREE.CircleGeometry(r, 16);
        return drawGeom.call(this,geom, pos, mat);
    }

    /*
     Draw cylinder with given top radius `radTop`, bottom radius `radBottom`, and height `h`,
     at Three.js Vector3 `pos` and Three.js material `material.`

     (For usage example, refer to drawCube).
     */
    function drawCylinder (radTop, radBottom, h, pos, mat) {
        var geom = new THREE.CylinderGeometry(radTop, radBottom, h, 16);
        return drawGeom.call(this,geom, pos, mat);
    }

    /* draw an arrow

     ex -

     var dir = new THREE.Vector3(-1,0,0)
     var length = 30
     var origin = api.getSelectionCenter().sub(new THREE.Vector3(0-origin,0,0))
     var red = 0xff0000
     var arrow = drawArrow(dir, origin, length, red)

     Now you can remove the arrow with

     arrow.remove()

     ,*/

    function drawArrow (dir, origin, length, hex) {
        var arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex );
        return drawMesh.call(this,arrowHelper);
    }

    // camera/view control methods -------------------------------------------

    //var autocam = this.MoleculeViewer.autocam;

    function viewOrientation (or) {
        var self = this;
        var orientations = [
            'top',
            'bottom',
            'front',
            'back',
            'left',
            'right'
        ];

        var givenOrientationOk = orientations.indexOf(or) > -1;

        if (givenOrientationOk) {
            self.MoleculeViewer.autocam.calculateCubeTransform(or);
            self.MoleculeViewer.autocam.sphericallyInterpolateTransition();
            return;
        }

        throw new Error(or + 'is not an orientation. Possible values are: ' + orientations.join(', '));
    }

    // Set explode scale (floating point number between 0 1)
    function explode (scale) {
        var self = this;
        return self.MoleculeViewer.explode(scale);
    }

    function viewHome () {
        var self = this;
        return self.MoleculeViewer.autocam.goHome();
    }

    function viewFront () {
        viewOrientation.call(this,'front');
    }

    function viewBack () {
        viewOrientation.call(this,'back');
    }

    function viewTop () {
        viewOrientation.call(this,'top');
    }

    function viewBottom () {
        viewOrientation.call(this,'bottom');
    }

    function viewLeft () {
        viewOrientation.call(this,'left');
    }

    function viewRight () {
        viewOrientation.call(this,'right');
    }

    // TODO - This method has the side-effect of setting the current selection as 'home'
    // This side-effect should be documented.
    function focusOnSelection () {
        var self = this;
        self.getAutocam().setCurrentViewAsHome(true);
    }

    function getSelectionBounds() {
        var self = this;
        return self.MoleculeViewer.impl.selector.getSelectionBounds();
    }
    function getVisibleBounds() {
        var self = this;
        return self.MoleculeViewer.impl.getVisibleBounds();
    }

    function setPivotPoint (bounds) {
        var self = this;
        var point = bounds.center();
        getAutocam.call(self).navApi.setPivotPoint(point);
    }

    // view / camera setter methods ------------------------------------------

    function resetCamera () {
        var self = this;
        return self.getAutocam().resetHome();
    }

    function resetOrientation () {
        var self = this;
        return self.getAutocam().resetOrientation();
    }

    function setCurrentViewAsHome () {
        var self = this;
        return self.getAutocam().setCurrentViewAsHome(false);
    }

    function setCurrentViewAsFront () {
        return this.getAutocam().setCurrentViewAsFront(false);
    }

    function setCurrentViewAsTop () {
        var self = this;
        return self.getAutocam().setCurrentViewAsTop(false);
    }

    function setSceneViewOrthographic () {
        var self = this;
        return self.getAutocam().toOrthographic();
    }

    // TODO this is confusingly named
    // TODO soudns like it's setting the viewer's perspective
    function setSceneViewPerspective () {
        var self = this;
        return self.getAutocam().toPerspective();
    }

    // returns the autocam.  we do it this way so that autocam is defined already
    function getAutocam() {
        var self = this;
        return self.MoleculeViewer.autocam;
    }

    // We need to get autocam this way since autocam has not been initialized when this
    // constructor runs.
    this.getAutocam = getAutocam;
    // return an object with the API methods
    return {
        appID: this.appID,
        container: this.container,
        // state getting / setting methods
        generateSnapshotURL: generateSnapshotURL.bind(this),
        loadSnapshotFromURL: function (url, cb) { stub();},
        getState: getState.bind(this),
        setState: setState.bind(this),
        // open, import, export methods
        open: function (fileType, fileBuffer) { stub();},
        importPDB: importPDB.bind(this),
        uploadCIF: uploadCIF.bind(this),
        setAssembly: setAssembly.bind(this),
        exportMolecule: exportMolecule.bind(this),
        screenshot: screenshot.bind(this),
        raycast: function () { stub();},
        // selection methods
        getSelection: getSelection.bind(this),
        select: select.bind(this),
        clearSelection: clearSelection.bind(this),
        // selection-based getters / setters
        getCenter: getCenter.bind(this),
        setColor: setColor.bind(this),
        setRepresentation: setRepresentation.bind(this),
        setSurfaceOpacity: setSurfaceOpacity.bind(this),
        // annotation methods
        annotate: annotate.bind(this),
        removeAllAnnotations: removeAllAnnotations.bind(this),
        // geometry methods
        material: material.bind(this),
        phongMaterial: phongMaterial.bind(this),
        drawMesh: drawMesh.bind(this),
        drawGeom: drawGeom.bind(this),
        drawCube: drawCube.bind(this),
        drawSphere: drawSphere.bind(this),
        drawCircle: drawCircle.bind(this),
        drawCylinder: drawCylinder.bind(this),
        drawArrow: drawArrow.bind(this),
        removeAllGeometries: removeAllGeometries.bind(this),
        // camera/view control methods
        explode: explode.bind(this),
        viewHome: viewHome.bind(this),
        viewFront: viewFront.bind(this),
        viewBack: viewBack.bind(this),
        viewTop: viewTop.bind(this),
        viewBottom: viewBottom.bind(this),
        viewLeft: viewLeft.bind(this),
        viewRight: viewRight.bind(this),
        focusOnSelection: focusOnSelection.bind(this),
        getSelectionBounds: getSelectionBounds.bind(this),
        getVisibleBounds: getVisibleBounds.bind(this),
        setPivotPoint: setPivotPoint.bind(this),
        // view / camera setter methods
        resetCamera: resetCamera.bind(this),
        resetOrientation: resetOrientation.bind(this),
        setCurrentViewAsHome: setCurrentViewAsHome.bind(this),
        setCurrentViewAsFront: setCurrentViewAsFront.bind(this),
        setCurrentViewAsTop: setCurrentViewAsTop.bind(this),
        setSceneViewOrthographic: setSceneViewOrthographic.bind(this),
        setSceneViewPerspective: setSceneViewPerspective.bind(this),
        // low-level camera object, for advanced users
        autocam: getAutocam.bind(this),
        mv: this.MoleculeViewer
    };
};
//TODO write the destructor
Autodesk.$ADSKMOLVIEW.prototype.dtor = function dtor() {

};;//additions from a later version of three.js needed for our imposters(instances) and buffer geometries
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function (array, itemSize, meshPerAttribute, dynamic) {

    THREE.DynamicBufferAttribute.call( this, array, itemSize );

    this.dynamic = dynamic || false;
    this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.DynamicBufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.clone = function () {

    return new THREE.InstancedBufferAttribute(new this.array.constructor(this.array), this.itemSize, meshPerAttribute, dynamic);

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function () {

    THREE.BufferGeometry.call( this );

    this.type = 'InstancedBufferGeometry';
    this.maxInstancedCount = -1;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset, instances ) {

    this.drawcalls.push( {

        start: start,
        count: count,
        index: indexOffset !== undefined ? indexOffset : 0,
        instances: instances
    } );

},

    THREE.InstancedBufferGeometry.prototype.clone = function () {

        var geometry = new THREE.InstancedBufferGeometry();

        for ( var attr in this.attributes ) {

            var sourceAttr = this.attributes[attr];
            geometry.addAttribute( attr, sourceAttr.clone() );

        }

        for ( var i = 0, il = this.offsets.length; i < il; i++ ) {

            var offset = this.offsets[i];

            geometry.offsets.push( {

                start: offset.start,
                index: offset.index,
                count: offset.count,
                instances: offset.instances

            } );

        }

        return geometry;

    };

THREE.BufferGeometry.prototype.copy = function(geometry){

    var attributes = geometry.attributes;
    var offsets = geometry.offsets;

    for ( var name in attributes ) {

        var attribute = attributes[ name ];

        this.addAttribute( name, attribute.clone() );

    }

    for ( var i = 0, il = offsets.length; i < il; i ++ ) {

        var offset = offsets[ i ];

        this.offsets.push( {

            start: offset.start,
            index: offset.index,
            count: offset.count

        } );

    }

    return this;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );


// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    THREE.BufferGeometry.call( this );

    this.type = 'SphereBufferGeometry';

    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;

    widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
    heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

    var thetaEnd = thetaStart + thetaLength;

    var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

    var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    var index = 0, vertices = [], normal = new THREE.Vector3();

    for ( var y = 0; y <= heightSegments; y ++ ) {

        var verticesRow = [];

        var v = y / heightSegments;

        for ( var x = 0; x <= widthSegments; x ++ ) {

            var u = x / widthSegments;

            var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
            var py = radius * Math.cos( thetaStart + v * thetaLength );
            var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

            normal.set( px, py, pz ).normalize();

            positions.setXYZ( index, px, py, pz );
            normals.setXYZ( index, normal.x, normal.y, normal.z );
            uvs.setXY( index, u, 1 - v );

            verticesRow.push( index );

            index ++;

        }

        vertices.push( verticesRow );

    }

    var indices = [];

    for ( var y = 0; y < heightSegments; y ++ ) {

        for ( var x = 0; x < widthSegments; x ++ ) {

            var v1 = vertices[ y ][ x + 1 ];
            var v2 = vertices[ y ][ x ];
            var v3 = vertices[ y + 1 ][ x ];
            var v4 = vertices[ y + 1 ][ x + 1 ];

            if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
            if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

        }

    }

    this.addAttribute( 'index', new THREE.BufferAttribute( new Uint16Array( indices ), 1 )  );
    this.addAttribute( 'position', positions );
    this.addAttribute( 'normal', normals );
    this.addAttribute( 'uv', uvs );

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

THREE.SphereBufferGeometry.prototype.clone = function () {

    var geometry = new THREE.SphereBufferGeometry(
        this.parameters.radius,
        this.parameters.widthSegments,
        this.parameters.heightSegments,
        this.parameters.phiStart,
        this.parameters.phiLength,
        this.parameters.thetaStart,
        this.parameters.thetaLength
    );

    geometry.copy( this );

    return geometry;

};;/**
 * Created by andrewkimoto on 11/29/16.
 */
var Autodesk = Autodesk || {};
Autodesk.Viewing = Autodesk.Viewing || {};

/* These constants are used to define the standard set of tools.
*
* @enum {string}
* @readonly
* @memberof Autodesk.Viewing
*/
Autodesk.Viewing.TOOLBAR = {
    NAVTOOLSID:      "navTools",
    MODELTOOLSID:    "modelTools",
    SELTOOLSID:    "selTools",
    SETTINGSTOOLSID: "settingsTools"
};

//constructor for molecule viewer app
Autodesk.MoleculeViewer = function(app, container, options) {
    var me = Autodesk.MoleculeViewer.prototype;
    //reference to the parent $ADSKMOLVIEW object, used to reference other members (e.g. MolMan)
    this.app = app;
    // we use the standard div structure unless an alternate structure is passed in as one of the options
    var viewer3dDiv = container;
    viewer3dDiv.classList.add('viewer3d'); // make sure that the div has the viewer3d class
    Autodesk.Viewing.Viewer3D.call(this, viewer3dDiv, options);

    var that = this;

    var svfURL;

    var stringToDOM = Autodesk.Viewing.Private.stringToDOM = function(str) {
        var d = document.createElement("div");
        d.innerHTML = str;
        return d.firstChild;
    };


    //unique id for the app instance.
    this.appID = THREE.Math.generateUUID;

    this.Loader = new Autodesk.Viewing.MolViewerLoader();

    me.initializeCookie.call(this,options);
};

Autodesk.MoleculeViewer.prototype = Object.create(Autodesk.Viewing.Viewer3D.prototype);
Autodesk.MoleculeViewer.prototype.constructor = Autodesk.MoleculeViewer;

Autodesk.MoleculeViewer.prototype._initialize = function _initialize(options) {
    var that = this;
    var svfURL = options.svf;

    if (typeof svfURL === 'string') {
        // Load local svf file.
        options.env = "Local";

        Autodesk.Viewing.Initializer(options, function() {
            that.app.Loader.initViewerCB(that,options);
        });

    } else if (typeof svfURL === 'string' && svfURL.indexOf("urn:") === 0) {
        // Load remote svf file through viewing service.
        Autodesk.Viewing.Initializer(options, function() {
            that.start();
            that.load(svfURL);
        });
    }
};



Autodesk.MoleculeViewer.prototype.initializeCookie = function initializeCookie(options) {
    var avp = Autodesk.Viewing.Private;
    var sessionID = Autodesk.Viewing.Private.getParameterByName('session');
    var loadEmpty = avp.getParameterByName("empty") === 'true';

    // set the connectionID for use with all api calls the ensure constant load balancer server.
    this.Loader.setConnectionID();

    if(!sessionID){
        if(!loadEmpty) {
            sessionID = this.Loader.getCookieItem('sessionCookie');
            if(sessionID===null || sessionID === undefined){
                sessionID = 'default';
            }
        }else{
            sessionID = null; //if load empty AND no session, if session always do it
        }
    }
    if(sessionID === "0"){ //special case to clear and load empty
        this.sessionID = null;
    }else {
        this.sessionID = sessionID;
        this.Loader.sessionID = sessionID; // initviewercb uses this to load the session
    }
    //toolbars
    this.getToolbar(true,false,true);
    options = this.app.Loader.getOptionsFromQueryString(null,options);
    this.options = options;
    this._initialize(options);
};

Autodesk.MoleculeViewer.prototype.loadExtensions = function loadExtensions(disabledExtensions) {

    this.loadExtension('Autodesk.DefaultTools.NavTools', {mode: "3d",app: this.app});

    if (!disabledExtensions || (disabledExtensions && !disabledExtensions.explode)) {
        this.loadExtension('Autodesk.Explode', {app: this.app});
    }

    if (!disabledExtensions || (disabledExtensions && !disabledExtensions.measure)) {
        this.loadExtension('Autodesk.Measure', {app: this.app});
    }
    if (!disabledExtensions || (disabledExtensions && !disabledExtensions.annotate)) {
        this.loadExtension('Autodesk.Annotate', {app: this.app});
    }
    if (!disabledExtensions || (disabledExtensions && !disabledExtensions.section)) {
        this.loadExtension('Autodesk.Section', {app: this.app});
    }
    if (!disabledExtensions || (disabledExtensions && !disabledExtensions.webVR)) {
        this.loadExtension('Autodesk.Viewing.webVR', {app: this.app});
    }
};


Autodesk.MoleculeViewer.prototype.loadModel = function (url, options, onSuccessCallback, onErrorCallback, initAfterWorker) {

    var viewer = this;

    function createUI(model) {
        if (!viewer.running) {
            avp.logger.error("createUI expects the viewer to be running.");
            return;
        }
        viewer.createUI(model);
    }

    function onSuccessChained(model) {

        //TODO: The exact timeout needs to be tuned for best
        //CPU utilization and shortest frame length during startup.
        setTimeout(createUI.bind(createUI, model), 1);

        if (onSuccessCallback)
            onSuccessCallback.apply(onSuccessCallback, arguments);

    }

    var that = this;
    function onFailureChained(errorCode) {
        avp.ErrorHandler.reportError(viewer.container, errorCode); // Show UI dialog
        onErrorCallback && onErrorCallback.apply(onErrorCallback, arguments);
    }

    var res = Autodesk.Viewing.Viewer3D.prototype.loadModel.call(this, url, options, onSuccessChained, onFailureChained, initAfterWorker);

    return res;
};

Autodesk.MoleculeViewer.prototype.initHotkeys = function (model) {
    var viewer = this;
    var keys = Autodesk.Viewing.theHotkeyManager.KEYCODES;
    var onPress;
    var onRelease;

    // Add Roll hotkey
    var previousToolForRoll;
    onPress = function () {
        if (viewer.toolController.getIsLocked() || !viewer.navigation.isActionEnabled('roll')) {
            return false;
        }

        previousToolForRoll = viewer.getActiveNavigationTool();
        viewer.setActiveNavigationTool("worldup");
        return true;
    };
    onRelease = function () {
        if (viewer.toolController.getIsLocked() || !viewer.navigation.isActionEnabled('roll')) {
            return false;
        }

        viewer.setActiveNavigationTool(previousToolForRoll);
        return true;
    };
    Autodesk.Viewing.theHotkeyManager.pushHotkeys("Autodesk.ROLL", [{
        keycodes: [keys.ALT, keys.SHIFT],
        onPress: onPress,
        onRelease: onRelease
    }], {tryUntilSuccess: true});
};

/**
 * Returns a toolbar.
 * @param {boolean} create - If true and the toolbar does not exist, it will be created.
 * @param {boolean} selTools - If true we add the selection tools.
 * @param {boolean} navTools - If true we add the 3D navigation tools.
 * @returns {Autodesk.Viewing.UI.ToolBar} Returns the toolbar.
 */
Autodesk.MoleculeViewer.prototype.getToolbar = function(create,selTools,navTools)
{
    if (!this.toolbar) {
        if (create) {
            var AVU = Autodesk.Viewing.UI;
            this.toolbar = new AVU.ToolBar( 'guiviewer3d-toolbar' );
            if (selTools) {
                this.selTools = new AVU.RadioButtonGroup( Autodesk.Viewing.TOOLBAR.SELTOOLSID );
                this.toolbar.addControl(this.selTools);
            }

            if (navTools) {
                this.navTools = new AVU.RadioButtonGroup( Autodesk.Viewing.TOOLBAR.NAVTOOLSID );
                this.toolbar.addControl(this.navTools);
            }
            this.container.appendChild(this.toolbar.container);
            this.toolbar.container.style.display = 'none'; // Will make visible when TOOLBAR_CREATED_EVENT fires
        }
    }
    return this.toolbar;
};

// This creates only a minimal ui -- hotkeys and toolbar only
Autodesk.MoleculeViewer.prototype.createUI = function createUI(model) {

    // We only support UI for initially loaded model.
    if (this.model !== model) {
        return;
    }

    var self = this;
    var viewer = this;

    var disabledExtensions = this.options.config3d.disabledExtensions;

    this.initHotkeys(model);

    //Optional rendering options panel + button
    if (avp.ENABLE_DEBUG) {
        this.initDebugTools();
    }

    // Dispatch a toolbar created event
    this.toolbar.container.style.display = 'block'; // Show toolbar before event fires
    this.fireEvent({type: Autodesk.Viewing.TOOLBAR_CREATED_EVENT});

    this.centerToolBar = function () {
        self.toolbar.container.style.left = 'initial';
        self.toolbar.container.style.right = '0px';
    };
    this.toolbar.addEventListener(Autodesk.Viewing.UI.ToolBar.Event.SIZE_CHANGED, this.centerToolBar);

    this.resize();
    window.setTimeout(function() {
        self.loadExtensions(self.options.config3d.disabledExtensions);
    },1);
};;/**
 * Created by andrewkimoto on 12/5/16.
 */
var Autodesk = Autodesk || {};
Autodesk.Viewing = Autodesk.Viewing || {};

/* These constants are used to define the standard set of tools.
 *
 * @enum {string}
 * @readonly
 * @memberof Autodesk.Viewing
 */
Autodesk.Viewing.TOOLBAR = {
    NAVTOOLSID:      "navTools",
    MODELTOOLSID:    "modelTools",
    SELTOOLSID:    "selTools",
    SETTINGSTOOLSID: "settingsTools"
};

Autodesk.Viewing.TOOLBAR_CREATED_EVENT = 'toolbarCreated';
Autodesk.Viewing.VIEW_CUBE_CREATED_EVENT = 'viewCubeCreated';

var stringToDOM = avp.stringToDOM = function(str) {
    var d = document.createElement("div");
    d.innerHTML = str;
    return d.firstChild;
};

//constructor for molecule viewer app
Autodesk.GuiMoleculeViewer = function(app, container, options) {
    this.app = app;
    this.gui = true;  // used to detect that this is the gui version

    var me = Autodesk.GuiMoleculeViewer.prototype;
    var structure;

    if (options) {
        structure = options.structure; // use a custom div structure if one is passed
    }

    var viewer3dDiv;
    // we use the standard div structure unless an alternate structure is passed in as one of the options
    var divResults = me.createDivStructure(app,container, structure);
    if (divResults.viewer3dDiv) {
        viewer3dDiv = divResults.viewer3dDiv;
    } else {
        console.error('We need a viewer3dDiv div to host the 3D.');
        return;
    }


    Autodesk.Viewing.Viewer3D.call(this, viewer3dDiv, options);

    var that = this;

    var svfURL;
    var setToolbarVisibility = function setToolbarVisibility() {
        if (options.topViews === 'presentation') {
            that.app.container.querySelector('#selTools').classList.add('hidden');
        }
        if (Autodesk.Viewing.isMobileDevice()) {
            that.app.container.querySelector('#guiviewer3d-toolbar').style.opacity = '0';
            that.app.container.querySelector('#guiviewer3d-toolbar').style.display = 'none';
        }
    };

    var stringToDOM = Autodesk.Viewing.Private.stringToDOM = function(str) {
        var d = that.app.container.createElement("div");
        d.innerHTML = str;
        return d.firstChild;
    };

    var initViewCube = function () {
        var that = this;
        if (!this.viewCubeUi) {
            this.createViewCube();
        }
        //Delay this to the next frame so that the current frame can render fast and display the geometry.
        setTimeout(function() {
            that.displayViewCube(that.options.config3d.showViewCube);
            that.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, initViewCubeBind);
        }, 1);
    };

    var setToolbarVisibilityBind = setToolbarVisibility.bind(this);
    var initViewCubeBind = initViewCube.bind(this);

    this.addEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, this.app.Loader.loadInitialViews.bind(this.app.Loader));
    this.addEventListener(Autodesk.Nano.MODEL_START_LOADED_EVENT,setToolbarVisibilityBind);
    this.addEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT,setToolbarVisibilityBind);
    this.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, initViewCubeBind);

    me.initializeCookie.call(this,options);
};

Autodesk.GuiMoleculeViewer.prototype = Object.create(Autodesk.MoleculeViewer.prototype);
Autodesk.GuiMoleculeViewer.prototype.constructor = Autodesk.GuiMoleculeViewer;

Autodesk.GuiMoleculeViewer.prototype._initialize = function _initialize(options) {
    var that = this;
    var svfURL = options.svf;



    this.app.ViewManager.parseTopViewData();

    if (typeof svfURL === 'string') {
        // Load local svf file.
        options.env = "Local";

        Autodesk.Viewing.Initializer(options, function() {
            that.app.Loader.initViewerCB(that,options);
            that.loadExtensions();
        });

    } else if (typeof svfURL === 'string' && svfURL.indexOf("urn:") === 0) {
        // Load remote svf file through viewing service.
        Autodesk.Viewing.Initializer(options, function() {
            that.start();
            that.load(svfURL);
        });
    }
};

Autodesk.GuiMoleculeViewer.prototype.loadViewData = function loadViewData(options) {
    var _that = this;
    var viewFile = 'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/config/mol-topviews.json';
    if (options.topViews && options.topViews !=="") {
        viewFile = 'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/config/' + options.topViews + (!options.topViews.match(/\.json$/) ? '.json' : '');
    }

    var promise = _that.app.ApiConnector.loadViewData(options,viewFile)
        .then(function(data){
            Autodesk.Viewing.topViewData = JSON.parse(data);
            _that._initialize(options);

            if (Autodesk.Viewing.isTouchDevice()) {
                document.body.className += "mobile";
                document.getElementById('guiviewer3d-toolbar').classList.add('hide-on-mobile');
            }
            if (_that.options.topViews === 'presentation') {
                _that.app.container.querySelector('#selTools').classList.add('hidden');
            }
        },function(data){
            console.error('failed',data);
        })
        .catch(function(error) {
            console.error('there was an error in LoadViewData',error);
        });
};

Autodesk.GuiMoleculeViewer.prototype.initializeCookie = function initializeCookie(options) {
    var avp = Autodesk.Viewing.Private;
    var sessionID = Autodesk.Viewing.Private.getParameterByName('session');
    var loadEmpty = avp.getParameterByName("empty") === 'true' ? true : false;

    // set the connectionID for use with all api calls the ensure constant load balancer server.
    this.app.Loader.setConnectionID();

    if(!sessionID){
        if(!loadEmpty) {
            sessionID = this.app.Loader.getCookieItem('sessionCookie');
            if(sessionID===null || sessionID === undefined){
                sessionID = 'default';
            }
        }else{
            sessionID = null; //if load empty AND no session, if session always do it
        }
    }
    if(sessionID === "0"){ //special case to clear and load empty
        this.sessionID = null;
    }else {
        this.sessionID = sessionID;
        this.app.Loader.sessionID = sessionID; // initviewercb uses this to load the session
    }

    //toolbars
    this.getToolbar(true,true,true);
    options = this.app.Loader.getOptionsFromQueryString(null, options);
    this.options = options;
    this.loadViewData(options);

};


Autodesk.GuiMoleculeViewer.prototype.loadModel = function (url, options, onSuccessCallback, onErrorCallback, initAfterWorker) {

    var viewer = this;

    function createUI(model) {
        if (!viewer.running) {
            avp.logger.error("createUI expects the viewer to be running.");
            //setTimeout(createUI, 1);
            return;
        }

        viewer.createUI(model);
    }

    function onSuccessChained(model) {

        //TODO: The exact timeout needs to be tuned for best
        //CPU utilization and shortest frame length during startup.
        setTimeout(createUI.bind(createUI, model), 1);

        if (onSuccessCallback)
            onSuccessCallback.apply(onSuccessCallback, arguments);

    }

    var that = this;
    function onFailureChained(errorCode) {
        avp.ErrorHandler.reportError(viewer.container, errorCode); // Show UI dialog
        onErrorCallback && onErrorCallback.apply(onErrorCallback, arguments);
    }

    var res = Autodesk.Viewing.Viewer3D.prototype.loadModel.call(this, url, options, onSuccessChained, onFailureChained, initAfterWorker);

    return res;
};


Autodesk.GuiMoleculeViewer.prototype.createUI = function createUI(model) {

    // We only support UI for initially loaded model.
    if (this.model !== model) {
        return;
    }

    var self = this;
    var viewer = this;

    var disabledExtensions = this.options.config3d.disabledExtensions;

    var initViewCube = function () {
        if (!this.viewCubeUi) {
            this.createViewCube();
        }
        //Delay this to the next frame so that the current frame can render fast and display the geometry.
        setTimeout(function() {
            self.displayViewCube(self.options.config3d.showViewCube);
            self.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, initViewCubeBind);
        }, 1);
    };

    var initViewCubeBind = initViewCube.bind(this);

    this.initHotkeys(model);

    this.loadExtension('Autodesk.DefaultTools.NavTools', {mode: model.is2d() ? "2d" : "3d"});

    //Optional rendering options panel + button
    if (avp.ENABLE_DEBUG) {
        this.initDebugTools();
    }

    // Dispatch a toolbar created event
    this.toolbar.container.style.display = 'block'; // Show toolbar before event fires
    this.fireEvent({type: Autodesk.Viewing.TOOLBAR_CREATED_EVENT});

    this.options.config3d.wantInfoButton = false;
    this.createViewCube();

    // Dispatch a view cube created event
    this.fireEvent({type: Autodesk.Viewing.VIEW_CUBE_CREATED_EVENT});

    this.centerToolBar = function () {
        self.toolbar.container.style.left = 'initial';
        self.toolbar.container.style.right = '0px';
    };
    this.toolbar.addEventListener(Autodesk.Viewing.UI.ToolBar.Event.SIZE_CHANGED, this.centerToolBar);

    this.resize();
    window.setTimeout(function() {
        self.loadExtensions(self.options.config3d.disabledExtensions);
        self.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, initViewCubeBind);
    },1);
};


Autodesk.GuiMoleculeViewer.prototype.createDivStructure = function createDivStructure(app, container,structure) {
    var child,
        elements = [],
        parent,
        main,
        viewer3dDiv;
    var getElement = function(name) {
        var i;
        for (i = 0; i < elements.length; ++i) {
            if (elements[i].structureName === name) {
                return elements[i];
            }
        }
        return false;
    };

    if (!structure) {
        structure = [
            {name : "main", id : "main", class : "main", parent : null},
            {name : "header", id : "header", class : "header", parent : "main"},
            {name: "contents", id : "contents", class : "contents", parent: "main"},
            {name: "center", id : "center", class : "center", parent: "contents"},
            {name: "viewer3d", id : "viewer3d", class : "viewer3d", parent: "center", isViewer3d: true},
            { name: "macro", id : "macro", class : "", parent: "center"}
        ];
    }

    for (i = 0; i < structure.length; ++i) { //create all elements
        child = document.createElement('div');
        child.setAttribute('id',structure[i].id + '-' + app.appID);
        child.setAttribute('class',structure[i].class);
        child.parent = structure[i].parent;
        child.structureName = structure[i].name;
        if (structure[i].isViewer3d) {
            viewer3dDiv = child;
        }
        elements.push(child);
    }

    for (var i = 0; i < elements.length; ++i) {
        if (elements[i].parent) {
            parent = getElement(elements[i].parent);
            if (parent) {
                parent.appendChild(elements[i]);
                delete elements[i].parent;
            }
        } else {
            main = elements[i];
            delete elements[i].parent;
        }
    }
    container.appendChild(main);
    return {status: 'success', viewer3dDiv: viewer3dDiv};
};;/**
 * Created by andrewkimoto on 8/24/15.
 */
//constructor
Autodesk.Viewing.MolViewer = function MolViewer(viewer,molMan,container) {
    this.viewer = viewer;
    this.molMan = molMan;
    this.container = container;
    this._initialize();
};


Autodesk.Viewing.MolViewer.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.prototype;
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.prototype.reInitViewer = function reInitViewer() {
    var options = this.molMan.getPDBData();
    options = this.getShareOptions(options);
    this.initViewer(options);

};


Autodesk.Viewing.MolViewer.prototype._initializeEvents = function _initializeEvents() {
    var self = this;

    this.getUrlWithSessionBind = self.getUrlWithSession.bind(self);

    //check to see if we need to apply a state saved in the URL
    this.viewer.addEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT, function(e) {if(!e || !e.modelType || e.modelType === 'mol'){
        this.checkState();
    }}.bind(this));
    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_UNINITIALIZED, function() {this.reInitViewer();}.bind(this));
    if(!Autodesk.Viewing.isMobileDevice()) {
        self.viewer.addEventListener(Autodesk.Nano.SESSION_SAVED_EVENT, self.getUrlWithSessionBind);
    }
};

Autodesk.Viewing.MolViewer.prototype.resetViewer = function resetViewer() {
    //NO!this.viewer.fireEvent(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED);
    var model;
    for ( model in this.molMan.molModels) {
        if (this.molMan.molModels.hasOwnProperty(model)) {
            this.molMan.deleteMolModel(model);
        }
    }
    this.molMan.deleteInstances(null,true);//mz need to have the molmodel due this later.
    this.molMan.clearCmdStack();
};

Autodesk.Viewing.MolViewer.prototype.resetShotParams = function resetShotParams() {
    this.viewer.autocam.shotParams.duration = loader.options.config3d.autocamDuration;
    this.viewer.autocam.shotParams.destinationPercent = loader.options.config3d.autocamDestinationPercent;
};

Autodesk.Viewing.MolViewer.prototype.checkState = function checkState() {
    var url = document.location.href;
    if (url.match(/&state=/)) {
        this.restoreMolViewerState(); //state that deals with 3D needs to get moved up
    } else {
        //mz should never be done by 2d view. it's data state and 3d state info.
        //TheMolMan.setDefaultReps(true);
        //TheMolMan.viewer.utilities.fitToView();
    }
};

Autodesk.Viewing.MolViewer.prototype.getShareOptions = function getShareOptions(options) {
    var viewerOnly = Autodesk.Viewing.Private.getParameterByName("vieweronly");
    var showViewCube =  Autodesk.Viewing.Private.getParameterByName("viewcube");
    var noSplash =  Autodesk.Viewing.Private.getParameterByName("nosplash");
    options.viewerOnly = (viewerOnly === 'true');
    options.showViewCube = (showViewCube !== 'false');
    options.noSplash = (noSplash === 'true');
    return options;
};
//need to redo this mz
Autodesk.Viewing.MolViewer.prototype.getMolViewerState = function getMolViewerState() {
    var jsonObj = this.viewer.getState({seedURN: true, viewport: true, cutplanes: true, measure: true});
    if (typeof this.annotateMan !== "undefined") {
        jsonObj.annotate = this.annotateMan.toJSONObj();
    }
    if (typeof this.measureMan !== "undefined") {
        jsonObj.measure = this.measureMan.toJSONObj();
    }
    jsonObj.mol =  this.molMan.toJSONObj();
    return jsonObj;
};

Autodesk.Viewing.MolViewer.prototype.getNanoURL = function getNanoURL(args) {
    var viewCube = true;
    var noSplash = true;
    var state = this.getMolViewerState();
    var svfParam = state.seedURN;
    var host = document.location.host;
    var protocol = document.location.protocol;
    delete state.seedURN;
    var stateParam = /*encodeURI */(JSON.stringify(state));//no longer encodeURI since it's compressed

    stateParam = /*encodeURI*/(LZString144.compressToEncodedURIComponent(stateParam));
    return protocol + '//' + host + '/?svf=' + svfParam +'&viewcube=' + viewCube + '&nosplash=' + noSplash + '&state=' + stateParam + '&tV=presentation';

};

// Returns the html to be embedded in an iframe
Autodesk.Viewing.MolViewer.prototype.getNanoFrame = function getNanoFrame(width,height) {
    var args = {hideBrowser: false, hideInspector: false, hideHeader: true, disableBrowser: true, disableInspector: true};
    var url = this.getNanoURL(args);
    height = height ? height : '550px';
    width = width ? width : '980px';
    return '<iframe style = "height: ' + height + '; width: ' + width + ';" src="' + url +  '"></iframe>';
};

Autodesk.Viewing.MolViewer.prototype.restoreMolViewerState = function restoreMolViewerState() {
    var url = document.location.href,
        paramString = url.split('?')[1],
        params = paramString.split('&'),
        svf = paramString.split('/')[paramString.split('/').length -1].replace(/\.svf.+/,''),
        i,
        stateString,
        stateObj;
    for(i = 0;i < params.length;i++) {
        if (params[i].match(/^state=/)) {
            stateString = params[i].replace(/^state=/, '');
            stateString = LZString144.decompressFromEncodedURIComponent((stateString));
            i = params.length;
        }
    }

    if(!stateString) {
        return;
    }
    stateObj = JSON.parse(stateString);
    this.molMan.fromJSONObj(stateObj);
};

Autodesk.Viewing.MolViewer.prototype.buildSessionUrl = function buildSessionUrl(id) {
    var url = window.location.protocol + '//' + window.location.host + '/?session='+id;
    return url;
};

Autodesk.Viewing.MolViewer.prototype.updateMolViewer = function updateMolViewer(viewer) {
    this.viewer = viewer;
    Autodesk.Viewing.MolViewer._instance = this;
    window.MolViewer = Autodesk.Viewing.MolViewer._instance;
};

//get url with current session id
Autodesk.Viewing.MolViewer.prototype.getUrlWithSession = function getUrlWithSession(event) {
    var url = window.location.href;
    var sessionId;
    if (!url.match(/session=/)) {
        sessionId = event.id;
        url += (url.match(/\?/) ? '&' : '?') + 'session=' + sessionId;
    }
    this.setQrCode(url);
};

//create the qrCode image, clone to vr dialog if open
Autodesk.Viewing.MolViewer.prototype.setQrCode = function setQrCode(url) {
    var qrDiv = this.container.querySelector('#qrCode');
    var target = null;
    var origin = null;
    var image = null;
    var throbber = null;
    var targetUrl = null;
    var qrCode;
    if (!qrDiv) {
        qrDiv = document.createElement('div');
        qrDiv.setAttribute('id','qrCode');
        qrDiv.setAttribute('data-url',url);
        qrDiv.setAttribute('title','');
        this.container.appendChild(qrDiv);
    } else if (qrDiv.firstChild) {
        qrDiv.removeChild(qrDiv.firstChild);
        qrDiv.setAttribute('data-url',url);
    }

    qrCode = new QRCode(this.container.querySelector('#qrCode'), {
        text: url,
        width: 120,
        height: 120,
        useSVG: true,
        colorDark: '#1d1b25',
        colorLight: '#dddddd'
    });
    if(document.querySelector('#vrDialog')) {
        target = this.container.querySelector('#qrContainer');
        origin = this.container.querySelector('#qrCode');
        targetUrl = document.querySelector('.cardboard-link');
        throbber = document.querySelector('#cardboardThrobber');
        if (origin) {
            image = origin.firstChild;
        }

        if(image && target) {
            image = image.cloneNode(true);
            target.appendChild(image);
            targetUrl.setAttribute('href',origin.getAttribute('data-url'));
            target.classList.add('opaque');
            targetUrl.classList.add('opaque');
            throbber.classList.add('hidden');
        }
    }
};;
//atomPositions??? residues?

Autodesk.Nano.Parser = function () {


    function _createHeaderObj(){
        return {
            author: "Bob Bob",
            bFactorMin: Number.POSITIVE_INFINITY,
            bFactorMax: Number.NEGATIVE_INFINITY,
            id: "PDBID",
            numAtoms: 0 , //MZ Just use size of atomMetaData Array?
            title:  "Title",
            offsetX: 0.0, //offsets aren't used.. MZ?
            offsetY: 0.0,
            offsetZ: 0.0
        };
    };


    function _createAtomMetadataObj() {
      return {
          id: 0,
          isHet: false,
          x: 0.0,
          y: 0.0,
          z: 0.0, //move to seperate array for cache hits?
          bonds: {positions: []},
          bondsIndex: [],
          altLoc: "", 
          bFactor : 0.0,
          chainID: "A",
          detailType: "O5'",
          element: "O",
          elementUpper: "O",
          resNumber: "5",
          residue: "U",
          seqNo: 1,
          ssType : "c", //"c" "h"

      };

    };

    // Create an object storing secondary structure information.
    //
    // type - The type of secondary structure: 's' = sheet, 'h' = helix, 'c' = coil.

    function _createSecondaryStructureObj(type, initResName, initChainID, initSeqNum, endResName, endChainID, endSeqNum) { 
        return {
            type: type,
            initResName: initResName, 
            initChainID: initChainID, 
            initSeqNum: initSeqNum, 
            endResName: endResName, 
            endChainID: endChainID, 
            endSeqNum: endSeqNum
        };
    };

    function _createResidueObj(){
        return {
            id: "1",
            name: "Z",
            type: "a",
            atoms: [], 
            maxX: Number.NEGATIVE_INFINITY,
            maxY: Number.NEGATIVE_INFINITY,
            maxZ: Number.NEGATIVE_INFINITY,
            minX: Number.POSITIVE_INFINITY,
            minY: Number.POSITIVE_INFINITY,
            minZ: Number.POSITIVE_INFINITY
        };
    };

    function _createChainObj(){
        return {
            id: "A",
            entityID: "1",
            //type: "w", davep
            type: undefined,
            residues: {},
            bonds: [],
            maxX: Number.NEGATIVE_INFINITY,
            maxY: Number.NEGATIVE_INFINITY,
            maxZ : Number.NEGATIVE_INFINITY,
            minX: Number.POSITIVE_INFINITY,
            minY: Number.POSITIVE_INFINITY,
            minZ: Number.POSITIVE_INFINITY

        };
    };

    function _createEntityObj(){
        return {
            id: "Bob",
            assemblyIDs: [],
            chainIDs: [],
            description: "Protein Dude",
            isForAssembly: false, //MZ may not be needed
            isVisible: true,  //MZ also may not be needed
            maxX: Number.NEGATIVE_INFINITY,
            maxY: Number.NEGATIVE_INFINITY,
            maxZ: Number.NEGATIVE_INFINITY,
            minX: Number.POSITIVE_INFINITY,
            minY: Number.POSITIVE_INFINITY,
            minZ: Number.POSITIVE_INFINITY
        };
    };

    function _calcMaxNumAtoms(atoms, assemblies){
        var numAtoms = atoms.length;
        var maxNumAtoms = numAtoms;
        var count, assembly;
        for( var id in assemblies){
            assembly = assemblies[id];
            count = numAtoms * assembly.transforms.length;
            if(count > maxNumAtoms){
                maxNumAtoms = count;
            };
        }
        return maxNumAtoms;

    };
    function _createAssemblyObj(){
        return {
            assemblyID: "1",
            chains: [],  //ID's like "A", AA, B, C
            details: "Author created assembly",
            entityID: "Entity 1",
            transforms: []
        };
    };
    //assemblies use a subset of chains, for each unique set
    //we build a new entity for it, marking it isForAssemby = true
    function _getEntityForTheseAssemblyChains(entities, chainIDs, assemblyID){
        var goodEntity = null;
        var count =0;
        for(var id in entities){
            ++count;
            var entity = entities[id];
            if(entity.isForAssembly){
                if(entity.chainIDs.length === chainIDs.length){ //okay may match and assume it's always ordered!!
                    for(var i = 0; i < chainIDs.length; i++) {
                        if(chainIDs[i] !== entity.chainIDs[i])
                            break;
                    }
                    if(i === chainIDs.length) {
                        entity.assemblyIDs.push(assemblyID);
                        return entity;
                    }
                }
            }
        }
        if(!goodEntity){
            ++count;
            entity = _createEntityObj();
            entity.id = "Assembly:" +  count.toString();
            entity.assemblyIDs.push(assemblyID);
            entity.chainIDs = chainIDs;
            entity.description = assemblyID;
            entity.isForAssembly = true;
            entity.isVisible = false;
            entities[entity.id] = entity;
        }
        return entity;
    }

    function _processTransformsForAssemblies(assemblies,transforms){
        var tnew,t1,t2;
        var s,s1;
        var ids;
        function _getIDs(str){
            //first see if -
            var ids =[];
            var multi = str.split('-');
            if(multi.length==2){
                var start = parseInt(multi[0]);
                var end = parseInt(multi[1]);
                for(var i =start; i <= end; ++i){
                    var s = i.toString();
                    ids.push(i);
                }
            }else{ //, seperate
                ids = str.split(',');

            }

            return ids;
        }
        for (var id in assemblies){
            var assembly = assemblies[id];
            var details = assembly.transformDetails;
            var ids;
            s = details.split("(");
            if(s.length == 1){ //just "1", or
                t1 = transforms[s[0]];
                tnew = new THREE.Matrix4().copy(t1);
                assembly.transforms.push(tnew);
            }else if (s.length === 2){
                s1 = s[1].split(")")[0];
                ids = _getIDs(s1);
                for(var i =0; i < ids.length;++i){
                    t1 = transforms[ids[i]];
                    tnew = new THREE.Matrix4().copy(t1);
                    assembly.transforms.push(tnew);
                }
            }else if(s.length ===3){ // we have a pre and a post

            }

        }


    };

    // Create an object storing connectivity between residues that is 
    // not implied by the primary structure. 
    function _createResidueConnection(atomName1, resName1, chainID1, resSeqNum1, atomName2, resName2, chainID2, resSeqNum2, dist) {
        return {
            atomName1: atomName1,  
            resName1: resName1, 
            chainID1: chainID1,
            resSeqNum1: resSeqNum1,
            atomName2: atomName2,
            resName2: resName2, 
            chainID2: chainID2,
            resSeqNum2: resSeqNum2,
            distance: dist 
        };
    };

    function _createBBox(){
        return new THREE.Box3();
    };

    function setMin(obj,x,y,z){
        if(x < obj.minX){
            obj.minX = x;
        }
        if(y < obj.minY){
            obj.minY = y;
        }
        if(z < obj.minZ){
            obj.minZ = z;
        }
    };

    function setMax(obj,x,y,z){
        if(x > obj.maxX){
            obj.maxX = x;
        }
        if(y > obj.maxY){
            obj.maxY = y;
        }
        if(z > obj.maxZ){
            obj.maxZ = z;
        }
    };

    function setEntitiesMinMax(entities,chains){
        var entity,chainID,chain;
        for(var z in entities) {
            entity = entities[z];
            for (var i = 0; i < entity.chainIDs.length; ++i) {
                chainID = entity.chainIDs[i];
                chain = chains[chainID];
                setMin(entity,chain.minX,chain.minY, chain.minZ);
                setMax(entity,chain.maxX,chain.maxY, chain.maxZ);
                if(!entity.isForAssembly && (chain.type === 'l' || chain.type === 'w')){
                    entity.isHetOrLigand = true;
                }
            }
            entity.bbox = new THREE.Box3();

            entity.minX -= 1.5;
            entity.minY -= 1.5;
            entity.minZ -= 1.5;
            entity.maxX += 1.5;
            entity.maxY += 1.5;
            entity.maxZ += 1.5;
            entity.bbox.min.x = entity.minX;
            entity.bbox.min.y = entity.minY;
            entity.bbox.min.z = entity.minZ;
            entity.bbox.max.x = entity.maxX;
            entity.bbox.max.y = entity.maxY;
            entity.bbox.max.z = entity.maxZ;


        }
    };

    function _setResidueType(residue,atom){

        if(residue.name == "C"  || residue.name == "DC" || residue.name == "DA" || residue.name == "A" ||
            residue.name == "G" || residue.name == "DG" || residue.name == "DT" || residue.name == "T" ||
            residue.name == "U" || residue.name == "DU" || residue.name.substr(0,1) == "U") {
            residue.type = 'n';
        }else if(residue.name =="HOH" || residue.name =="DOD"
            || residue.name == "ADE" || residue.name == "CYT"|| residue.name ==  "GUA"
            || residue.name == "INO" || residue.name == "THY" || residue.name == "URA"
            || residue.name == "WAT" || residue.name == "TIP" || residue.name  == "H2O"
            || residue.name == "MOH") {
            residue.type = 'w';
        }else{
            if(!atom.isHet){
                residue.type = 'a';
            }else{
                residue.type = 'l';
            }
        }
    };

    var bondTable = {
        H :0.37,                                                                                                                                HE:0.32,
        LI:1.34,BE:0.90,                                                                                B :0.82,C :0.77,N :0.75,O :0.73,F :0.71,NE:0.69,
        NA:1.54,MG:1.30,                                                                                AL:1.18,SI:1.11,P :1.06,S :1.02,CL:0.99,AR:0.97,
        K :1.96,CA:1.74,SC:1.44,TI:1.56,V :1.25,/* Cr */MN:1.39,FE:1.25,CO:1.26,NI:1.21,CU:1.38,ZN:1.31,GA:1.26,GE:1.22,/* As */SE:1.16,BR:1.14,KR:1.10,
        RB:2.11,SR:1.92,Y :1.62,ZR:1.48,NB:1.37,MO:1.45,TC:1.56,RU:1.26,RH:1.35,PD:1.31,AG:1.53,CD:1.48,IN:1.44,SN:1.41,SB:1.38,TE:1.35,I :1.33,XE:1.30,
        CS:2.25,BA:1.98,LU:1.60,HF:1.50,TA:1.38,W :1.46,RE:1.59,OS:1.44,IR:1.37,PT:1.28,AU:1.44,HG:1.49,TL:1.48,PB:1.47,BI:1.46,/* Po *//* At */RN:1.45

        // None of the boottom row or any of the Lanthanides have bond lengths
    }
    var bondLength = function(elem) {
        return bondTable[elem] || 1.6;
    }
// return true if atom1 and atom2 are probably bonded to each other
// based on distance alone
    var areConnected = function(atom1, atom2) {
        var maxsq = bondLength(atom1.elementUpper) + bondLength(atom2.elementUpper);
        maxsq += 0.25;// fudge factor, especially important for md frames, also see 1i3d
        maxsq *= maxsq;

        var xdiff = atom1.x - atom2.x;
        xdiff *= xdiff;
        if (xdiff > maxsq)
            return false;
        var ydiff = atom1.y - atom2.y;
        ydiff *= ydiff;
        if (ydiff > maxsq)
            return false;
        var zdiff = atom1.z - atom2.z;
        zdiff *= zdiff;
        if (zdiff > maxsq)
            return false;

        var distSquared = xdiff + ydiff + zdiff;

        if (isNaN(distSquared))
            return false;
        else if (distSquared < 0.5)
            return false; // maybe duplicate position.
        else if (distSquared > maxsq)
            return false;
        else if(atom1.altLoc != atom2.altLoc && atom1.altLoc != ' ' && atom2.altLoc != ' ')
            return false; // don't connect across alternate locations
        else
            return true;
    };

    // Find the atom from a list of atoms matching the atom name.
    var getResidueAtom = function(atomName, atoms) {
        if (atoms === undefined) {
            return null; 
        } 
        var atom = null; 
        for (var i = 0, numAtoms = atoms.length; i < numAtoms; i++) {
            if (atoms[i].detailType === atomName) {
                atom = atoms[i];
                break;
            }
        }
        return atom; 
    };

    // Assign secondary structure to atoms.
    //
    // Secondary structure is assigned to the atoms for a residue. The start and end residue
    // IDs for each secondary structure object are used to iterate over each residue and
    // set the secondary structure type for all their atoms (references to the all the atoms 
    // for the macromolecular structure data).
    //
    // Parameters:
    //     secondaryStructures - The list of secondary structure objects.
    //     moleculeResidues - The list of residues for the macromolecular structure data.
    //
    var assignSecondaryStructure = function(secondaryStructures, moleculeResidues) {
        var structure, type, initResName, initChainID, initSeqNum, endResName, endChainID,
            endSeqNum, startResNum, endResNum, residues, atoms;

        for (var i = 0, numStructures = secondaryStructures.length; i < numStructures; i++) {
            structure = secondaryStructures[i];
            type = structure.type,
            initResName = structure.initResName; 
            initChainID = structure.initChainID; 
            initSeqNum = structure.initSeqNum; 
            endResName = structure.endResName; 
            endChainID = structure.endChainID; 
            endSeqNum = structure.endSeqNum;
            startResNum = parseInt(initSeqNum);
            endResNum = parseInt(endSeqNum);
            residues = moleculeResidues[initChainID];
            for (var resNum = startResNum; resNum <= endResNum; resNum++) {
                if (resNum in residues) {
                    atoms = residues[resNum].atoms;
                    for (var j = 0, n = atoms.length; j < n; j++) {
                        atoms[j].ssType = type; 
                    }
                }
            }
        }
    }

    // Create covalent bonds between atoms.
    //
    // Covelent bonds between atoms are created in two ways. The first method creates bonds between 
    // atoms implied by the primary structure of the molecule: a bond is created between two atoms
    // whose distance is within their covalent bond length. The second method creates bonds that have
    // been explicitly defined between atoms of different residues.
    //
    // Parameters:
    //     entities - where we create the bonds...
    //     atoms - The list of all atoms defined from the macromolecular structure data. 
    //     residues - The list of residues defined from the macromolecular structure data.
    //     residueConnectivity - The list of ResidueConnection objects for explicitly defined bonds. 
    //
    var assignBonds = function(atoms, residues, residueConnectivity) {
        var dir = new THREE.Vector3();

        var createBondObjs = function( atoms,index1,index2){
            var atom1, atom2;

            atom1 = atoms[index1];
            atom2 = atoms[index2];
            dir.x = atom2.x - atom1.x;
            dir.y = atom2.y - atom1.y;
            dir.z = atom2.z - atom1.z;
            var length = dir.length();
            var halfLength = length * 0.5;
            var halfX = atom1.x + halfLength * dir.x;
            var halfY = atom1.y + halfLength * dir.y;
            var halfZ = atom1.z + halfLength * dir.z;
            var bonds = atom1.bonds;
            bonds.positions.push(halfX);
            bonds.positions.push(halfY);
            bonds.positions.push(halfZ);
            bonds  = atom2.bonds;
            bonds.positions.push(halfX);
            bonds.positions.push(halfY);
            bonds.positions.push(halfZ);
        };

        for (var i = 0, n = atoms.length; i < n; i++) {
            // Don't reindex if atoms are already indexed
            if (!atoms[i].index)
                atoms[i].index = i;
        }

        var grid = {};
        var MAX_BOND_LENGTH = 4.95; // (largest bond length, Cs) 2.25 * 2 * 1.1 (fudge factor)

        for (var index = 0; index < atoms.length; index++) {
            var atom = atoms[index];
            var x = Math.floor(atom.x / MAX_BOND_LENGTH);
            var y = Math.floor(atom.y / MAX_BOND_LENGTH);
            var z = Math.floor(atom.z / MAX_BOND_LENGTH);
            if (!grid[x]) {
                grid[x] = {};
            }
            if (!grid[x][y]) {
                grid[x][y] = {};
            }
            if (!grid[x][y][z]) {
                grid[x][y][z] = [];
            }

            grid[x][y][z].push(atom);
        }

        var findConnections = function(points, otherPoints) {
            for (var i = 0; i < points.length; i++) {
                var atom1 = points[i];
                for (var j = 0; j < otherPoints.length; j++) {
                    var atom2 = otherPoints[j];

                    if (areConnected(atom1, atom2)) {
                        if (atom1.bondsIndex.indexOf(atom2.index) == -1) {
                            atom1.bondsIndex.push(atom2.index);
                            //atom1.bondOrder.push(1);
                            atom2.bondsIndex.push(atom1.index);
                            //atom2.bondOrder.push(1);
                            createBondObjs(atoms,atom1.index,atom2.index);
                        }
                    }
                }
            }
        }


        /*const*/ var OFFSETS = [
            {x: 0, y: 0, z: 1},
            {x: 0, y: 1, z:-1},
            {x: 0, y: 1, z: 0},
            {x: 0, y: 1, z: 1},
            {x: 1, y:-1, z:-1},
            {x: 1, y:-1, z: 0},
            {x: 1, y:-1, z: 1},
            {x: 1, y: 0, z:-1},
            {x: 1, y: 0, z: 0},
            {x: 1, y: 0, z: 1},
            {x: 1, y: 1, z:-1},
            {x: 1, y: 1, z: 0},
            {x: 1, y: 1, z: 1}
        ];
        for (var x in grid) {
            x = parseInt(x);
            for (var y in grid[x]) {
                y = parseInt(y);
                for (var z in grid[x][y]) {
                    z = parseInt(z);
                    var points = grid[x][y][z];

                    for (var i = 0; i < points.length; i++) {
                        var atom1 = points[i];
                        for (var j = i + 1; j < points.length; j++) {
                            var atom2 = points[j];
                            if (areConnected(atom1, atom2)) {
                                if (atom1.bondsIndex.indexOf(atom2.index) == -1) {
                                    atom1.bondsIndex.push(atom2.index);
                                    //atom1.bondOrder.push(1);
                                    atom2.bondsIndex.push(atom1.index);
                                    //atom2.bondOrder.push(1);
                                    createBondObjs(atoms,atom1.index,atom2.index);
                                }
                            }
                        }
                    }

                    for (var o = 0; o < OFFSETS.length; o++) {
                        var offset = OFFSETS[o];
                        if (!grid[x+offset.x]
                            || !grid[x+offset.x][y+offset.y]
                            || !grid[x+offset.x][y+offset.y][z+offset.z]) continue;

                        var otherPoints = grid[x + offset.x][y + offset.y][z + offset.z];
                        findConnections(points, otherPoints);
                    }
                }
            }
        }

        // Add explicitly defined covalent bonds between atoms of different residues.
        for (var i = 0, n = residueConnectivity.length; i < n; i++) {
            var bond = residueConnectivity[i];
            var atomName1 = bond.atomName1;
            var chainID1 = bond.chainID1;
            var resSeqNum1 = bond.resSeqNum1;
            var atom1 = getResidueAtom(atomName1, residues[chainID1][resSeqNum1].atoms);
            var atomName2 = bond.atomName2;
            var chainID2 = bond.chainID2;
            var resSeqNum2 = bond.resSeqNum2;
            var atom2 = getResidueAtom(atomName2, residues[chainID2][resSeqNum2].atoms);
            if ((atom1 !== null) && (atom2 !== null)) {
                createBondObjs(atoms, atom1.index, atom2.index);
                //a1s = " atom1 " + atom1.id + " " + atom1.detailType + " " + atom1.resNumber;
                //a2s = " atom2 " + atom2.id + " " + atom2.detailType + " " + atom2.resNumber;
                //console.log(">>> create bond between " + a1s + "   " + a2s); 
            }
        }
    };


    /** Just read one model

     */
    readCIFFile = function readFile(str, options) {
        var atoms = [];
        var bonds = {};
        var chains = {};
        var entity,entityID;
        var entities = {};
        var residues = {};
        var residueConnectivity = [];
        var secondaryStructures = [];
        var assemblies = {};
        var positions;
        var headerObj;
        var noAssembly = options ? !options.doAssembly : false; // don't assemble by default
        var copyMatrix = options ? !options.duplicateAssemblyAtoms: false;
        var modelData = atoms.modelData = [];
        var  startChain;
        var  resStart, resEnd;
        var z;

        // Used to handle quotes correctly
        function splitRespectingQuotes(string, separator) {
            var sections = [];
            var sectionStart = 0;
            var sectionEnd = 0;
            while (sectionEnd < string.length) {
                while (string.substr(sectionEnd, separator.length) !== separator
                && sectionEnd < string.length) {
                    // currently does not support escaping quotes
                    if (string[sectionEnd] === "'") {
                        sectionEnd++;
                        while (sectionEnd < string.length
                        && string[sectionEnd] !== "'") {
                            sectionEnd++;
                        }
                    } else if (string[sectionEnd] === '"') {
                        sectionEnd++;
                        while (sectionEnd < string.length
                        && string[sectionEnd] !== '"') {
                            sectionEnd++;
                        }
                    }
                    sectionEnd++;

                }
                sections.push(string.substr(sectionStart, sectionEnd
                - sectionStart));
                sectionStart = sectionEnd = sectionEnd + separator.length;
            }
            return sections;
        }


        var lines = str.split(/\r?\n|\r/);
        // Filter text to remove comments, trailing spaces, and empty lines
        var linesFiltered = [];
        var trimDisabled = false;
        for (var lineNum = 0; lineNum < lines.length; lineNum++) {
            // first remove comments
            // incorrect if #'s are allowed in strings
            // comments might only be allowed at beginning of line, not sure
            var line = lines[lineNum].split('#')[0];

            // inside data blocks, the string must be left verbatim
            // datablocks are started with a ';' at the beginning of a line
            // and ended with a ';' on its own line.
            if (trimDisabled) {
                if (line[0] === ';') {
                    trimDisabled = false;
                }
            } else {
                if (line[0] === ';') {
                    trimDisabled = true;
                }
            }

            if (trimDisabled || line !== "") {
                if (!trimDisabled) {
                    line = line.trim();
                    if (line[0] === '_') {
                        // Replace dot separating category from data item with underscore. Dots aren't guarenteed, to makes
                        // files consistent.
                        var dot = line.split(/\s/)[0].indexOf('.');
                        if (dot > -1) {
                            line[dot] = '_';
                            line = line.substr(0,dot) + '_' + line.substr(dot + 1)
                        }
                    }
                }
                linesFiltered.push(line);
            }
        }

        var lineNum = 0;
        while (lineNum < linesFiltered.length) {
            while (! linesFiltered[lineNum].startsWith("data_") ||
            linesFiltered[lineNum] === "data_global") {
                lineNum++;
            }
            lineNum++;

            // Process the lines and puts all of the data into an object.
            var mmCIF = {};
            while (lineNum < linesFiltered.length &&
            ! linesFiltered[lineNum].startsWith("data_")) {
                if (linesFiltered[lineNum][0] === undefined) {
                    lineNum++;
                } else if (linesFiltered[lineNum][0] === '_') {
                    var dataItemName = (linesFiltered[lineNum].split(/\s/)[0]).toLowerCase();
                    var dataItem = (mmCIF[dataItemName] = mmCIF[dataItemName] || []);

                    // if nothing left on the line go to the next one
                    var restOfLine = linesFiltered[lineNum]
                        .substr(linesFiltered[lineNum].indexOf(dataItemName)
                        + dataItemName.length);
                    if (restOfLine === "") {
                        lineNum++;
                        if (linesFiltered[lineNum][0] === ';') {
                            var dataBlock = linesFiltered[lineNum].substr(1);
                            lineNum++;
                            while (linesFiltered[lineNum] !== ';') {
                                dataBlock = dataBlock + '\n'
                                + linesFiltered[lineNum];
                                lineNum++;
                            }
                            dataItem.push(dataBlock);
                        } else {
                            dataItem.push(linesFiltered[lineNum]);
                        }
                    } else {
                        dataItem.push(restOfLine.trim());
                    }
                    lineNum++;
                } else if (linesFiltered[lineNum].substr(0, 5) === "loop_") {
                    lineNum++;
                    var dataItems = [];
                    while (linesFiltered[lineNum] === ""
                    || linesFiltered[lineNum][0] === '_') {
                        if (linesFiltered[lineNum] !== "") {
                            var dataItemName = (linesFiltered[lineNum].split(/\s/)[0]).toLowerCase();
                            var dataItem = (mmCIF[dataItemName] = mmCIF[dataItemName] || []);
                            dataItems.push(dataItem);
                        }
                        lineNum++;
                    }

                    var currentDataItem = 0;
                    while (lineNum < linesFiltered.length
                    && linesFiltered[lineNum][0] !== '_'
                    && !linesFiltered[lineNum].startsWith("loop_")
                    && !linesFiltered[lineNum].startsWith("data_")) {
                        var line = splitRespectingQuotes(linesFiltered[lineNum], " ");
                        for (var field = 0; field < line.length; field++) {
                            if (line[field] !== "") {
                                dataItems[currentDataItem].push(line[field]);
                                currentDataItem = (currentDataItem + 1) % dataItems.length;
                            }
                        }
                        lineNum++;
                    }
                } else {
                    lineNum++;
                }
            }
            //okay here the _mmCIF object holds the data
            //first check to make sure we have atom data, if not just exit...

            if(!mmCIF._atom_site_id || ! mmCIF._atom_site_type_symbol || !mmCIF._atom_site_cartn_x
                || !mmCIF._atom_site_cartn_y || !mmCIF._atom_site_cartn_z){
                return false;
            }

            var atomCount = mmCIF._atom_site_id !== undefined ? mmCIF._atom_site_id.length
                : mmCIF._atom_site_label.length;

            positions = new Float32Array(3 * atomCount);
            headerObj = _createHeaderObj(mmCIF);
            headerObj.title = mmCIF._struct_title[0];
            headerObj.id = mmCIF._entry_id[0];
            headerObj.numAtoms = atomCount;
            if(mmCIF._audit_author_name){
                if(mmCIF._audit_author_name.length){
                    headerObj.author = '';
                    for( z= 0; z < mmCIF._audit_author_name.length; ++z ) {
                        if(z!==0){
                            headerObj.author += ' ';
                        }
                        headerObj.author += mmCIF._audit_author_name[z];
                    }
                }else{
                    headerObj.author = mmCIF._audit_author_name;
                }
            }
            //headerObj.bFactorMin: Number.POSITIVE_INFINITY,
            //bFactorMax: Number.NEGATIVE_INFINITY,
            //numAtoms: 0 , //MZ Just use size of atomMetaData Array?
            // offsetX: 0.0, //offsets aren't used.. MZ?
            // offsetY: 0.0,
            // offsetZ: 0.0

            // Process helix secondary structure data.
            if (mmCIF._struct_conf_beg_label_asym_id) {
                for (z = 0; z  < mmCIF._struct_conf_beg_label_asym_id.length; ++z){
                    // There may also be TURN_P types here which we don't process.
                    if (mmCIF._struct_conf_conf_type_id[z] != "HELX_P") {
                        continue;
                    }
                    startResName = mmCIF._struct_conf_beg_label_comp_id[z];
                    startChain = mmCIF._struct_conf_beg_label_asym_id[z];
                    startSeqNum = mmCIF._struct_conf_beg_label_seq_id[z];
                    endResName = mmCIF._struct_conf_end_label_comp_id[z];
                    endChain = mmCIF._struct_conf_end_label_asym_id[z];
                    endSeqNum = mmCIF._struct_conf_end_label_seq_id[z];
                    helix = _createSecondaryStructureObj('h', startResName, startChain, startSeqNum,
                        endResName, endChain, endSeqNum);
                    secondaryStructures.push(helix);
                }
            }

            // Process sheet secondary structure data.
            if(mmCIF._struct_sheet_range_beg_label_asym_id){
                for (z = 0;  z < mmCIF._struct_sheet_range_beg_label_asym_id.length; ++z){
                    startResName = mmCIF._struct_sheet_range_beg_label_comp_id[z];
                    startChain = mmCIF._struct_sheet_range_beg_label_asym_id[z];
                    startSeqNum = mmCIF._struct_sheet_range_beg_label_seq_id[z];
                    endResName = mmCIF._struct_sheet_range_end_label_comp_id[z];
                    endChain = mmCIF._struct_sheet_range_end_label_asym_id[z];
                    endSeqNum = mmCIF._struct_sheet_range_end_label_seq_id[z];                    
                    sheet = _createSecondaryStructureObj('s', startResName, startChain, startSeqNum, 
                        endResName, endChain, endSeqNum);  
                    secondaryStructures.push(sheet);
                }
            }

            /* _createEntityObj(){
             return {
             assemblyIDs: [],
             chainIDs: [],
             description: "Protein Dude",*/
            if(mmCIF._entity_id){
                for (z = 0; z < mmCIF._entity_id.length; ++z){
                    entity = _createEntityObj();
                    entity.id = mmCIF._entity_id[z];
                    entity.description = mmCIF._entity_pdbx_description[z];
                    entity.type = mmCIF._entity_type[z];
                    entities[entity.id] = entity;


                }
            }else { //create default
                entity = _createEntityObj();
                entity.description = "created as default";
                entity.type = "default";
                entities["1"] = entity;
            }

            if(mmCIF._struct_asym_id) {
                for (z = 0; z < mmCIF._struct_asym_id.length; ++z){
                    entity = entities[mmCIF._struct_asym_entity_id[z]];
                    entity.chainIDs.push(mmCIF._struct_asym_id[z]);
                }
            }

            modelData.push({symmetries:[]});

            // Pulls atom information out of the data

            var currentIndex = 0;

            function sqr(n) {
                return n*n;
            }
            var conversionMatrix;
            if (mmCIF._cell_length_a !== undefined) {
                var a = parseFloat(mmCIF._cell_length_a);
                var b = parseFloat(mmCIF._cell_length_b);
                var c = parseFloat(mmCIF._cell_length_c);
                var alpha_deg = parseFloat(mmCIF._cell_angle_alpha) || 90;
                var beta_deg = parseFloat(mmCIF._cell_angle_beta) || 90;
                var gamma_deg = parseFloat(mmCIF._cell_angle_gamma) || 90;
                var alpha = alpha_deg * Math.PI / 180;
                var beta = beta_deg * Math.PI / 180;
                var gamma = gamma_deg * Math.PI / 180;
                var cos_alpha = Math.cos(alpha);
                var cos_beta = Math.cos(beta);
                var cos_gamma = Math.cos(gamma);
                var sin_gamma = Math.sin(gamma);
                conversionMatrix = [
                    [a, b*cos_gamma, c*cos_beta],
                    [0, b*sin_gamma, c*(cos_alpha-cos_beta*cos_gamma)/sin_gamma],
                    [0, 0, c*Math.sqrt(1-sqr(cos_alpha)-sqr(cos_beta)-sqr(cos_gamma)+2*cos_alpha*cos_beta*cos_gamma)/sin_gamma]
                ];
                modelData[modelData.length-1].cryst = {'a' : a, 'b' : b, 'c' : c, 'alpha' : alpha_deg, 'beta' : beta_deg, 'gamma' : gamma_deg};
            }
            function fractionalToCartesian(a, b, c) {
                var x = conversionMatrix[0][0]*a + conversionMatrix[0][1]*b + conversionMatrix[0][2]*c;
                var y = conversionMatrix[1][0]*a + conversionMatrix[1][1]*b + conversionMatrix[1][2]*c;
                var z = conversionMatrix[2][0]*a + conversionMatrix[2][1]*b + conversionMatrix[2][2]*c;
                return {x:x, y:y, z:z};
            }

            var  lastChain = "$";
            var  lastSeqNo = "0";
            var  currentSeqNo;
            var  residueName;
            var  lastResidueName = "-----";
            var  currentChain;
            var  altLoc;
            var  chain;
            var  residue;
            var  newChain = false;
            var  posCount = 0;
            for (var i = 0; i < atomCount; i++) {
                if (mmCIF._atom_site_pdbx_pdb_model_num  && mmCIF._atom_site_pdbx_pdb_model_num[i] === '1' &&
                    mmCIF._atom_site_group_pdb  && mmCIF._atom_site_group_pdb[i] !== "TER") {
                    var atom = _createAtomMetadataObj();
                    if (mmCIF._atom_site_cartn_x !== undefined) {
                        atom.x = parseFloat(mmCIF._atom_site_cartn_x[i]);
                        atom.y = parseFloat(mmCIF._atom_site_cartn_y[i]);
                        atom.z = parseFloat(mmCIF._atom_site_cartn_z[i]);
                    }
                    else {
                        var coords = fractionalToCartesian(
                            parseFloat(mmCIF._atom_site_fract_x[i]),
                            parseFloat(mmCIF._atom_site_fract_y[i]),
                            parseFloat(mmCIF._atom_site_fract_z[i]));
                        atom.x = coords.x;
                        atom.y = coords.y;
                        atom.z = coords.z;
                    }
                    //atom.x = 0;
                    //atom.y = i;
                    //atom.z = i;
                    positions[posCount++] = atom.x;
                    positions[posCount++] = atom.y;
                    positions[posCount++] = atom.z;

                    currentChain = mmCIF._atom_site_label_asym_id ? mmCIF._atom_site_label_asym_id[i] : 'A';
                    if(currentChain != lastChain){
                        lastChain = currentChain;
                        chain = _createChainObj();
                        chain.id = currentChain;
                        chains[chain.id] = chain;
                        newChain =true;
                    }else{
                        newChain  = false;
                    }
                    atom.chainID = currentChain;
                    currentSeqNo = mmCIF._atom_site_label_seq_id ? (mmCIF._atom_site_label_seq_id[i]) : "1";
                    atom.resNumber = currentSeqNo;
                    residueName = mmCIF._atom_site_label_comp_id ? mmCIF._atom_site_label_comp_id[i].trim() : "Z";
                    atom.residue = residueName;
                    atom.isHet = !mmCIF._atom_site_group_pdb || mmCIF._atom_site_group_pdb[i] === "HETA" || mmCIF._atom_site_group_pdb[i] === "HETATM";

                    if(currentSeqNo != lastSeqNo || (residueName != lastResidueName) || newChain){
                        lastSeqNo = currentSeqNo;
                        lastResidueName = residueName;
                        residue = _createResidueObj();
                        residue.id = currentSeqNo;
                        residue.name = residueName;
                        _setResidueType(residue,atom);
                        chain.residues[residue.id] = residue;
                        chain.type = residue.type;
                    }
                    residue.atoms.push(atom);
                    setMin(residue, atom.x,atom.y,atom.z);
                    setMax(residue, atom.x,atom.y,atom.z);
                    setMin(chain, atom.x,atom.y,atom.z);
                    setMax(chain, atom.x,atom.y,atom.z);

                    atom.detailType = mmCIF._atom_site_label_atom_id ? mmCIF._atom_site_label_atom_id[i].replace(/"/gm, '') : undefined; //"primed" names are in quotes
                    var elem = mmCIF._atom_site_type_symbol[i];
                    atom.element = elem[0].toUpperCase() + elem.substr(1).toLowerCase();
                    atom.elementUpper = atom.element.toUpperCase(); //cache this for use to get radius later.
                    atom.id = i;


                    atom.bFactor = mmCIF._atom_site_b_iso_or_equiv ? parseFloat(mmCIF._atom_site_b_iso_or_equiv[i]) : undefined;
                    if (atom.bFactor && !atom.isHet) {
                        if (atom.bFactor < headerObj.bFactorMin) {
                            headerObj.bFactorMin = atom.bFactor;
                        }
                        if (atom.bFactor > headerObj.bFactorMax) {
                            headerObj.bFactorMax = atom.bFactor;
                        }
                    }
                    atoms.push(atom);
                }
            }
            if (mmCIF._pdbx_struct_assembly_gen_assembly_id !== undefined){
                for(var z =0; z < mmCIF._pdbx_struct_assembly_id.length; ++z){
                    var assembly = _createAssemblyObj();
                    assembly.assemblyID = mmCIF._pdbx_struct_assembly_id[z];
                        //chains: [],  //ID's like "A", AA, B, C
                    var str  = mmCIF._pdbx_struct_assembly_gen_asym_id_list[z];
                    assembly.chains = str.split(',');
                    assembly.details  = mmCIF._pdbx_struct_assembly_details[z];
                    assembly.transformDetails = mmCIF._pdbx_struct_assembly_gen_oper_expression[z];

                        //entityID: "Entity 1",
                        //transforms: []
                    var ent = _getEntityForTheseAssemblyChains(entities, assembly.chains, assembly.assemblyID);
                    assembly.entityID = ent.id;
                    assemblies[assembly.assemblyID] = assembly;
                }
            }
            var transforms = {};
            if (mmCIF._pdbx_struct_oper_list_id) {
                for (var i = 0; i < mmCIF._pdbx_struct_oper_list_id.length; i++) {
                    var matrix11 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[1][1]'][i]);
                    var matrix12 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[1][2]'][i]);
                    var matrix13 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[1][3]'][i]);
                    var vector1 = parseFloat(mmCIF['_pdbx_struct_oper_list_vector[1]'][i]);
                    var matrix21 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[2][1]'][i]);
                    var matrix22 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[2][2]'][i]);
                    var matrix23 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[2][3]'][i]);
                    var vector2 = parseFloat(mmCIF['_pdbx_struct_oper_list_vector[2]'][i]);
                    var matrix31 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[3][1]'][i]);
                    var matrix32 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[3][2]'][i]);
                    var matrix33 = parseFloat(mmCIF['_pdbx_struct_oper_list_matrix[3][3]'][i]);
                    var vector3 = parseFloat(mmCIF['_pdbx_struct_oper_list_vector[3]'][i]);

                    var matrix = new THREE.Matrix4().set(matrix11, matrix12, matrix13, vector1,
                        matrix21, matrix22, matrix23, vector2,
                        matrix31, matrix32, matrix33, vector3,
                    0,0,0,1);
                    var id = mmCIF._pdbx_struct_oper_list_id[i];
                    transforms[id] = matrix;
                }
            }
            _processTransformsForAssemblies(assemblies,transforms);
            function parseTerm(term){
                var negative = term.match('-');
                term = term.replace(/[-xyz]/g, "");
                var fractionParts = term.split('/');

                var numerator, denominator;
                if (fractionParts[1] === undefined) {
                    denominator = 1;
                }
                else {
                    denominator = parseInt(fractionParts[1]);
                }
                if (fractionParts[0] === "") {
                    numerator = 1;
                }
                else {
                    numerator = parseInt(fractionParts[0]);
                }
                return numerator / denominator * (negative ? -1 : 1);
            }
            if (mmCIF._symmetry_equiv_pos_as_xyz !== undefined) {
                for (var sym = 0; sym < mmCIF._symmetry_equiv_pos_as_xyz.length; sym++) {
                    var transform = mmCIF._symmetry_equiv_pos_as_xyz[sym].replace(/["' ]/g,"");
                    var componentStrings = transform.split(',').map(
                        function(val){
                            return val.replace(/-/g,"+-");
                        });
                    var matrix = new THREE.Matrix4().set(0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,1);
                    for (var coord = 0; coord < 3; coord++) {
                        var terms = componentStrings[coord].split('+');
                        var constant = 0, xTerm = 0, yTerm = 0, zTerm = 0;
                        for (var t = 0; t < terms.length; t++) {
                            var term = terms[t];
                            if (term === "")
                                continue;
                            var coefficient = parseTerm(term);
                            if (term.match('x')) {
                                matrix.elements[coord + 0] = coefficient;
                            }
                            else if (term.match('y')) {
                                matrix.elements[coord + 4] = coefficient;
                            }
                            else if (term.match('z')) {
                                matrix.elements[coord + 8] = coefficient;
                            }
                            else {
                                matrix.elements[coord + 12] = coefficient;
                            }
                        }
                    }
                    var conversionMatrix4 = new THREE.Matrix4().set(
                        conversionMatrix[0][0], conversionMatrix[0][1], conversionMatrix[0][2], 0,
                        conversionMatrix[1][0], conversionMatrix[1][1], conversionMatrix[1][2], 0,
                        conversionMatrix[2][0], conversionMatrix[2][1], conversionMatrix[2][2], 0);
                    var conversionInverse = (new THREE.Matrix4()).getInverse(conversionMatrix4, true);
                    matrix = (new THREE.Matrix4()).multiplyMatrices(matrix, conversionInverse);
                    matrix = (new THREE.Matrix4()).multiplyMatrices(conversionMatrix4, matrix);
                    modelData[modelData.length-1].symmetries.push(matrix);
                }
            }
        }

        // Process explicit covalent bond definitions.
        if (mmCIF._struct_conn_id !== undefined) {
            var bondType, atomName1, resName1, chainID1, resSeqNum1, atomName2, resName2, chainID2, resSeqNum2, dist;
            for (var i = 0; i < mmCIF._struct_conn_id.length; i++) {
                bondType = mmCIF._struct_conn_conn_type_id[i];
                if ((bondType === "disulf") || (bondType === "covale")) {
                    chainID1 = mmCIF._struct_conn_ptnr1_label_asym_id[i];
                    resName1 = mmCIF._struct_conn_ptnr1_label_comp_id[i];
                    resSeqNum1 = mmCIF._struct_conn_ptnr1_label_seq_id[i];
                    atomName1 = mmCIF._struct_conn_ptnr1_label_atom_id[i];
                    chainID2 = mmCIF._struct_conn_ptnr2_label_asym_id[i];
                    resName2 = mmCIF._struct_conn_ptnr2_label_comp_id[i];
                    resSeqNum2 = mmCIF._struct_conn_ptnr2_label_seq_id[i];
                    atomName2 = mmCIF._struct_conn_ptnr2_label_atom_id[i];
                    dist = mmCIF._struct_conn_pdbx_dist_value[i];
                    if (dist === undefined) { 
                        dist = 1e6;
                    }
                    var resConn = _createResidueConnection(atomName1, resName1, chainID1, resSeqNum1,
                        atomName2, resName2, chainID2, resSeqNum2, dist);
                    residueConnectivity.push(resConn);
                }
            }
        }


        // Set up residues based upon chains.
        for(var chainID in chains){
            chain = chains[chainID];
            residues[chainID] = chain.residues;
        }
        //we use this for determining some factors such as surface Factor for calculating views resolutions.
        var maxNumAtoms = _calcMaxNumAtoms(atoms, assemblies);
        // Create covalent bonds between atoms.
        assignBonds(atoms, residues, residueConnectivity);

        // Assign secondary structure to atoms.
        assignSecondaryStructure(secondaryStructures, residues);

        setEntitiesMinMax(entities,chains);
        return {atomMetadata: atoms, bonds: bonds, header: headerObj, chains: chains,
            entities:entities, residues: residues, positions: positions,assemblies:assemblies,
        maxNumAtoms : maxNumAtoms};
    }

    // Parse a PDB format file.
    //
    // A PDB format file consists of a number of 80-column lines called records. The first six columns of every line 
    // contains a left-justified record name separated by a blank. The record name identifies the type of data stored 
    // in the record and its format. Record data is divided into fields with a fixed starting position and width.   
    //
    // A molecule object is created to store data (e.g. atoms) as records are parsed. The chains and residues of the 
    // structure are created from the list of atoms after all of the records have been parsed. 
    //
    readPDBFile = function readFile(str, options) {
        // Create a molecule object to store the atoms, biomolecules, compounds, etc.
        var molecule = createMolecule();
        var pdbRecordParsers = null;
        var bonds = {};
        var chains = {};
        var entity,entityID;
        var entities = {};
        var assemblies = {};
        var residues = {};
        var positions;
        var headerObj;
        var noAssembly = options ? !options.doAssembly : false; // don't assemble by default
        var copyMatrix = options ? !options.duplicateAssemblyAtoms: false;
        var modelData = molecule.atoms.modelData = [];
        var startChain;
        var resStart, resEnd;
        var z;
        var lastChain = "$";
        var lastSeqNo = "0";
        var currentSeqNo;
        var residueName;
        var lastResidueName = "-----";
        var currentChain;
        var posCount = 0;

        // Get the table of PDB parsing functions. 
        //
        // The table key is the PDB record name, the value the parsing function.
        //
        function getPdbRecordParsers() {
            return {
                atom : parseAtom,
                compnd : parseCompnd,
                header : parseHeader,
                helix : parseHelix,
                hetatm : parseHetatom,
                link : parseLink,
                model : parseModel,
                remark : parseRemark,
                sheet : parseSheet,
                ssbond : parseSsbond,
                title : parseTitle 
            }
        }

        // Parse an atom record.
        function parseAtom(line, molecule) {
            var serial = line.substr(6, 5).trim();
            var atomName = line.substr(12, 4).replace(/ /g, "");
            var altLoc = line.substr(16, 1).trim();
            var resName = line.substr(17, 3).replace(/ /g, "");
            var chainID = line.substr(21, 1);
            var resSeq = line.substr(22, 4).trim();
            var icode = line.substr(26, 1);
            var x = parseFloat(line.substr(30, 8));
            var y = parseFloat(line.substr(38, 8));
            var z = parseFloat(line.substr(46, 8));
            var bfactor = line.substr(60, 8);
           
            // If the element field is blank then use the atom name.
            var element = line.substr(76, 2).replace(/ /g, "");
            if (element === '') {
                element = line.substr(12, 2).replace(/ /g, "");
            }

            // Create an atom object.
            var atom = _createAtomMetadataObj();
            // TODO [davep 1/4/17] It seems that atom.id needs to start at 1. 
            // Reading in a structure with atoms IDs not starting at 1 displays 
            // nothing. Do atom IDs matter?
            //atom.id = molecule.atoms.length+1; 
            //atom.id = serial;
            atom.id = molecule.atoms.length; 
            atom.detailType = atomName;
            atom.x = x; 
            atom.y = y; 
            atom.z = z; 
            atom.altLoc = altLoc; 
            atom.chainID = chainID;
            atom.element = element;
            atom.elementUpper = element.toUpperCase();
            atom.resNumber = resSeq;
            atom.residue = resName;

            if (bfactor) {
                atom.bFactor = parseFloat(bfactor);
            }

            if (atom.bFactor) {
                if (atom.bFactor < headerObj.bFactorMin) {
                    headerObj.bFactorMin = atom.bFactor;
                }
                if (atom.bFactor > headerObj.bFactorMax) {
                    headerObj.bFactorMax = atom.bFactor;
                }
            }

            molecule.atoms.push(atom);
            return atom;
        }

        // Parse a het atom record.
        function parseHetatom(line, molecule) {
            atom = parseAtom(line, molecule);
            atom.isHet = true;
        }

        // Parse a compound record describing the macromolecular contents of the structure.
        //
        // A compoundObj is created for each compound and stored in the list of compounds.
        //
        function parseCompnd(line, molecule) {
            var str = line.substr(10, 80).replace(/\;/g,"");
            var tokens = str.split(" ").filter(function(n){return n != ""}); 
            // Create a new compound object.
            if (tokens[0] === "MOL_ID:") {
                var id = tokens[1];
                var compoundObj = createCompound(id);
                molecule.compounds.push(compoundObj);
                molecule.currentCompound = compoundObj;
            // Add a description to the current compound.
            } else if (tokens[0] == "MOLECULE:") {
                molecule.currentCompound.description = tokens.slice(1).join(" "); 
            // Add chain IDs to the current compound.
            } else if (tokens[0] == "CHAIN:") {
                for (var i = 1, n = tokens.length; i < n; i++) {
                    molecule.currentCompound.chains.push(tokens[i].replace(/\,/g,""));
                }
            }
        }

        // Parse a header record.
        function parseHeader(line, molecule) {
            var classification = line.substr(10, 50);
            var date = line.substr(50, 59);
            var idCode = line.substr(62, 66).trim();
            molecule.header.id = idCode;
        }

        // Parse a helix record. 
        //
        // Helix records define the residues involved in helix secondary structure formation.
        // A SecondaryStructure object is created and added to molecule.secondaryStructures[].
        //
        function parseHelix(line, molecule) {
            var id, num, initResName, initChainID, initSeqNum, endResName, endChainID, endSeqNum, hclass, hlength;
            num = line.substr(7, 3);
            id = line.substr(11, 3);
            initResName = line.substr(15, 3);
            initChainID = line.substr(19, 1);
            initSeqNum = line.substr(21, 4).trim();
            endResName = line.substr(27, 3);
            endChainID = line.substr(31, 1);
            endSeqNum = line.substr(33, 4).trim();
            hclass = parseInt(line.substr(38, 2));
            hlength = parseInt(line.substr(71, 5));
            helix = _createSecondaryStructureObj('h', initResName, initChainID, initSeqNum, endResName, endChainID, endSeqNum); 
            molecule.secondaryStructures.push(helix);
        }

        // Parse a model record. This record contains the model serial number when a 
        // single coordinate entry contains multiple structures.
        //
        // Note: We currently don't process multiple models.
        //
        function parseModel(line, molecule) {
            var id = parseInt(line.substr(4, 10));
        }

        // Parse a link record. 
        //
        // This defines covalent bonds between hetatoms of different residues.
        // A ResidueConnection object is created and add to molecule.residueConnectivity[].
        //
        function parseLink(line, molecule) {
            var atomName1, resName1, chainID1, resSeqNum1,
                atomName2, resName2, chainID2, resSeqNum2;
            atomName1 = line.substr(12, 4).trim();
            resName1 = line.substr(17, 3).trim();
            chainID1 = line.substr(21, 1);
            resSeqNum1 = line.substr(22, 4).trim();
            atomName2 = line.substr(42, 4).trim();
            resName2 = line.substr(47, 3).trim();
            chainID2 = line.substr(51, 1);
            resSeqNum2 = line.substr(52, 4).trim();
            var dist = parseFloat(line.substr(73, 5));
            var resConn = _createResidueConnection(atomName1, resName1, chainID1, resSeqNum1,
                atomName2, resName2, chainID2, resSeqNum2, dist);
            molecule.residueConnectivity.push(resConn);
        }

        // Parse a sheet record. 
        //
        // Sheet records define the residues involved in sheet secondary structure formation.
        // A SecondaryStructure object is created and added to molecule.secondaryStructures[].
        // 
        function parseSheet(line, molecule) {
            var id, num, initResName, initChainID, initSeqNum, endResName, endChainID, endSeqNum, sense;
            num = line.substr(7, 3);
            id = line.substr(11, 3);
            initResName = line.substr(17, 3);
            initChainID = line.substr(21, 1);
            initSeqNum = line.substr(22, 4).trim();
            endResName = line.substr(28, 3);
            endChainID = line.substr(32, 1);
            endSeqNum = line.substr(33, 4).trim();
            sense = parseInt(line.substr(38, 2));
            sheet = _createSecondaryStructureObj('s', initResName, initChainID, initSeqNum, endResName, endChainID, endSeqNum); 
            molecule.secondaryStructures.push(sheet);
        }

        // Parse an ssbond record. 
        //
        // This defines a covalent disulfide bond between atoms of different residues.
        // A ResidueConnection object is created and add to molecule.residueConnectivity[].
        //
        function parseSsbond(line, molecule) {
            var atomName = "SG", resName = "CYS", chainID1, resSeqNum1, chainID2, resSeqNum2;
            chainID1 = line.substr(15, 1);
            resSeqNum1 = line.substr(17, 4).trim();
            chainID2 = line.substr(29, 1);
            resSeqNum2 = line.substr(31, 4).trim();
            dist = parseFloat(line.substr(73, 5));
            resConn = _createResidueConnection(atomName, resName, chainID1, resSeqNum1, 
                atomName, resName, chainID2, resSeqNum2, dist);
            molecule.residueConnectivity.push(resConn);
        }

        // Parse a title record.
        function parseTitle(line, molecule) {
            var cont = line.substr(8, 1);
            var title = line.substr(10, 80);
            if (cont === ' ') { 
                molecule.header.title = title;
            } else {
                molecule.header.title += ";" + title;
            }
        }

        // Parse a remark record.
        //
        // REMARK 350: presents all transformations, both crystallographic and non-crystallographic, 
        // needed to generate the biomolecule. These transformations operate on the coordinates in the 
        // entry. A Biomolecule object is created and added to molecule.biomolecules[]. There will be 
        // multiple REMARK 350 records defining the chains and transformations of the biomolecule. 
        // When the "BIOMOLECULE:" field is found a new Biomolecule object is created and set as the 
        // biomolecule being processed by being stored in molecule.currentBiomolecule.
        //
        function parseRemark(line, molecule) {
            var remarkNum;
            var nstr = line.substr(7, 10);
            var str = line.substr(11, 79);

            if (nstr === ' ') { 
                remarkNum = 0;
            } else {
                remarkNum = parseInt(nstr);
            }

            // Parse a biomolecular transformation.
            if (remarkNum === 350) {
                var tokens = str.split(" ");
                tokens = tokens.filter(function(n){return n != ""}); 
                // Create a new Biomolecule object.
                if (tokens.length && tokens[0] === "BIOMOLECULE:") { 
                    var id = parseInt(tokens[1]);
                    var biomol = createBiomolecule(id);
                    molecule.biomolecules.push(biomol)
                    molecule.currentBiomolecule = biomol;
                // Add a row in a transformation matrix. This includes 3 columns for 
                // the rotation and one for the translation.
                } else if (tokens.length && tokens[0].substr(0,5)  === "BIOMT") { 
                    var xformID = parseInt(tokens[1]);
                    var row = parseInt(tokens[0].substr(5,1));
                    var matrix; 
                    if (xformID  in molecule.currentBiomolecule.xforms) { 
                        matrix = molecule.currentBiomolecule.xforms[xformID]; 
                    } else { 
                        matrix = new THREE.Matrix4();
                        molecule.currentBiomolecule.xforms[xformID] = matrix; 
                    }
                    for (var i = 2; i < 6; i++) {
                        matrix.elements[4*(row-1)+i-2] = parseFloat(tokens[i]);
                    }
                // Add the biomolecule chain IDs.
                } else if (tokens.length && tokens[0] === "APPLY") { 
                    for (var i = 5, n = tokens.length; i < n; i++) {
                        molecule.currentBiomolecule.chains.push(tokens[i].replace(",",""));
                    }
                }
            }
        }

        // Create a molecule object. 
        //
        // This stores the atoms, biomolecules, secondary structures and compounds defined 
        // for the structure as they are parsed.
        //
        // Properties:
        //     atoms - The list of all atoms defined from the macromolecular structure data. 
        //     biomolecules - The list Biomolecule objects.
        //     compounds - The list Compound objects.
        //     currentBiomolecule - The current Biomolecule object being processed.
        //     currentCompound - The current Compound object being processed.
        //     header - The HeaderObj.
        //     residueConnectivity - The list of ResidueConnection objects defining explicit covalent bonds.
        //     secondaryStructures - The list of SecondaryStructure objects defining the seconcdary structures
        //         defined from the macromolecular structure data.
        //
        function createMolecule() {
            return { 
                header: null,
                atoms: [],
                biomolecules: [],
                currentBiomolecule: null,
                compounds: [],
                currentCompound: null,
                residueConnectivity: [],
                secondaryStructures: []
            }; 
        } 

        // Create a biomolecule object. 
        //
        // This stores chain and transformation data used to create assemblies.
        //
        // The 'xforms' property will be a list of 4x4 matrices defining the biomolecule 
        // rotation and translation transformations.
        //
        function createBiomolecule(id) {
            return { 
                id : id, 
                chains : [],
                xforms : {}
            }; 
        } 

        // Create a compound object. 
        //
        // This stores the chains and the description for a compound in the structure. 
        //
        function createCompound(id) {
            return {
                id : id,
                description : null,
                chains : [],
            };
        }

        // Create the object to store structure title, bfactor range, et.
        headerObj = _createHeaderObj();

        // Create a molecule object to store the atoms, biomolecules, compounds, etc.
        molecule = createMolecule();
        molecule.header = headerObj; 

        // Get the PDB parsing functions.
        pdbRecordParsers = getPdbRecordParsers();

        // Parse PDB records.
        var lines = str.split(/\r?\n|\r/);
        var i, line, recordName;
        for (i = 0; i < lines.length; i++) {
            line = lines[i].replace(/^\s*/, ''); // remove indent
            recordName = line.substr(0,6).toLowerCase().trim();
            if (recordName in pdbRecordParsers) { 
                pdbRecordParsers[recordName](line, molecule);
            }
        }

        // Create chain and residue objects.
        //console.log(">>> Number of atoms " + molecule.atoms.length); 
        positions = new Float32Array(3 * molecule.atoms.length);
        headerObj.numAtoms = molecule.atoms.length;
        var atom, chain, residue;
        for (var i = 0, n = molecule.atoms.length; i < n; i++) {
            atom = molecule.atoms[i]
            positions[posCount++] = atom.x;
            positions[posCount++] = atom.y;
            positions[posCount++] = atom.z;

            // Create chains. 
            currentChain = atom.chainID; 
            if (currentChain in chains) {
                chain = chains[currentChain];
            } else {
                chain = _createChainObj();
                chain.id = currentChain;
                chains[chain.id] = chain;
            }

            // Add a new residue.
            //
            // The same chain may contain polymer and hetatoms (e.g. water).
            // Check for this when setting the chain type to make sure
            // that its type is a polymer if there are multiple residue types
            // in it.
            currentSeqNo = atom.resNumber;
            residueName = atom.residue;
            if ((currentSeqNo != lastSeqNo) || (residueName != lastResidueName) || (lastChain !== currentChain)) {
                lastSeqNo = currentSeqNo;
                lastResidueName = residueName;
                residue = _createResidueObj();
                residue.id = currentSeqNo;
                residue.name = residueName;
                _setResidueType(residue,atom);
                chain.residues[residue.id] = residue;
                if (!chain.type) {
                    chain.type = residue.type;
                } else if (chain.type !== residue.type) {
                    if ((residue.type == "a") || (residue.type == "n")) { 
                        chain.type = residue.type;
                    }
                }
            }

            lastChain = currentChain;
            residue.atoms.push(atom);

            // Update residue and chain extents.
            setMin(residue, atom.x,atom.y,atom.z);
            setMax(residue, atom.x,atom.y,atom.z);
            setMin(chain, atom.x,atom.y,atom.z);
            setMax(chain, atom.x,atom.y,atom.z);
        }

        // Create an entity for each compound.
        var compound, entity;
        var id, chains;
        for (var i = 0, n = molecule.compounds.length; i < n; i++) {
            compound = molecule.compounds[i];
            id = compound.id;
            entity = _createEntityObj();
            entity.id = id;
            entity.description = compound.description;
            //entity.type = "polymer";
            entity.type = "default";
            entities[id] = entity;
            for (var j = 0, m = compound.chains.length; j < m; j++) {
                entity.chainIDs.push(compound.chains[j]);
            }
        }

        modelData.push({symmetries:[]});

        // Create BioAssembly objects.
        var assembly, biomolecule, entity;
        var id, chains;
        for (var i = 0, n = molecule.biomolecules.length; i < n; i++) {
            biomolecule = molecule.biomolecules[i];
            assembly = _createAssemblyObj();
            assembly.assemblyID = biomolecule.id;
            for (var j = 0, m = biomolecule.chains.length; j < m; j++) {
                assembly.chains.push(biomolecule.chains[j]);
            }
            entity = _getEntityForTheseAssemblyChains(entities, assembly.chains, assembly.assemblyID);
            assembly.entityID = entity.id;
            for (var xformID in biomolecule.xforms) {
                assembly.transforms.push(biomolecule.xforms[xformID]);
            }
            assemblies[assembly.assemblyID] = assembly;
        }

        // Map residues to chain IDs. 
        for (var chainID in chains) {
            chain = chains[chainID];
            residues[chainID] = chain.residues;
        }

        // Add covalent bonds between atoms.
        assignBonds(molecule.atoms, residues, molecule.residueConnectivity);

        // Assign secondary structure to atoms.
        assignSecondaryStructure(molecule.secondaryStructures, residues);
        for (var i = 0, n = molecule.atoms.length; i < n; i++) {
            atom = molecule.atoms[i]
            //console.log(">>> atom " + atom.id + "  chainID " + atom.chainID + "  res " + atom.resNumber + 
            //    "  ssType " + atom.ssType);
         }

        setEntitiesMinMax(entities, chains);

        return {
            assemblies:assemblies,
            atomMetadata: molecule.atoms, 
            chains: chains, 
            entities: entities, 
            header: headerObj,
            positions: positions,
            residues: residues 
        };
    }

    return {
       readCIFFile : readCIFFile,
       readPDBFile : readPDBFile
    };

};
;// set up namespace...
Autodesk.Viewing.MolViewer = Autodesk.Viewing.MolViewer || {};

/**
 * constructor for MetaData
 * @param {object} viewer - the 3DViewer object.
 */
Autodesk.Viewing.MolViewer.MetaData = function(cifModel) {
    var time = Date.now();
    this.subTitle = '';
    this.selectedInstances = [];
    this.selectedChains = [];
    this.selectedResidues = [];
    this.selectedAtoms = [];
    this.parentInstances = [];
    this.parentChains = [];
    this.parentResidues = [];
    this.shortNames = {
        'ALA': 'A',
        'ARG': 'R',
        'ASN': 'N',
        'ASP': 'D',
        'ASX': 'B',
        'CYS': 'C',
        'GLU': 'E',
        'GLN': 'Q',
        'GLX': 'Z',
        'GLY': 'G',
        'HIS': 'H',
        'ILE': 'I',
        'LEU': 'L',
        'LYS': 'K',
        'MET': 'M',
        'PHE': 'F',
        'PRO': 'P',
        'SER': 'S',
        'THR': 'T',
        'TRP': 'W',
        'TYR': 'Y',
        'VAL': 'V',
        'A': 'A',
        'T':'T',
        'U':'U',
        'C': 'C',
        'G': 'G',
        'DA': 'A',
        'DT':'T',
        'DU':'U',
        'DC': 'C',
        'DG': 'G',
        'HOH': 'HOH',
        'GLC': 'GLC'
    };

    this.atomNames = {
        'H': 'Hydrogen',
        'LI': 'Lithium',
        'BE': 'Beryllium',
        'B': 'Boron',
        'C': 'Carbon',
        'N': 'Nitrogen',
        'O': 'Oxygen',
        'F': 'Fluorine',
        'NA': 'Sodium',
        'MG': 'Magnesium',
        'AL': 'Aluminum',
        'Si': 'Silicon',
        'P': 'Phosphorus',
        'S': 'Sulphur',
        'Cl': 'Chlorine',
        'K': 'Potassium',
        'CA': 'Calcium',
        'V': 'Vanadium',
        'SE': 'Selenium',
        'FE': 'Iron'
    };

    this._loadMetaData(cifModel); //create the metaData array
    this._buildMetaArray(); //Maps to metaData array.  Each row has chain id, residue number, residue name, atom name
    this._buildAtomArray(); //Maps to metaData array. Each row has atom name
    this._buildAtomInfoArray(); //Maps to metaData array. Each row has atom name and positional data
    this._buildBFactorArray(); //Maps to metaData array. Each row has the B-Factor of that atom
    this._buildResidueArray(); //Maps to metaData array. Each row has residue name
    this._buildResidueIDArray(); //Maps to metaData array. Each row has residue number
    this._buildChainArray(); //Maps to metaData array. Each row has chain ID
    this._buildEntityAtomsArray(); //Maps to metaData array. Each row has entity ID
    this._buildMoleculeTypeArray(); //generates type by atom from MyData.metadata['custom json'].residue[n].type
    this._buildChainTypeObject(); //generates an object mapping chain ids to types
    console.log(Date.now() - time+' ms to build arrays');
}; // end constructor


Autodesk.Viewing.MolViewer.MetaData.prototype = Object.create(Autodesk.Nano.MetaData.prototype);

/**
 * Builds an array of atomic data objects
 * @param {object} viewer - the 3DViewer object.
 */
Autodesk.Viewing.MolViewer.MetaData.prototype._loadMetaData = function _loadMetaData(molModel) {

    if(molModel) {
        this.metaData = molModel.atomMetadata;
        this.entities = molModel.entities;
        this.modelResidues = molModel.residues;
        this.bFactorMin = molModel.header.bFactorMin;
        this.bFactorMax = molModel.header.bFactorMax;
        this.title = molModel.header.id;
        this.subTitle = molModel.header.title;
        this.author = molModel.header.author;
        return true;
    }
};


/**
 * Builds an array containing the chainID, resNumber, residue name, atom name, B-factor.
 * Maps to this.metaData.
 */
Autodesk.Viewing.MolViewer.MetaData.prototype._buildMetaArray = function _buildMetaArray() {
    var self = this,
        name,
        i;
    this.metaArray = [];
    if (!this.metaData) {
        return false;
    }
    for (i = 0; i < this.metaData.length; i++) {
        name = self.shortNames[this.metaData[i].residue.trim().replace(/[\cA-\cZ0-9]/g,"")];
        name = name ? name : this.metaData[i].residue.substr(0,3);
        this.metaArray.push([this.metaData[i].chainID.trim(),
            this.metaData[i].resNumber,
            name,
            this.metaData[i].detailType.trim().substr(0,2).replace(/(.)[0-9A-Z ]?/,"$1"),
            this.metaData[i].bFactor]);
    }
    return true;
};


/**
 * Builds an array containing the atom names.
 * Maps to this.metaData.
 */
Autodesk.Viewing.MolViewer.MetaData.prototype._buildAtomArray = function _buildAtomArray() {
    var i;
    this.atoms = [];
    if (!this.metaData) {
        return false;
    }
    for (i = 0; i < this.metaData.length; i++) {
        this.atoms.push(this.metaData[i].detailType.trim().substr(0,2).replace(/(.)[0-9A-Z ]?/,"$1"));
    }
    return true;
};


/**
 * Builds an array containing the atom info including name and position data.
 * Maps to this.metaData.
 */
Autodesk.Viewing.MolViewer.MetaData.prototype._buildAtomInfoArray = function _buildAtomInfoArray() {
    var i;
    this.atomInfo = [];
    if (!this.metaData) {
        return false;
    }
    for (i = 0; i < this.metaData.length; i++) {
        this.atomInfo.push(this.metaData[i].detailType.trim());
    }
    return true;
};


/**
 * Builds an array containing the B-factor data for atoms.
 * Maps to this.metaData.
 */
Autodesk.Viewing.MolViewer.MetaData.prototype._buildBFactorArray = function _buildBFactorArray() {
    var i;
    this.bFactors = [];
    if (!this.metaData) {
        return false;
    }
    for (i = 0; i < this.metaData.length; i++) {
        this.bFactors.push(this.metaData[i].bFactor);
    }
    return true;

};


/**
 * Builds an array containing the residue numbers.
 * Maps to this.metaData.
 */
Autodesk.Viewing.MolViewer.MetaData.prototype._buildResidueIDArray = function _buildResidueIDArray() {
    var i;
    this.residueIDs = [];
    if (!this.metaData) {
        return false;
    }
    for (i = 0; i < this.metaData.length; i++) {
        this.residueIDs.push(this.metaData[i].chainID + '-' + this.metaData[i].resNumber);
    }
    return true;
};


/**
 * Builds an array containing the residue designations.
 * Maps to this.metaData.
 */
Autodesk.Viewing.MolViewer.MetaData.prototype._buildResidueArray = function _buildResidueArray() {
    var i;
    this.residues = [];
    if (!this.metaData) {
        return false;
    }
    for (i = 0; i < this.metaData.length; i++) {
        this.residues.push(this.metaData[i].residue.trim().replace(/[\cA-\cZ0-9]/g,""));
    }
    return true;
};


/**
 * Builds an array containing the chain ids.
 * Maps to this.metaData.
 */
Autodesk.Viewing.MolViewer.MetaData.prototype._buildChainArray = function _buildChainArray() {
    var i;
    this.chains = [];
    if (!this.metaData) {
        return false;
    }
    for (i = 0; i < this.metaData.length; i++) {
        this.chains.push(this.metaData[i].chainID.trim());
    }
    return true;
};

/**
 * Builds an array containing the entity ids.
 * Maps to this.metaData.
 */
Autodesk.Viewing.MolViewer.MetaData.prototype._buildEntityAtomsArray = function _buildEntityAtomsArray() {
    if (!this.metaData) {
        return false;
    }
    var i,
        val,
        entity,
        entities = this.entities;
    this.entityAtoms = [];
    for (i = 0; i < this.metaData.length; i++) {
        val = null;
        for (entity in entities) {
            if(entities.hasOwnProperty(entity)) {
                if(entities[entity].chainIDs.indexOf(this.metaData[i].chainID) >= 0) {
                    val = entity;
                    break;
                }
            }
        }
        this.entityAtoms.push(val);
    }
    return true;
};

/**
 * Builds an array containing the molecule types.
 * Maps to this.metaData.
 */
Autodesk.Viewing.MolViewer.MetaData.prototype._buildMoleculeTypeArray = function _buildMoleculeTypeArray() {
    var i,
     residues = this.modelResidues;

    this.moleculeTypes = [];
    if (!this.metaData) {
        return false;
    }
    for (i = 0; i < this.metaData.length;i++) {
        this.moleculeTypes.push([this.metaData[i].chainID.trim(),this.metaData[i].chainID.trim()+'-'+this.metaData[i].resNumber,residues[this.metaData[i].chainID][this.metaData[i].resNumber].type]);
    }

};

Autodesk.Viewing.MolViewer.MetaData.prototype._buildChainTypeObject = function _buildChainTypeObject() {
    var uniqueChains = this.getUniqueItems(this.chains,0),
        i,
        j,
        chain,
        type = 'o';

    this.chainTypes = {};

    for (i = 0; i < uniqueChains.length; i++) {
        chain = this.findAtoms(uniqueChains[i],'chain');
        for (j = 0; j < chain.length; j++) {
            type = this.moleculeTypes[chain[j]][2];
            if (type === 'n' || type === 'a') {
                break;
            } else {
                type = 'o';
            }

        }
        this.chainTypes[uniqueChains[i]] = type;
    }
};

Autodesk.Viewing.MolViewer.MetaData.prototype.getPolymerChains = function getPolymerChains() {
    var chain,
        output = [];
    for (chain in this.chainTypes) {
        if(this.chainTypes.hasOwnProperty(chain)) {
            if(this.chainTypes[chain] !== 'o') {
                output.push(chain);
            }
        }
    }
    return output;
};

/**
 * performs a search of the array based on type, returns array of atoms.
 * @param {string} term - the term for which to search
 * @param {string} type - type of search to be performed - determines which array is searched
 * choices are: atom, bFactor, residueID, residue, chain, and entity
 * @returns {object} atomResults - an array of atom ids (i.e. metaData row numbers)
 * Usage: this.findAtoms('C','atom') returns atom ids for all Carbon (C) atoms
 * Usage: this.findAtoms('B','chain') returns the atom ids for all atoms in chain 'B'
 */
Autodesk.Viewing.MolViewer.MetaData.prototype.findAtoms = function findAtoms(term,type) {
    var i,
        atomResults = [],
        searchArray,
        searchLength;

    if (!term || !type) {
        return false;
    }
    switch(type) {
        case 'atom':
            searchArray = this.atoms;
            searchLength = this.atoms.length;
            break;
        case 'bFactor':
            searchArray = this.bFactors;
            searchLength = this.bFactors.length;
            break;
        case 'residueID':
            searchArray = this.residueIDs;
            searchLength = this.residueIDs.length;
            break;
        case 'residue':
            searchArray = this.residues;
            searchLength = this.residues.length;
            break;
        case 'chain':
            searchArray = this.chains;
            searchLength = this.chains.length;
            break;
        case 'entity':
            searchArray = this.chains;
            searchLength = this.chains.length;
            var entity = this.entities[term];
            if(entity && entity.chainIDs.length > 0) {
                for (i = 0; i < searchLength; i++) {
                    for(var j = 0;j < entity.chainIDs.length;++j) {
                        if (searchArray[i] === entity.chainIDs[j]) {
                            atomResults.push(i);
                        }
                    }
                }
            }
            return atomResults;
        case 'instance':
            searchArray = TheMolMan.molModels[0].activeInstances;
            searchLength = TheMolMan.molModels[0].activeInstances.length;
            break;
    }

    for (i = 0; i < searchLength; i++) {
        if (searchArray[i] === term) {
            atomResults.push(i);
        }
    }
    return atomResults;

};


/**
 * performs a search of the metaArray, returns array of atom ids.
 * @param {string} term - the term for which to search
 * @param {string} searchType - type of search to be performed - determines which array column is searched
 * choices are: atom, bFactor, residueID, residue, chain
 * @param {string} returnType - type of data to be returned - determines which array column is returned
 * choices are: atom, bFactor, residueID, residue, chain
 * @returns {object} atomResults - an array of arrays, each one of which contains
 * an atom id (i.e. metaData row numbers) and the value of the column specified by returnType
 * Usage: this.findAtoms2('VAL','residue','atom') returns an array of arrays of atom ids and the letter of
 * each atom
 */
Autodesk.Viewing.MolViewer.MetaData.prototype.findAtoms2 = function findAtoms2(term,searchType,returnType) {
    var i,
        searchColumn,
        returnColumn,
        atomResults = [],
        searchArray = this.metaArray,
        searchLength = this.metaArray.length;

    if (!term || !searchType) {
        return false;
    }
    switch(searchType) {
        case 'atom':
            searchColumn = 3;
            break;
        case 'bFactor':
            searchColumn = 4;
            break;
        case 'residueID':
            searchColumn = 1;
            break;
        case 'residue':
            searchColumn = 2;
            break;
        case 'chain':
            searchColumn = 0;
            break;
    }

    switch(returnType) {
        case 'atom':
            returnColumn = 3;
            break;
        case 'bFactor':
            returnColumn = 4;
            break;
        case 'residueID':
            returnColumn = 1;
            break;
        case 'residue':
            returnColumn = 2;
            break;
        case 'chain':
            returnColumn = 0;
            break;
    }

    for (i = 0; i < searchLength; i++) {
        if(searchArray[i][searchColumn] === term) {
            atomResults.push([i,searchArray[i][returnColumn]]);
        }
    }
    return atomResults;
};


Autodesk.Viewing.MolViewer.MetaData.prototype.mapItems = function findItems(obj,type) {
    if (type === 'residueID') {
        return this.metaData[obj].chainID + '-' + this.metaData[obj].resNumber;
    } else {
        return this.metaData[obj][type];
    }
};;Autodesk.Nano = Autodesk.Nano || {};
Autodesk.Nano.MolViewer = Autodesk.Nano.MolViewer || {};

Autodesk.Nano.MolViewer.GeometryCache = function () {
    /**
     *
     * @param entityID ID for entity
     * @param viewType  type of view (CPK, etc..) string
     * @param geometry the THREE.Geometry object
     * @param md5Data  the data we use for the md5 calc, controlled by the view(indices for mesh, positions/translations for imposters
     */
    var _entities = {};
    function addGeometryCache(entityID,viewType,geometry,dataID){

        var entity, view;
        if(!_entities[entityID]){
            entity = {views:{}};
            _entities[entityID] = entity;
        }else{
            entity = _entities[entityID];
        }
        if(!entity.views[viewType]){
            view = {dataID :{}}
            entity.views[viewType] = view;

        }else{
            view = entity.views[viewType];
        }
        view.dataID[dataID] = geometry;
    };
    function getGeometryCache(entityID, viewType, dataID){
        var geometry = null;
        var entity = _entities[entityID];
        var view;
        if(entity){
            view = entity.views[viewType];
            if(view){
                geometry = view.dataID[dataID];
            }
        }
        return geometry;

    };

    function removeGeometry(entityID,viewType,dataID){
        var entity = _entities[entityID];
        var view,geometry;
        if(entity){
            view = entity.views[viewType];
            if(view){
                geometry = view.dataID[dataID];
                if(geometry ){
                    delete view.dataID[dataID];
                    geometry.dispose && geometry.dispose();
                }
            }
        }
    };

    function removeAllGeometries(entityID){
        var entity = _entities[entityID];
        var view,geometry;
        if(entity) {
            for (var viewType in entity.views) {
                view = entity.views[viewType];
                for (var dataID in view.dataID) {
                    geometry = view.dataID[dataID];
                    geometry.dispose && geometry.dispose();
                }
            }
            delete _entities[entityID];
        }

    };

    return {
        getGeometryCache: getGeometryCache,
        addGeometryCache: addGeometryCache,
        removeGeometry: removeGeometry,
        removeAllGeometries: removeAllGeometries

    };

};;/**
 * The MolInstance object now contains the atom state and selection state for each instance
 * It also keeps track of the fragment segment it is part of.
 * We may move molreps to also be in here.
 * @param molModel
 * @param molMan
 * @param entityIDs
 * @constructor
 */
Autodesk.Viewing.MolViewer.MolInstance = function(molModel,molMan,entityIDs){
    this.id = THREE.Math.generateUUID();
    this.reps = {'surface':{model:null,startFrag:-1,endFrag:-1,atomToFrags:null},
                 'stick':{model:null,startFrag:-1,endFrag:-1,atomToFrags:null},
                 'ribbon':{model:null,startFrag:-1,endFrag:-1,atomToFrags:null}};

    this.hasSharedProperties = false;
    this.molModel = molModel;
    this.molMan = molMan;
    this.molMetadata = this.molModel.molMetadata;
    this.viewer = molModel.viewer;
    this.entityIDs = entityIDs;
    this.selection = {
        instanceSelected: false,
        chain: [],
        residue: [],
        atomType: [],
        atomID: new BitSet(molModel.getNumAtoms(), 0),
        atoms: new BitSet(molModel.getNumAtoms(), 0)
    };
    this.molReps = new Autodesk.Viewing.MolViewer.MolReps(molModel,this,this.viewer);

    this.atomSelectionState =  new Autodesk.Viewing.MolViewer.AtomSelectionState(this,this.viewer);

    this.atomRepState =  new Autodesk.Viewing.MolViewer.AtomRepState(this);

    //effectively world transform
    this.transform = new THREE.Matrix4();
    this.origTransform = new THREE.Matrix4(); //original transform set from assembly

    this.bbox =  new THREE.Box3();
    this.origBBox = new THREE.Box3();

    // save offset for moving annotations when exploding structures.
    this.explodeOffset = new THREE.Vector3();

    // save explode offsets for entities.
    this.entityExplodeOffsets = null;



    //mz hardcoding views here will move out later...maybe
    this._3DViews = {};
    if(!this._3DViews['CPK']) {
        if(this.viewer.impl.useFragDepth) {
            this._3DViews['CPK'] = new Autodesk.Nano.MolViewer.CPKView(this.viewer.impl.scene, this, this.viewer);
        }else{
            this._3DViews['CPK'] = new Autodesk.Nano.MolViewer.CPKMeshView(this.viewer.impl.scene, this, this.viewer);
        }
    }

    if(!this._3DViews['ribbon']) {
       this._3DViews['ribbon'] = new Autodesk.Nano.MolViewer.RibbonView(this.viewer.impl.scene,this, this.viewer);
    }

    if(!this._3DViews['surface']) {
        this._3DViews['surface'] = new Autodesk.Nano.MolViewer.SurfaceView(this.viewer.impl.scene,this, this.viewer);
    }


    if(!this._3DViews['stick']) {
        this._3DViews['stick'] = new Autodesk.Nano.MolViewer.StickView(this.viewer.impl.scene,this, this.viewer);
    }


};

Autodesk.Viewing.MolViewer.MolInstance.prototype.getID= function getID(){
    return this.id;
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.createViewsFromInstance = function createViewsFromInstance(instance){

    var material;
    for(var view in this._3DViews)
    {
        var molRepRep = this.molReps.reps[view];
        if (instance._3DViews[view])  {
            this._3DViews[view].createFrom(instance._3DViews[view],molRepRep);
        }
    }

};

Autodesk.Viewing.MolViewer.MolInstance.prototype.setViewTransforms = function setViewTransforms(mat4){

    this.transform.copy(mat4);
    this.origTransform.copy(mat4);
    if(this.center) {
        this.center.applyMatrix4(mat4);
    }

    this.bbox.applyMatrix4(mat4);
    this.origBBox.copy(this.bbox);
    for(var view in this._3DViews)
    {
        this._3DViews[view].setTransforms(this.transform);
    }

};



Autodesk.Viewing.MolViewer.MolInstance.prototype.setExplodeOffset = function setExplodeOffset(pt) {

    this.explodeOffset.x = pt.x;
    this.explodeOffset.y = pt.y;
    this.explodeOffset.z = pt.z;
    this.transform.elements[12] = this.origTransform.elements[12] + pt.x;
    this.transform.elements[13] = this.origTransform.elements[13] + pt.y;
    this.transform.elements[14] = this.origTransform.elements[14] + pt.z;
    //?? this.bbox
    //?? this.center?
    for(var view in this._3DViews)
    {
        this._3DViews[view].setTransforms(this.transform);
    }
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.setEntityExplodeOffset = function setEntityExplodeOffset(entityID,pt) {

    this.entityExplodeOffsets[entityID].x = pt.x;
    this.entityExplodeOffsets[entityID].y = pt.y;
    this.entityExplodeOffsets[entityID].z = pt.z;
    this.molMan.cachedTransform.copy(this.origTransform)
    this.molMan.cachedTransform.elements[12] +=  pt.x;
    this.molMan.cachedTransform.elements[13] +=  pt.y;
    this.molMan.cachedTransform.elements[14] +=  pt.z;

    //?? this.bbox
    //?? this.center?
    for(var view in this._3DViews)
    {
        this._3DViews[view].setEntityTransforms(entityID,this.molMan.cachedTransform);
    }
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.toJSONObj = function toJSONObj(){
    var obj = {};
    obj.atomRepState = this.atomRepState.toJSONObj();
    obj.molReps = this.molReps.toJSONObj();
    return obj;
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.fromJSONObj = function fromJSONObj(obj){
    this.atomRepState.fromJSONObj(obj.atomRepState);
    this.molReps.fromJSONObj(obj.molReps);
    var reps = ['ribbon', 'stick', 'surface', 'CPK'];
    for (var i = 0; i < reps.length; ++i) {
        this._turnOffVisibility(reps[i]);
    }
    this._setRepsFromState(); //sets up the index buffers
    this.setMaterialsBasedUponOpacity('surface'); //just care about surface for now

};


Autodesk.Viewing.MolViewer.MolInstance.prototype.dtor = function dtor() {

    this.viewer.impl.highlightObjectByAtoms(this,[],false);

    //need to move out but okay for now, needs to happend FIRST before data is removed below.
    for(var id in this._3DViews){
        this._3DViews[id].dtor();
    }


    if(!this.hasSharedProperties) {
        this.molReps.removeMaterials(this.viewer);
        this.molReps.dtor();
        this.atomRepState.dtor();
        this.atomSelectionState.dtor();
        this.molReps.dtor();
        this.atomRepState.dtor();

    }


    delete this.selectionAlphaTextureAtom;
    delete this.selectionMaterialBase;
    delete this.selectionMaterialTop;
    delete this.getUVSelection;
    delete this.atomSelectionState;
    delete this.molReps;
    delete this.molModel;
    delete this.atomRepState;

    delete this.reps;
    this.reps = null;
    this.molMetadata = null;
    this.viewer = null;
    this.selection = null;
    this.atomSelectionState = null;
    this.molReps = null;



};


Autodesk.Viewing.MolViewer.MolInstance.prototype.setAtomToFrags = function setAtomToFrags(rep,atomToFrags){
    this.reps[rep].atomToFrags = atomToFrags;
};



Autodesk.Viewing.MolViewer.MolInstance.prototype.getSelection= function getSelection() {
    return this.selection;
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.clearSelection = function clearSelection(nofire) {
    this.selection.instanceSelected = false;
    this.selection.chain = [];
    this.selection.residue = [];
    this.selection.atom = [];
    this.selection.atomID.clear();
    this.selection.what = null;
    this.atomSelectionState.clearSelection(); //this will clear up the atoms
    //firing events moved back to model
};



Autodesk.Viewing.MolViewer.MolInstance.prototype._getAtoms = function _getAtoms(what) {
    var atoms = [],
        i,
        j,
        chains,
        term,
        key;
    for (key in what) {
        if (what.hasOwnProperty(key)) {
            if (key === 'instance') {
                chains = this.molModel.uniqueChains;
                for (j = 0; j < chains.length; ++j) {
                    atoms = atoms.concat(this.molMetadata.findAtoms(chains[j], 'chain'));
                }
            } else if (key !== 'atomID') {
                for (i = 0; i < what[key].length; ++i) {
                    term = what[key][i];
                    atoms = atoms.concat(this.molMetadata.findAtoms(term, key));

                }
            } else {
                for (i = 0; i < what[key].length; ++i) {
                    atoms = atoms.concat(what[key][i]);
                }
            }
        }
    }
    return atoms;
};


Autodesk.Viewing.MolViewer.MolInstance.prototype._setSelections = function _setSelections(what) {
    var results = [],
        i,
        j,
        term,
        key1,
        atoms;
    for (var key in what) {
        if (what.hasOwnProperty(key)) {
            if (key === 'instance') {
                for (i = 0; i < what[key].length; ++i) {
                    term = what[key][i];
                    for (j = 0; j < this.molModel.activeInstances.length; j++) {
                        if (this.molModel.activeInstances[j].id === term) {
                            this.molModel.activeInstances[j].selection.instanceSelected = true;
                        }
                    }
                }

            } else if (key !== 'atomID') {
                for (i = 0; i < what[key].length; ++i) {
                    term = what[key][i];
                    results = this.molMetadata.findAtoms(term, key);
                    key1 = key === 'residueID' ? 'residue' : key === 'atom' ? 'atomType' : key;
                    this.selection[key1].push(results);

                }
                this.instanceSelected = true;

            } else {
                atoms = what[key];
                for (i = 0; i < atoms.length; i++) {
                    this.selection['atomID'].set(atoms[i], 1);

                }
            }

        }
    }
};


/**
 *
 * @param returns number of atoms selected
 */
Autodesk.Viewing.MolViewer.MolInstance.prototype.numSelected = function numSelected(what) {
    return this.atomSelectionState.numSel;
};
/**
 @param what {} an object specifying the selection, made up of a set of key:value pairs
 * valid key types are 'chain','residue', 'residueID','atom','atomID'.  The value will always be an array
 @return returns true if selected or false
 */
Autodesk.Viewing.MolViewer.MolInstance.prototype.isSelected = function isSelected(what) {
    var i;
    var somethingIsSelected = false;
    for (var key in what) {
        if (key !== 'atomID') {
            var key1 = key === 'residueID' ? 'residue' : key === 'atom' ? 'atomType': key;
            if (this.selection[key1][what]){
                somethingIsSelected = true;
            }else{
                return false;
            }
        }else{
            for (i = 0; i < what[key].length;++i) {
                if (this.atomSelectionState.isAtomSelected(what[key][i])){
                    somethingIsSelected = true;
                }else{
                    return false;
                }
            }
        }
    }

    return somethingIsSelected;

};


Autodesk.Viewing.MolViewer.MolInstance.prototype.removeSelected = function removeSelected(what){
    return;
    var i,j;
    var newSelection = {
        instanceSelected: false,
        chain: [],
        residue: [],
        atom:[],  //matches to atomType
        atomID:[]
    };
    if(this.selection.chain.length > 0){
        newSelection.chain = this.selection.chain.slice();
    }
    if(this.selection.residue.length > 0){
        newSelection.residue = this.selection.residue.slice();
    }
    if(this.selection.atomType.length > 0){
        newSelection.atomType = this.selection.atomType.slice();
    }

    var term,results,key1;
    for (var key in what) {
        if (key !== 'atomID') {
            for (i = 0; i < what[key].length; ++i) {
                term = what[key][i];
                results = this.molMetadata.findAtoms(term, key);
                key1 = key === 'residueID' ? 'residue' : key === 'atom' ? 'atomType' : key;
                for (i = 0; i < results.length; ++i) {

                }
            }
        } else if (key === 'atomID') {
            var atoms = what[key];
            for (i = 0; i < atoms.length; i++) {
                this.selection['atomID'].set(atoms[i], 1);
            }
        }
    }
    return newSelection;
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.toggleSelection = function toggleSelection(resultArray){

    for(var z = 0; z< resultArray.length;++z) {

        var result = resultArray[z];
        var atomNum;
        if (result.atomID) {
            atomNum = this.atomSelectionState.getAtomNumFromResult(result);
        }else{
            atomNum = result;

        }
        var obj = this.getFiltered(atomNum);
        /* will add this later
         if(this.isSelected(obj)){
         var newSelection = this.removeSelected(obj);
         this.select(newSelection,false);
         }
         else
         */
        {
            var obj = this.getFiltered(atomNum);
            this.select(obj,true);
        }
    }

};

//off for now still,need to figure out if this is the whole selection or not, time consuming.
Autodesk.Viewing.MolViewer.MolInstance.prototype.selectionIsEqual = function selectionIsEqual(resultArray) {
    return false;
}

Autodesk.Viewing.MolViewer.MolInstance.prototype.getSelectionBounds = function getSelectionBounds () {
    var bounds = new THREE.Box3();
    var box = new THREE.Box3();
    var selected = this.atomSelectionState.getSelected();
    var atoms = this.molModel.atomMetadata;
    var bbox = this.molModel.residues;
    var off  = this.molModel.getGlobalOffset();
    for(var i =0;i< selected.length; ++i){
        var atom = atoms[selected[i]];
        var whichChain = bbox[atom.chainID];
        var residueNum = atom.resNumber;
        var minMax = whichChain[residueNum];
        box.set( new THREE.Vector3(minMax.minX - off.x,minMax.minY - off.y, minMax.minZ-off.z) ,
            new THREE.Vector3(minMax.maxX  - off.x,minMax.maxY - off.y, minMax.maxZ - off.z));
        //console.log((box.max.x - box.min.x) + " " + (box.max.y - box.min.y) + " " + (box.max.z - box.min.z) );
        bounds.union(box);
    }
    return bounds;
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.getFiltered = function getFiltered(atomNum){
    var type = this.molMan.selectionFilter;
    var values = [];
    var term;
    if (type === 'instance') {
        term = this.id;
        values.push(term);
    } else if (type === 'chain'){
        term = this.molMetadata.chains[atomNum];
        values.push(term);
    }else if (type ==='residueID'){
        term = this.molMetadata.residueIDs[atomNum];
        values.push(term);
    }else if (type ==='residue'){
        term = this.molMetadata.residues[atomNum];
        values.push(term);
    }else if (type ==='atom'){
        term = this.molMetadata.atoms[atomNum];
        values.push(term);
    }else if (type ==='atomID'){
        values.push(atomNum);
    }
    var obj = {};
    obj[type]  = values;
    return obj;
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.markObject = function markObject(result,keepSelection){
    var atomNum;
    var instances=[];
    if (result.atomID) {
        atomNum = this.atomSelectionState.getAtomNumFromResult(result);
    }else{
        atomNum = result;
    }
    var obj = this.getFiltered(atomNum);
    instances.push({instance: this, what:obj});
    this.molModel.select(instances,keepSelection);
};


Autodesk.Viewing.MolViewer.MolInstance.prototype.getChainIDs = function getChainIDs() {
    var entityID,
        i,
        chains = [];
    for (i = 0; i < this.entityIDs.length; ++i) {
            chains = chains.concat(this.molModel.entities[this.entityIDs[i]].chainIDs);
    }
    return chains;
};

// get an object containing visible chains and residues
Autodesk.Viewing.MolViewer.MolInstance.prototype.getVisible = function getVisible() {
    var results = {
        ribbon: {chains:[],residues:[]},
        stick: {chains:[],residues:[]},
        surface: {chains:[],residues:[]}
        },
        residues = [],
        chainIDs = this.getChainIDs(),
        atoms = [],
        visAtoms,
        rep,
        i;

    for (rep in results) {
        if(results.hasOwnProperty(rep)) {
            for (i = 0; i < chainIDs.length; i++) {
                atoms = this.molMetadata.findAtoms(chainIDs[i], 'chain');
                if (this.atomRepState.getAtomsRep(rep,atoms,true)) {
                    results[rep].chains.push(chainIDs[i]);
                } else if (this.atomRepState.getAtomsRep(rep,atoms,false)) {
                    visAtoms = this.atomRepState.getWhichAtomsOn(rep,atoms);
                    residues = this.molMetadata.findItems('residueID',visAtoms);
                    results[rep].residues =  results[rep].residues.concat(residues);
                }
            }
        }
    }
    return results;
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.isForAssembly = function isForAssembly() {
    return this.molModel.entities[this.entityIDs[0]].isForAssembly;
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.useTheseRepsAndColors= function useTheseRepsAndColors(reps,atomRepState,molReps){
    for(var rep in this.reps){
        this.reps[rep].model = reps[rep].model;
        this.reps[rep].startFrag = reps[rep].startFrag;
        this.reps[rep].endFrag = reps[rep].endFrag;

    }
    this.atomRepState.createFrom(atomRepState);
    this.molReps.createFrom(molReps);
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.setDefaultReps = function setDefaultReps(){

    var rep;
    for(rep in this.atomRepState.bitSets){
        this.atomRepState.setAtomsRep(rep,null,0);
    };

    var atoms = this.molModel.atomMetadata;
    var residue = this.molModel.residues;
    var ribbonAtoms = [], stickAtoms = [];
    for(var i =0;i< atoms.length; ++i){
        var atom = atoms[i];
        var whichChain = residue[atom.chainID];
        var residueNum = atom.resNumber;
        var res = whichChain[residueNum];
        if(res.type ==='n' || res.type ==='a'){
            ribbonAtoms.push(i);
        }else if (res.type ==='l'){
            stickAtoms.push(i);
        }
    }

    if(ribbonAtoms.length > 0) {
        this.atomRepState.setAtomsRep('ribbon', ribbonAtoms, 1);
    }
    if(stickAtoms.length > 0) {
        this.atomRepState.setAtomsRep('stick', stickAtoms, 1);
    }
    this.setRepsFromState('ribbon');
    this.setRepsFromState('stick');

};

Autodesk.Viewing.MolViewer.MolInstance.prototype.setVisibleFromSelection = function setVisibleFromSelection(rep,visible){
    var val = visible ? 1 : 0;
    var atoms = this.atomSelectionState.getSelected();
    this.atomRepState.setAtomsRep(rep,atoms,val);
    this.setRepsFromState(rep);
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.getVisibleFromSelection = function getVisibleFromSelection(rep,checkAll) {
    var atoms = this.atomSelectionState.getSelected();
    return this.atomRepState.getAtomsRep(rep,atoms,checkAll);
};


Autodesk.Viewing.MolViewer.MolInstance.prototype.setOpacityFromSelection = function setOpacityFromSelection(rep,opacity,fromCustom){
    var bitSet = this.atomSelectionState.bitSet.isEmpty() ? null : this.atomSelectionState.bitSet; //if nothing selected set null which acts as all.
    this.molReps.setOpacityFromSelection(rep,opacity,bitSet,fromCustom);
    this.setMaterialsBasedUponOpacity(rep);
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.getOpacityFromSelection = function getOpacityFromSelection(rep) {
    var bitSet = this.atomSelectionState.bitSet.isEmpty() ? null : this.atomSelectionState.bitSet; //if nothing selected set null which acts as all.
    return this.molReps.getOpacityFromSelection(rep,bitSet);
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.setColorFromSelection = function setColorFromSelection(rep, type, colorIndex, bitSet) {
    if (!bitSet) { // if no custom bitSet is passed
        bitSet = this.atomSelectionState.bitSet.isEmpty() ? null : this.atomSelectionState.bitSet; //if nothing selected set null which acts as all.
    }
    this.molReps.colorBy(rep,type,bitSet,colorIndex);

    var what = this.viewer.impl;
    setTimeout(function(){ what.invalidate(true,true,true); }, 300);

};

Autodesk.Viewing.MolViewer.MolInstance.prototype.getCustomColorIndexFromSelection = function getCustomColorIndexFromSelection(rep) {
    var selBitSet = null;
    var i;
    var colors;

    // get ref to atomSelectionState.bitSet if there are selected atoms
    if(!this.atomSelectionState.bitSet.isEmpty()) {
        selBitSet = this.atomSelectionState.bitSet;
    }

    // if null selBitSet is passed we get all custom colors for the rep
    colors = this.molReps.getCustomColorIndexFromSelection(rep,selBitSet);
    return colors;
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.getColorFromSelection = function getColorFromSelection(rep) {
    var bitSet = this.atomSelectionState.bitSet.isEmpty() ? null : this.atomSelectionState.bitSet; //if nothing selected set null which acts as all.
    return this.molReps.getColorTypes(rep,bitSet);
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.getAtomsWithCustomColorIndex = function getAtomsWithCustomColorIndex(rep, index) {
    return {instance: this, bitSet: this.molReps.getAtomsWithCustomColorIndex(rep, index)};
};

//MZ TODO move this to a factory object
Autodesk.Viewing.MolViewer.MolInstance.prototype._createCPKView = function _createCPKView(checkRepState){

    var rep = 'CPK';
    var i,id;
    var forAssembly = this.isForAssembly();
    if (!checkRepState ||this.atomRepState.getAtomsRep(rep)) {

        var molModel = this.molModel;
        for (i = 0; i < this.entityIDs.length; ++i) {
            id = this.entityIDs[i];
            var atomsOn = checkRepState ? this.atomRepState.getWhichAtomsOn(rep, molModel.entities[id].atomIDs) : molModel.entities[id].atomIDs ;
            if (atomsOn.length > 0) {
                var options = {atomsOn: atomsOn, molRepRep: this.molReps.reps[rep]};
                this._3DViews[rep].create(id, options);
                if(!forAssembly){
                    this._3DViews[rep].explodeIfNeeded(id); //since we create our views on demand we may need to explode them out (replace with move ifneeded once API is in).
                }
            }
        }
    }
};

Autodesk.Viewing.MolViewer.MolInstance.prototype._createStickView = function _createStickView(checkRepState) {
    var rep = 'stick';
    var i,id;
    var forAssembly = this.isForAssembly();

    if (!checkRepState ||this.atomRepState.getAtomsRep(rep)) {

        var molModel = this.molModel;
        for (i = 0; i < this.entityIDs.length; ++i) {
            id = this.entityIDs[i];
            var atomsOn = checkRepState ? this.atomRepState.getWhichAtomsOn(rep, molModel.entities[id].atomIDs) : molModel.entities[id].atomIDs ;
            if (atomsOn.length > 0) {
                var options = {atomsOn: atomsOn, molRepRep: this.molReps.reps[rep]};
                this._3DViews[rep].create(id, options);
                if(!forAssembly){
                    this._3DViews[rep].explodeIfNeeded(id); //since we create our views on demand we may need to explode them out (replace with move ifneeded once API is in).
                }
            }

        }

    }

};
Autodesk.Viewing.MolViewer.MolInstance.prototype._createRibbonView = function _createRibbonView(checkRepState) {

    var rep = 'ribbon';
    var i,id;
    var forAssembly = this.isForAssembly();

    if (!checkRepState ||this.atomRepState.getAtomsRep(rep)) {
        var molModel = this.molModel;
        var atoms = molModel.atomMetadata;
        var entity;
        for (i = 0; i < this.entityIDs.length; ++i) {
            id = this.entityIDs[i];
            entity = molModel.entities[id];
            var atomsOn = checkRepState ? this.atomRepState.getWhichAtomsOn(rep, molModel.entities[id].atomIDs,true) : this._getNonHetLigandAtoms(molModel.entities[id].atomIDs);

            if (!entity.isHetOrLigand) {
                for (var j = 0; j < entity.chainIDs.length; j++) {
                    var chainID = entity.chainIDs[j];
                    var chain = molModel.chains[chainID];
                    if(chain.type !== 'l' && chain.type !=='w') { //no ligands please
                        var allAtoms = molModel.entities[id].atomIDs;
                        var meshID =   id + '.' + chainID;
                        var options = {
                            allAtoms: allAtoms,
                            atoms: atoms,
                            atomRepState: this.atomRepState,
                            atomsOn: atomsOn,
                            chainID: chainID,
                            molRepRep: this.molReps.reps[rep]
                        };
                        this._3DViews[rep].create(meshID, options);
                    }
                }
                if(!forAssembly){
                    this._3DViews[rep].explodeIfNeeded(id); //since we create our views on demand we may need to explode them out (replace with move ifneeded once API is in).
                }
            }
        }
    }
};
Autodesk.Viewing.MolViewer.MolInstance.prototype._getNonHetLigandAtoms = function _getNonHetLigandAtoms(atomIDs){

    var atoms = this.molModel.atomMetadata;
    var newAtoms = [];
    for(var i =0 ;i< atomIDs.length;++i){
        var id = atomIDs[i];
        if(!atoms[id].isHet){
            newAtoms.push(id);
        }
    }
    return newAtoms;
};
Autodesk.Viewing.MolViewer.MolInstance.prototype._createSurfaceView = function _createSurfaceView(checkRepState, viewOptions) {

    var rep = 'surface';
    var i,id;
    var forAssembly = this.isForAssembly();

    if (!checkRepState ||this.atomRepState.getAtomsRep(rep)) {
        var molModel = this.molModel;
        var atoms = molModel.atomMetadata;
        var entity;
        for (i = 0; i < this.entityIDs.length; ++i) {
            id = this.entityIDs[i];
            entity = molModel.entities[id];
            if (!entity.isHetOrLigand) {
                var bbox = entity.bbox;
                var allAtoms = this._getNonHetLigandAtoms(molModel.entities[id].atomIDs); //need all of them(minus bad ones!) so we can create the default index buffers

                var atomsOn = checkRepState ? this.atomRepState.getWhichAtomsOn(rep, molModel.entities[id].atomIDs,true) : this._getNonHetLigandAtoms(molModel.entities[id].atomIDs);

                var options = {
                    atoms: atoms,
                    allAtoms: allAtoms,
                    atomsOn: atomsOn,
                    atomRepState: this.atomRepState,
                    bbox: bbox,
                    molRepRep: this.molReps.reps[rep]
                };
                if(viewOptions){
                    options.scaleFactor = viewOptions.scaleFactor;
                }
                this._3DViews[rep].create(id, options);
                if(!forAssembly){
                    this._3DViews[rep].explodeIfNeeded(id); //since we create our views on demand we may need to explode them out (replace with move ifneeded once API is in).
                }
            }
        }
    }
}
Autodesk.Viewing.MolViewer.MolInstance.prototype._setRepsFromState = function _setRepsFromState(r){
    var i,id;
    var rep,reps = []
    if(!r){
        reps.push('CPK');
        reps.push('ribbon');
        reps.push('stick');
        reps.push('surface')
    }else{
        reps.push(r);
    }
    for(var z = 0; z< reps.length; ++z) {
        rep = reps[z];
        if (rep === 'CPK') {
            if (this.atomRepState.getAtomsRep(rep)) {

                this._createCPKView(true);
            }else{
                this._3DViews[rep].hide();
            }

        } else if (rep === 'stick') {
            if (this.atomRepState.getAtomsRep(rep)) {

                this._createStickView(true);

            }else{
                this._3DViews[rep].hide();
            }

        }
        else if (rep === 'ribbon') {
            if (this.atomRepState.getAtomsRep(rep)) {
               this._createRibbonView(true);
            }else{
                this._3DViews[rep].hide();
            }

        } else if (rep === 'surface') {
            if (this.atomRepState.getAtomsRep(rep)) {
                this._createSurfaceView(true);
            }else{
                this._3DViews[rep].hide();
            }
        }
    }
    this.molMan.bboxIsDirty = true;


    var results, bitSet,  opacity;
    for (var id in this.molModel.chains) {
        results = this.molMetadata.findAtoms(id, 'chain');
        bitSet = new BitSet(this.molModel.getNumAtoms());
        for (var k = 0; k < results.length; ++k) {
            bitSet.set(results[k], 1);
        }

        if (this.atomRepState.getAtomsRep('CPK', results) || this.atomRepState.getAtomsRep('stick', results) || this.atomRepState.getAtomsRep('ribbon', results)) {
            opacity = 0.3;
        } else {
            opacity = 1.0;
        }

        if (this.atomRepState.getAtomsRep('surface', results)) {
            this.molReps.setOpacityFromSelection('surface', opacity, bitSet);
            this.setMaterialsBasedUponOpacity(rep);
            var what = this.viewer.impl;
            setTimeout(function(){ what.invalidate(true,true,true); }, 300);
        }

    }


};


Autodesk.Viewing.MolViewer.MolInstance.prototype.setMaterialsBasedUponOpacity = function setMaterialsBasedUponOpacity(rep){

    var view = this._3DViews[rep];
    if(view && view.setMaterialsBasedUponOpacity){
        view.setMaterialsBasedUponOpacity();
        var what = this.viewer.impl;
        setTimeout(function(){ what.invalidate(true,true,true); }, 300);

    }
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.setRepsFromState = function setRepsFromState(rep) {

    //off selection
    var reps = ['ribbon', 'stick', 'surface','CPK'];
    var i;
    //turn all frags off at first.
    if (rep) {
        this._turnOffVisibility(rep);
    } else {
        for (i = 0; i < reps.length; ++i) {
            this._turnOffVisibility(reps[i], false);
        }
    }


    var selatoms = [];
    var state =  this.atomSelectionState;
    for(var i = 0;i < state.atoms.length;++i) {
        if (state.bitSet.get(i)) {
            selatoms.push(i);
        }
    }
    if(selatoms.length > 0) {
        state.unmarkObjects(selatoms);
    }

    this._setRepsFromState(rep);

    if(selatoms.length > 0) {
        state.markObjects(selatoms);
    }


};


/**
 *
 * @param rep 'surface','ribbon','stick'
 * @param visible true or false
 */
Autodesk.Viewing.MolViewer.MolInstance.prototype._turnOffVisibility = function _turnOffVisibility(rep) {
    if(rep) {
        if (this._3DViews[rep]) {
            this._3DViews[rep].hide();
        }
    }else{
        for(var view in this._3DViews){
            this._3DViews[view].hide();
        }
    }
};

//mz todo, maybe move from instance since instance doesn't matter
Autodesk.Viewing.MolViewer.MolInstance.prototype.fireRepChangedEvent = function() {

    var event = {
        type: Autodesk.Viewing.REP_SET_EVENT,
        instance: this
    };
    this.viewer.fireEvent(event);
};


Autodesk.Viewing.MolViewer.MolInstance.prototype.isThisInstance = function isThisInstance(entityID){
    for(var i =0;i<this.entityIDs.length;++i){
        if(entityID === this.entityIDs[i]){
            return true;
        }
    }
    return false;
};


/**
 * This overlay may be used by any 3D mesh, not by an imposter
 */
Autodesk.Viewing.MolViewer.MolInstance.prototype.createOverlay = function createOverlay(){
    var viewer = this.viewer.impl;
    if(!this.selectionAlphaTextureAtom) {
        this.selectionAlphaTextureAtom = this.createAlphaTextureAtom();
        this.selectionMaterialBase = new THREE.MeshPhongMaterial({
            color: 0x000000, specular: 0x000000, emissive: 0x2F51FF,
            alphaTest: 0.5, ambient: 0, opacity: 1.00, alphaMap: this.selectionAlphaTextureAtom, transparent: false
        });
        this.selectionMaterialTop = new THREE.MeshPhongMaterial({
            color: 0x000000, specular: 0x000000, emissive: 0x2F51FF,
            alphaTest: 0.15, ambient: 0, opacity: 0.15, alphaMap: this.selectionAlphaTextureAtom, transparent: true
        });

        //no but we may want to this.selectionMaterialBase.packedNormals = true;
        //no but we may want to this.selectionMaterialTop.packedNormals = true;
        this.selectionMaterialBase.overrideType = 'selectionBase';
        this.selectionMaterialTop.overrideType = 'selectionTop';
        this.overlayName = "selection" + ":" + this.id;
        viewer.createSelectionScene(this.overlayName, this.selectionMaterialBase, this.selectionMaterialTop);
        /*
         this.selectionMaterialBase = new THREE.MeshLambertMaterial({color:0x6699ff, specular:0x080808, emissive:0x334c77,
         alphaTest: 0.5,ambient:0,opacity:1.0, alphaMap:this.selectionAlphaTextureAtom, transparent:false});
         this.selectionMaterialTop = new THREE.MeshLambertMaterial({color:0x6699ff, specular:0x080808, emissive:0x334c77,
         alphaTest: 0.15,ambient:0, opacity:0.15, alphaMap:this.selectionAlphaTextureAtom , transparent:true});
         */

    }
};


Autodesk.Viewing.MolViewer.MolInstance.prototype.GetUVs =  function GetUVs(ni) {
    this.numItems = ni;
    var sq = Math.sqrt(this.numItems);
    this.width = Math.ceil(sq);
    this.height = this.width;
    this.step = 1.0/(this.width);
    this.halfStep = this.step * 0.5;
    var bigSize = 3 * this.width * this.height;
    this.data = new Uint8Array(bigSize);
    var val  = 0;
    for ( var i = 0; i < bigSize; i ++ ) {
        this.data[ i  ] 	= val;
    }
    this.setColor= function(itemNum,r,g,b){
        this.data[ 3* itemNum  ] 	= r;
        this.data[ 3* itemNum +1  ] 	= g;
        this.data[ 3* itemNum   + 2] 	= b;

    }
    this.clearColor= function(){
        var bigSize = 3 * this.width * this.height;
        var val  = 0;
        for ( var i = 0; i < bigSize; i ++ ) {
            this.data[ i  ] 	= val;
        }
    }
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.createAlphaTextureAtom = function createAlphaTextureAtom() {
    this.getUVSelection = new this.GetUVs(this.molModel.getNumAtoms());

    var texture = new THREE.DataTexture( this.getUVSelection.data, this.getUVSelection.width, this.getUVSelection.height,
        THREE.RGBFormat,
        THREE.UnsignedByteType,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
        THREE.LinearFilter, THREE.LinearFilter, 0);
    texture.unpackAlignment = 1;
    texture.generateMipmaps = false;
    texture.flipY = false;
    texture.needsUpdate = true;
    return texture;
};


Autodesk.Viewing.MolViewer.MolInstance.prototype.getCopyOfSelection  = function getCopyOfSelection(){
    if(this.selection.atoms.isEmpty()){
        return null;  //nothing is there so it's empty
    }

    var selection = {
        instanceSelected: false,
        chain: [],
        residue: [],
        atomType: [],
        atomID: new BitSet(this.molModel.getNumAtoms(), 0),
        atoms: new BitSet(this.molModel.getNumAtoms(), 0)
    };

    selection.instanceSelected = this.selection.instanceSelected;
    selection.chain = JSON.parse(JSON.stringify(this.selection.chain));
    selection.residue = JSON.parse(JSON.stringify(this.selection.residue));
    selection.atomType = JSON.parse(JSON.stringify(this.selection.atomType));
    selection.atomID = this.selection.atomID.clone();
    selection.atoms = this.selection.atoms.clone();
    return selection;

};

Autodesk.Viewing.MolViewer.MolInstance.prototype.setSelectionFromState  = function setSelectionFromState(selection){
    this.clearSelection(true);
    this.selection.instanceSelected = selection.instanceSelected;
    this.selection.chain =  selection.chain;
    this.selection.residue = selection.residue;
    this.selection.atomType = selection.atomType;
    this.selection.atomID = selection.atomID.clone();
    this.selection.atoms = selection.atoms.clone();
    delete this.atomSelectionState.bitSet;
    this.atomSelectionState.bitSet = this.selection.atoms;

};
/**
 * returns distance if nothing hit then distance will be Number.MAX_VALUE
 * @param ray
 */
Autodesk.Viewing.MolViewer.MolInstance.prototype.doesThisHitSphere = function doesThisHitSphere(ray){
    var maxDist = Number.MAX_VALUE;
    var offset = this.center;
    for(var rep in this._3DViews) {
        if (this.atomRepState.getAtomsRep(rep)) {
            var dist = this._3DViews[rep].hitTestBoundingSpheres(ray);
            if (dist < maxDist) {
                maxDist = dist;
            }
        }
    }
    return maxDist;

};

Autodesk.Viewing.MolViewer.MolInstance.prototype.doesThisHitAtom = function doesThisHitAtom(ray,atomID,cachedSphere){
    var maxDist = Number.MAX_VALUE;
    var atom = this.molModel.atomMetadata[atomID];
    var radius = this.molMan.getRadius(atom);
    radius *= 5.0; //puff up a little..
    cachedSphere.radius = radius;
    cachedSphere.center.x = atom.x;
    cachedSphere.center.y = atom.y;
    cachedSphere.center.z = atom.z;
    cachedSphere.center.applyMatrix4(this.transform);
    console.log(cachedSphere.center);
    var val = ray.intersectSphere(cachedSphere);
    if(val) {
        var diffx = val.x - cachedSphere.center.x;
        var diffy = val.y - cachedSphere.center.y;
        var diffz = val.z - cachedSphere.center.z;
        var dist = diffx * diffx + diffy * diffy + diffz * diffz;

        if(dist <maxDist) {
            maxDist = dist;
        }

    }
    return maxDist;

};
Autodesk.Viewing.MolViewer.MolInstance.prototype.setShowBFactor = function sethSowBFactor(val){

    this.showBFactor = val;
};
Autodesk.Viewing.MolViewer.MolInstance.prototype.tick  = function tick(){

    if(this.showBFactor) {
        var rep = 'CPK';
        var molModel = this.molModel;
        var i,id;
        var bFactorMin = molModel.header.bFactorMin;
        var bFactorMax = molModel.header.bFactorMax;
        if (this.atomRepState.getAtomsRep(rep)) {
            for (i = 0; i < this.entityIDs.length; ++i) {
                id = this.entityIDs[i];
                var atomsOn = this.atomRepState.getWhichAtomsOn(rep, molModel.entities[id].atomIDs);
                if (atomsOn.length > 0) {
                    var theid =  id;
                    this._3DViews[rep].bFactorAnimation(theid, atomsOn, molModel.atomMetadata,bFactorMin,bFactorMax);
                }
            }
            this.viewer.impl.sceneUpdated(true);

        }
    }

};

Autodesk.Viewing.MolViewer.MolInstance.prototype.getAtomPosition = function getAtomPosition(atomID) {
    var pt = this.molModel.getLocalAtomPosition(atomID);
    if(this.isForAssembly()) {
        pt.applyMatrix4(this.transform);
    }else{
        var entityID = this.molMetadata.entityAtoms[atomID];
        this.molMan.cachedTransform.copy(this.origTransform);
        this.molMan.cachedTransform.elements[12] +=  this.entityExplodeOffsets[entityID].x;
        this.molMan.cachedTransform.elements[13] +=  this.entityExplodeOffsets[entityID].y;
        this.molMan.cachedTransform.elements[14] +=  this.entityExplodeOffsets[entityID].z;
        pt.applyMatrix4(this.molMan.cachedTransform);

    };
    return pt;
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.getSelectedAtomsCenter = function getSelectedAtomsCenter() {
    var atoms = this.atomSelectionState.getSelected();
    if (atoms && atoms.length) {
        return this.getAtomsCenter(atoms);
    }
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.getSelectedAtomsBBox = function getSelectedAtomsBBox() {
    var atoms = this.atomSelectionState.getSelected();
    if (atoms && atoms.length) {
        return this.getAtomsBBox(atoms);
    }
};

Autodesk.Viewing.MolViewer.MolInstance.prototype.getAtomsCenter = function getAtomsCenter(atoms) {
    var pos;
    var i;
    var total;
    var atomID;
    var positions = this.molModel.positions;
    var loc;
    var pt = this.molMan.cachedVector;
    var count = 0;
    if (atoms && atoms.length) {
        total = {x: 0, y: 0, z: 0};
        if(this.isForAssembly()) { //duplicate code to get rid of if statment in for lloop
            for (i = 0; i < atoms.length; ++i) {
                atomID = atoms[i];
                if (this.atomRepState.isVisible(atomID)) {
                    ++count;
                    loc = atomID * 3;
                    pt.x = positions[loc];
                    pt.y = positions[loc + 1];
                    pt.z = positions[loc + 2];
                    pt.applyMatrix4(this.transform);

                    total.x += pt.x;
                    total.y += pt.y;
                    total.z += pt.z;
                }
            }

        }else{
            var lastEntityID = 'blah';
            var entityID;
            for (i = 0; i < atoms.length; ++i) {
                atomID = atoms[i];
                if (this.atomRepState.isVisible(atomID)) {
                    entityID = this.molMetadata.entityAtoms[atomID];
                    if(lastEntityID !== entityID) {
                        this.molMan.cachedTransform.copy(this.origTransform);
                        if (this.entityExplodeOffsets && this.entityExplodeOffsets[entityID]) {
                            this.molMan.cachedTransform.elements[12] += this.entityExplodeOffsets[entityID].x;
                            this.molMan.cachedTransform.elements[13] += this.entityExplodeOffsets[entityID].y;
                            this.molMan.cachedTransform.elements[14] += this.entityExplodeOffsets[entityID].z;
                        }
                    }
                    ++count;
                    loc = atomID * 3;
                    pt.x = positions[loc];
                    pt.y = positions[loc + 1];
                    pt.z = positions[loc + 2];
                    pt.applyMatrix4(this.molMan.cachedTransform);

                    total.x += pt.x;
                    total.y += pt.y;
                    total.z += pt.z;
                }
            }
        }
    }

    if(count > 0) {
        var invlength = 1.0 / count;
        total.x *= invlength;
        total.y *= invlength;
        total.z *= invlength;
    }
    return total;
};


Autodesk.Viewing.MolViewer.MolInstance.prototype.getAtomsBBox = function getAtomsBBox(atoms) {
    var pos;
    var i;
    var atomID;
    var positions = this.molModel.positions;
    var loc;
    var pt = this.molMan.cachedVector;
    var bbox = this.molMan.cachedBBox;
    bbox.makeEmpty();


    if (atoms && atoms.length) {
        if(this.isForAssembly()) { //duplicate code to get rid of if statment in for lloop
            for (i = 0; i < atoms.length; ++i) {
                atomID = atoms[i];
                if (this.atomRepState.isVisible(atomID)) {
                    loc = atomID * 3;
                    pt.x = positions[loc];
                    pt.y = positions[loc + 1];
                    pt.z = positions[loc + 2];
                    pt.applyMatrix4(this.transform);
                    if(i >0) {
                        bbox.expandByPoint(pt);
                    }else{
                        bbox.min.x = bbox.max.x = pt.x;
                        bbox.min.y = bbox.max.y = pt.y;
                        bbox.min.z = bbox.max.z = pt.z;

                    }

                }
            }

        }else{
            var lastEntityID = 'blah';
            var entityID;
            for (i = 0; i < atoms.length; ++i) {
                atomID = atoms[i];
                if (this.atomRepState.isVisible(atomID)) {
                    entityID = this.molMetadata.entityAtoms[atomID];
                    if(lastEntityID !== entityID){
                        this.molMan.cachedTransform.copy(this.origTransform);
                        if(this.entityExplodeOffsets && this.entityExplodeOffsets[entityID]) {
                            this.molMan.cachedTransform.elements[12] += this.entityExplodeOffsets[entityID].x;
                            this.molMan.cachedTransform.elements[13] += this.entityExplodeOffsets[entityID].y;
                            this.molMan.cachedTransform.elements[14] += this.entityExplodeOffsets[entityID].z;
                        }
                    }
                    loc = atomID * 3;
                    pt.x = positions[loc];
                    pt.y = positions[loc + 1];
                    pt.z = positions[loc + 2];
                    pt.applyMatrix4(this.molMan.cachedTransform);
                    if(i >0) {
                        bbox.expandByPoint(pt);
                    }else{
                        bbox.min.x = bbox.max.x = pt.x;
                        bbox.min.y = bbox.max.y = pt.y;
                        bbox.min.z = bbox.max.z = pt.z;

                    }
                }
            }
        }
    }
    //slightly expand to avoid errors
    bbox.min.x -=0.5;    bbox.min.y -=0.5;    bbox.min.z -=0.5;
    bbox.max.x +=0.5;    bbox.max.y +=0.5;    bbox.max.z +=0.5;


    return bbox;
};

;

Autodesk.Nano = Autodesk.Nano || {};
Autodesk.Nano.MolViewer = Autodesk.Nano.MolViewer || {};


Autodesk.Nano.MolViewer.MolModel = function(id,options) {
    this.viewer = options.viewer;
    this.molMan = options.molMan;
    this.apiConnector = options.apiConnector;
    this.viewManager = options.viewManager;
    this.loader = options.loader;
    this.socketID = THREE.Math.generateUUID();
    this.molMetadata = null;
    this.atomMetadata = null;
    this.header = null;
    this.positions = null;
    this.entities = null;
    this.chains = null;
    this.assemblies = null;
    this.residues = null;
    this.activeAssembly = null;
    this.palettes = { entity: {}, chain: {}, residue: {}, secondary: {}, bfactor: {}, index:{}, atom: {} };
    this.customColors = { //really shouldn't be here MZ TODO
        ribbon: [null, '#2FE695', '#F3FF86', '#FF8C35', '#FF4674', '#5981FF', '#FFFFFF', '#7F818B', '#2C334B',
            '#4DB184', '#9CA15D', '#B1774D', '#7F4CB2', '#B24CB2', '#B24C7F', '#4CB2B2', '#7FB24C'],
        stick: [null, '#2FE695', '#F3FF86', '#FF8C35', '#FF4674', '#5981FF', '#FFFFFF', '#7F818B', '#2C334B',
            '#4DB184', '#9CA15D', '#B1774D', '#7F4CB2', '#B24CB2', '#B24C7F', '#4CB2B2', '#7FB24C'],
        surface: [null, '#2FE695', '#F3FF86', '#FF8C35', '#FF4674', '#5981FF', '#FFFFFF', '#7F818B', '#2C334B',
            '#4DB184', '#9CA15D', '#B1774D', '#7F4CB2', '#B24CB2', '#B24C7F', '#4CB2B2', '#7FB24C'],
        CPK: [null, '#2FE695', '#F3FF86', '#FF8C35', '#FF4674', '#5981FF', '#FFFFFF', '#7F818B', '#2C334B',
            '#4DB184', '#9CA15D', '#B1774D', '#7F4CB2', '#B24CB2', '#B24C7F', '#4CB2B2', '#7FB24C']
    };
    this.offset = new THREE.Vector3();
    this.offset.x = 0;
    this.offset.y = 0;
    this.offset.z = 0;
    this.activeInstances = [];
    this.assembly = null;
    this._explodeScale = 0.0;
    this.bbox = new THREE.Box3();
    this.hostProtocol = this.loader.options.config3d.hostProtocol;
    //loading data, may want to move out to different object later.
    this.url = options.url;   //may be null if loading a pdb but will get set later during load.
    this.md5 = options.md5;   //may be null if loading a pdb but will get set later during load.
    this.pdbID = options.pdbID; //may be null if custom

    Autodesk.Nano.Instance.call(this, 'mol',id); //do we need a model class or model is a subclass of instance?


    this.saveSessionBind = this.saveSession.bind(this);

    //Instances based upon the various entities/assamblies
    this.instance = null; //default isntance for
    this.assemblyEntityInstances  = {}; //based on ENTITY ID, not assemblyinstance for each assembly, currently built on demand
    this.molMan.addMolModel(this);
};

Autodesk.Nano.MolViewer.MolModel.prototype = Object.create(Autodesk.Nano.Instance.prototype);
Autodesk.Nano.MolViewer.MolModel.prototype.constructor = Autodesk.Nano.MolViewer.MolModel;


Autodesk.Nano.MolViewer.MolModel.prototype.dtor = function dtor() {

    //TheMolMan.deleteInstances(this,true);
    if(this._connection) {
        this._connection.close();
    }
    delete this._connection;

    delete this.saveSessionBind;
    var event = {
        type: Autodesk.Nano.MODEL_DELETED_EVENT,
        id: this.getID()
    };
    delete this.activeInstances;
    delete this.instance;
    this.viewer.fireEvent(event);
};




Autodesk.Nano.MolViewer.MolModel.prototype.saveSession = function saveSession(event) {

    this.viewer.removeEventListener(Autodesk.Nano.SESSION_SAVED_EVENT,this.saveSessionBind);
    this.molMan.saveSessionCookie(event.id);
};


Autodesk.Nano.MolViewer.MolModel.prototype.getGlobalOffset = function getGlobalOffset(){
    return this.offset;
};

Autodesk.Nano.MolViewer.MolModel.prototype.getJSON = function getJSON(url,title) {
    var self = this;
    var what = title;
    return new Promise(function(resolve, reject) {
        var request = new XMLHttpRequest();
        var full;
        var callID = THREE.Math.generateUUID();
        if(url[url.length-1] !== '/') {
            full = url + '/' + title
        }else{
            full = url + title;
        }
        request.open('GET',full);
        request.setRequestHeader("Connection-ID", self.loader.getConnectionID());
        request.setRequestHeader("Socket-ID", callID);
        request.setRequestHeader("Stack-Trace", 'MolModel.getJSON');
        request.onload = function() {
            if (request.status == 200) {
                var dude = { response: request.response, title: what};
                resolve(dude); // we get the data here, so resolve the Promise
            } else {
                reject(new Error(request.statusText)); // if status is not 200 OK, reject.
            }
        };

        request.onerror = function() {
            reject(Error("Error fetching data.")); // error occurred, so reject the Promise
        };

        request.send(); // send the request
    });
};



//need to call this on each new load
Autodesk.Nano.MolViewer.MolModel.prototype.nextSocketID = function nextSocketID() {
    this.socketID = THREE.Math.generateUUID();
};

Autodesk.Nano.MolViewer.MolModel.prototype.readySocket = function readySocket(md5){
    var port = '',
        protocol,
        newURL,
        pdbID = md5 + '.' + this.socketID,
        that = this;

    this._loadingMD5 = md5;

    //localhost or ip address hostname needs port #
    if (window.location.hostname === 'localhost' || window.location.hostname.match(/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/)) {
        port = ':8000';
    }
    //match protocols http => ws, https => wss
    protocol = (location.protocol === 'https:' ? 'wss:' : 'ws:');


    newURL  = protocol + "//" + window.location.hostname + port + '/';
    newURL +=  pdbID;

    this._readyToLoad = {'surface':false,'ribbon': false, 'stick':false};
    this._connection = new WebSocket(newURL, ['soap', 'xmpp']);
    this._connection.onopen = function (e) {
        console.log('WebSocket connected ' + e);

    };

// Log errors
    this._connection.onerror = function (error) {
        console.log('WebSocket Error ' + error);
    };

// Log messages from the server
    this._connection.onmessage = function (e) {
        var dataObj = JSON.parse(e.data);
        // !dataObj.data is the signature of the md5 bug
        if (!dataObj.data) {
            console.log('**** no data object was returned!');
            return;
        }
        var data = dataObj.data; //uglify does not like data = data.data -- handles it incorrectly!!
        if(data.md5.toString() === that._loadingMD5.toString()) { //need to make sure that we are getting the right one (always should bu make sure)
            console.log('loading' + data.type + ' socket load');
            var url = (that.hostProtocol !== '' ? that.hostProtocol + '/' : '') + data.outputsBaseUrl + 'molecule/' + data.type + '/' + 'molecule.svf';
            if(that.loadingRep ==='none') {
                that.loadSVFURL(url, data.type, data.status === 'success');
            }else{
                var rep  = {rep:data.type, url: url};
                that.repsToLoad.push(rep);
            }

        }else{
            console.log('got wrong md5 for ' + data.type + ' socket load');
        }

    };

    this._connection.onclose = function(){
        delete that._connection;
        delete that._readyToLoad;
    };

};
/**
 * Need to cache for each entity the atoms it belonds too
*/
Autodesk.Nano.MolViewer.MolModel.prototype.setAtomsForEntities = function setAtomsForEntities(){
    var entity, id;
    for(id in this.entities){
        entity = this.entities[id];
        entity.atomIDs = [];
        for(var i =0; i < entity.chainIDs.length;++i ){
            var chain = this.chains[entity.chainIDs[i]];
            for(var residueID in chain.residues){
                var residue = chain.residues[residueID];
                for(var j = 0; j< residue.atoms.length;++j){
                    entity.atomIDs.push(residue.atoms[j].id);
                }
            }
        }
    }

};

Autodesk.Nano.MolViewer.MolModel.prototype.loadMetadata = function loadMetadata(url,md5) {
    var that = this;
    var headless = that.viewer.options.headless ? true : false;
    if(1){

        function loadCIFFile(cif) {
            // [0] accesses the DOM element from the jQuery result
            if (!headless) {
                that.viewManager.getTopView('StatusView').showCustomMessage('Parsing CIF');
            }

            var p = new Autodesk.Nano.Parser();
            var obj = p.readCIFFile( cif);
            for(var id in obj){
                that[id] = obj[id];
            }
            if (!headless) {
                that.viewManager.getTopView('StatusView').showCustomMessage('Setting Up Metadata');
            }
            that.setUpAfterMetadataLoaded();
            that.setAtomsForEntities();

            that.viewer.fireEvent({type: Autodesk.Nano.MODEL_END_LOADED_EVENT,model: that,modelType: 'mol'});
            that.viewer.fireEvent({type: Autodesk.Nano.MODEL_ADDED_EVENT,model: that});


            that.viewer.addEventListener(Autodesk.Nano.SESSION_SAVED_EVENT,that.saveSessionBind);
            that.molMan.saveSession(); //save after we load

            if (!headless) {
                that.viewManager.getTopView('StatusView').showCustomMessage('Building 3D View');
                that.viewManager.getTopView('StatusView').hide();
            }
            /*
            var atomScaledBFactors = []; //where to do this , here for now just a hack
            for(var i = 0;i < atoms.length;++i){
                var locAtoms = atoms[i];
                var min = obj.data[0].minBFactor;
                var max = obj.data[0].maxBFactor;
                var diff = 1.0/(max - min);
                var val;
                var bFactors = [];
                for(var j =0;j < locAtoms.length;++j){
                    val = (locAtoms[j].bfactor - min) * diff;
                    bFactors.push(val);
                }
                var typed  = new Float32Array( bFactors );
                atomScaledBFactors.push(typed);

            }
            var spheres = new Spheres(scene,atoms,atomScaledBFactors,stickRadius);
            var material = spheres.material;
            materials.push(material);
            var cylinders = new Cylinders(scene,bonds,atomScaledBFactors,stickRadius);
            material = cylinders.material;
            materials.push(material);
            console.log(atoms);
            */
        }
        if (!headless) {
            that.viewManager.getTopView('StatusView').showCustomMessage('Downloading CIF');
        }

        var pdbId = this.getID();
        pdbId = pdbId.toUpperCase();
        var url = 'http://www.rcsb.org/pdb/files/' + pdbId + '.cif';
        //url = 'models/1crn.cif';
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onload = function (e) {
            if (this.status == 200) {
                console.log(e);
                loadCIFFile(this.responseText);

            } else {
                console.log(e);
            }
        };
        xhr.send();
        return;
    }else {
        if (!headless) {
            that.viewManager.getTopView('StatusView').showTranslating();
        }


        var pdb = this.getID();

        var promise;
        var loadedMD5 = true;
        if (md5) {
            promise = that.apiConnector.getCifMD5(md5, this.socketID);
        } else {
            loadedMD5 = false;
            promise = that.apiConnector.getPdbUrl(pdb, this.socketID);
        }
        promise
            .then(function (data) {
                data.url = (that.hostProtocol !== '' ? that.hostProtocol + '/' + data.url : data.url);
                that.url = data.url;
                that.md5 = data.md5;
                that.apiConnector.loadMetadata(that, data.url, data.md5);
            })
            .catch(function (err) {
                console.log('Error getting PDB URL: ', err);
                if (loadedMD5) {
                    that.setID('1C7D'); //set it do default
                    that.loadMetadata(null, null); //force another load
                } else {
                    if (!headless) {
                        that.viewManager.getTopView('StatusView').showError();
                    }
                    that.viewer.fireEvent({type: Autodesk.Nano.MODEL_LOAD_ERROR_EVENT, molModel: that});
                }

            });

    }
};



Autodesk.Nano.MolViewer.MolModel.prototype.setUpAfterMetadataLoaded =  function setUpAfterMetadataLoaded() {

    this.molMetadata = new Autodesk.Viewing.MolViewer.MetaData(this);
    this.uniqueChains = this.molMetadata.getUniqueItems(this.molMetadata.chains);
    //BAD! window.MetaData = this.molMetadata; //global MetaData object ref

    var entity;
    //this is the default instance (no assembly) for the renderModel.
    //need to push all non-assembly IDs to it until we do one entity per instance.
    var entityIDs =[];
    for(entity in this.entities) {
        if(!this.entities[entity].isForAssembly) {
            entityIDs.push(entity);
        }
    }

    this.instance = new Autodesk.Viewing.MolViewer.MolInstance(this,this.molMan,entityIDs);

    for (entity in this.entities) {
        if (this.entities[entity].isForAssembly) {
            this.entities[entity].isVisible = false;
        } else {
            var b = this.getBox3FromMinMax(this.entities[entity]);
            this.bbox.union(b);
            this.entities[entity].isVisible = true;
        }
    }
    this.instance.bbox.copy(this.bbox);
    this.createPalettes();
    this.molMan.addInstance(this.instance);
    this.instance.setDefaultReps();
    this.instance.molReps.colorBy('surface', 'chain');
    this.instance.molReps.colorBy('stick', 'atom');
    this.instance.molReps.colorBy('CPK','atom');
    this.instance.molReps.colorBy('ribbon', 'residue');
    //mz need to move this..
    //this.viewer.utilities.fitToView();
    this.viewer.fireEvent({type: Autodesk.Nano.METADATA_LOADED_EVENT,model: this,modelType: 'mol'});

};
Autodesk.Nano.MolViewer.MolModel.prototype.getActiveAssembly = function getActiveAssembly() {
    return this.activeAssembly;
};


Autodesk.Nano.MolViewer.MolModel.prototype.createInstance = function createInstance(entityID){
    var entityIDs =[];
    entityIDs.push(entityID);
    var instance = new Autodesk.Viewing.MolViewer.MolInstance(this,this.molMan,entityIDs);
    var entity = this.entities[entityID];
    var b = this.getBox3FromMinMax(entity);
    instance.bbox = b;
    instance.center = b.center();


    return instance;
};

Autodesk.Nano.MolViewer.MolModel.prototype.getAssemblyInstance = function getAssemblyInstance(assemblyID){
    var assembly = this.assemblies[assemblyID];
    var entityID = assembly.entityID;
    if(!this.assemblyEntityInstances[entityID]){
        this.assemblyEntityInstances[entityID] = this.createInstance(entityID);

    }
    return this.assemblyEntityInstances[entityID];
};

//don't delete assembly instances or this.instance since they contain cached 3dview data
//(we could fix that and move cache externall, would be better...)
Autodesk.Nano.MolViewer.MolModel.prototype.deleteIfNotForced= function deleteIfNotForced(instance){

    if( instance === this.instance){
        this.instance._turnOffVisibility();
       return false;
    }else{
        for (var id  in this.assemblyEntityInstances){
            if(this.assemblyEntityInstances[id] === instance){
                this.assemblyEntityInstances[id]._turnOffVisibility();
                return false;
            }
        }
    }
    
    return true;
};

Autodesk.Nano.MolViewer.MolModel.prototype.switchToAssembly = function switchToAssembly(assemblyID) {

    if(assemblyID && !this.assemblies[assemblyID]){
        console.log("That Assembly doesn't exists");
        return;
    }
    if( (!assemblyID && !this.activeAssembly) || (this.activeAssembly === this.assemblies[assemblyID])){
        return; //same assembly just exit
    }

    this.bbox.makeEmpty();

    this.molMan.deleteInstances(this);
    this._explodeScale = 0.0;
    var event = {
        type: Autodesk.Viewing.EXPLODE_CHANGE_EVENT,
        molModel: this
    };
    this.viewer.fireEvent(event);

    if(!assemblyID){
        this.molMan.addInstance(this.instance);
        this.instance._setRepsFromState();
        this.instance.fireRepChangedEvent();
        this.bbox.union(this.instance.bbox);
        assemblyID = null; //for use by setActiveAssembly
    }else{
        this.instance._turnOffVisibility();
        var assembly = this.assemblies[assemblyID];
        var instance = this.getAssemblyInstance(assemblyID);
        var newInstance;
        for(var z = 0; z < assembly.transforms.length;++z){

            if(z==0){
                newInstance =instance;
                this.molMan.addInstance(newInstance);
                var viewOptions  = {scaleFactor :0.75};
                if(this.maxNumAtoms > 80000){
                    viewOptions.scaleFactor = 0.5;
                }
                newInstance._createSurfaceView(false,viewOptions);
                newInstance._createRibbonView(false);
                newInstance._createStickView(false);
                newInstance._createCPKView(false);

            }else{

                newInstance = this.createInstance(instance.entityIDs[0]);
                this.molMan.addInstance(newInstance);
                newInstance.createViewsFromInstance(instance);
            }
            newInstance.setViewTransforms(assembly.transforms[z]);
            this.bbox.union(newInstance.bbox);

            newInstance.useTheseRepsAndColors(this.instance.reps,this.instance.atomRepState, this.instance.molReps);
            newInstance._setRepsFromState();
            newInstance.fireRepChangedEvent();
        }
    }
    if(assemblyID) {
        this.activeAssembly = this.assemblies[assemblyID];
    } else {
        this.activeAssembly = null;
    }
    this.molMan.bboxIsDirty = true;

    this.explode(0.0);
    this.viewer.impl.selector.setSelection([]);
    this.viewer.utilities.fitToView();
    this.viewer.fireEvent({type:Autodesk.Viewing.ASSEMBLY_SET_EVENT,id:assemblyID});
};
Autodesk.Nano.MolViewer.MolModel.prototype.getLocalAtomPosition = function getLocalAtomPosition(atomID){
    //var offset = isForAssembly ? this.offset : {x:0,y:0,z:0};
    var offset = this.offset;
    var off  = {x:0,y:0,z:0};// this.renderModel.myData.globalOffset; //for now zero leaving in case it comes back
    var loc = atomID * 3;
    var x = this.positions[loc] - off.x;
    var y = this.positions[loc + 1] - off.y;
    var z = this.positions[loc + 2] - off.z;
    var pt = new THREE.Vector3(x + offset.x,y + offset.y,z + offset.z);
    return pt;
};



//fix the next two!!!!mz
Autodesk.Nano.MolViewer.MolModel.prototype.fragAdded = function fragAdded(fragId){
    /*
     var totalFragments = TheMolMan.viewer.model.myData.fragments.length,
     percent;
     this.fragIds.push(fragId);
     percent = (this.fragIds.length/totalFragments) *100;
     */
    var percent = 50;
    this.viewer.fireEvent({type: Autodesk.Viewing.MOLVIEWER_PROGRESS_EVENT, percent: percent});
};

//todo move out and put in view somewhere..
Autodesk.Nano.MolViewer.MolModel.prototype.createPalettes = function createPalettes() {

    var brewer = new ColorBrewer();
    var quant = brewer.getPalettes(2, false); //quant
    var sequ = brewer.getPalettes(3, true); //sequ
    var diver = brewer.getPalettes(1, false);
    var custom = brewer.getPalettes(4, false);

    var chains;
    var chainAtoms;
    var chainPalette;
    var uniqueResidues = this.molMetadata.getUniqueItems(this.molMetadata.residues, 0);
    var uniquePolymers = [];
    var uniqueNucleics = [];
    var uniqueAminos = [];
    var entities = [];
    var palette;
    var i;
    var j;
    var key;
    var polymerChains = this.molMetadata.getPolymerChains();
    //color object for nucleic acids
    var nucleics = {
        DC: "#bb2222",
        DA: "#2222bb",
        DG: "#22bb22",
        DT: "#bbbb22",
        DU: "#bbbb22",
        C: "#bb2222",
        A: "#2222bb",
        G: "#22bb22",
        T: "#bbbb22",
        U: "#bbbb22"
    };

    for (key in this.entities) {
        if (this.entities.hasOwnProperty(key)) {
            entities.push(key);
        }
    }

    palette = brewer.getColorPalette(custom[1], entities.length);
    for (i = 0; i < palette.length; ++i) {
        this.palettes['entity'][entities[i]] = palette[i];
    }

    palette = brewer.getColorPalette(custom[1], polymerChains.length);
    for (i = 0; i < palette.length; ++i) {
        this.palettes['chain'][polymerChains[i]] = palette[i];
    }


    for (i = 0; i < uniqueResidues.length; i++) {
        if (nucleics[uniqueResidues[i]]) {
            uniqueNucleics.push(uniqueResidues[i]);
        } else {
            uniqueAminos.push(uniqueResidues[i]);
        }
    }

    if (uniqueAminos.length > 0) {  //needed for nucleic-acid only structures
        palette = brewer.getColorPalette(custom[1], uniqueAminos.length);
        for (i = 0; i < palette.length; ++i) {
            this.palettes['residue'][uniqueAminos[i]] = palette[i];
        }
    }


    for (i = 0; i < uniqueNucleics.length; i++) {
        this.palettes['residue'][uniqueNucleics[i]] = nucleics[uniqueNucleics[i]];
    }

    palette = brewer.getColorPalette(diver[7], this.molMetadata.atoms.length);
    for (i = 0; i < palette.length; ++i) {
        this.palettes['bfactor'][i] = palette[i];
    }

    palette = new Array(this.molMetadata.atoms.length);
    chains = this.molMetadata.getUniqueItems(this.molMetadata.chains);
    for (j = 0; j < chains.length; ++j) {
        chainAtoms = this.molMetadata.findAtoms(chains[j], 'chain');
        chainPalette = brewer.getColorPalette(custom[0], chainAtoms.length);
        for (i = 0; i < chainAtoms.length; ++i) {
            palette[chainAtoms[i]] = chainPalette[i];
            this.palettes['index'][chainAtoms[i]] = chainPalette[i];
        }
    }

    this.palettes['secondary']['c'] = '#cccccc';
    this.palettes['secondary']['h'] = '#ff0080';
    this.palettes['secondary']['s'] = '#ffc800';


    this.palettes['atom']['C'] = '#999999';
    this.palettes['atom']['N'] = '#577eff';
    this.palettes['atom']['S'] = '#ffc800';
    this.palettes['atom']['CL'] = '#00de52';
    this.palettes['atom']['O'] = '#eb223d';
    this.palettes['atom']['P'] = '#ff8300';
    this.palettes['atom']['MG'] = '#008030';
    this.palettes['atom']['BR'] = '#443135';
    this.palettes['atom']['ZN'] = '#443135';
    this.palettes['atom']['NA'] = '#354ea0';
    this.palettes['atom']['CA'] = '#4c4c4c';
    this.palettes['atom']['H'] = '#FFFFFF';
    this.createIdMaterial();
    this.viewer.impl.setIDMaterial(this.idMaterialAtom);

};


Autodesk.Nano.MolViewer.MolModel.prototype.createIdMaterial = function  createIdMaterial() {
    this.GetUVs = function(ni) {
        this.numItems = ni;
        var sq = Math.sqrt(this.numItems);
        this.width = Math.ceil(sq);
        this.height = this.width;
        this.step = 1.0/(this.width);
        this.halfStep = this.step * 0.5;
        var bigSize = 3 * this.width * this.height;
        this.data = new Uint8Array(bigSize);
        var val  = 0;
        for ( var i = 0; i < bigSize; i ++ ) {
            this.data[ i  ] 	= val;
        }
        this.setColor= function(itemNum,r,g,b){
            this.data[ 3* itemNum  ] 	= r;
            this.data[ 3* itemNum +1  ] 	= g;
            this.data[ 3* itemNum   + 2] 	= b;

        }
    };

    this.iduvs = new this.GetUVs(this.molMetadata.atoms.length);
    var color, r, g, b;
    for (color =0;color < this.iduvs.numItems;++color){
        b = (color >> 16) & 0xff;
        g = (color >> 8) & 0xff;
        r= color & 0xff;
        //r = 50;
        this.iduvs.setColor(color,r,g,b);
        //this.iduvs.setAlpha(color,0xff);
    }
    var texture = new THREE.DataTexture(this.iduvs.data, this.iduvs.width, this.iduvs.height,
        THREE.RGBFormat,
        THREE.UnsignedByteType,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
        THREE.LinearFilter, THREE.LinearFilter, 0);
    texture.unpackAlignment = 1;
    texture.generateMipmaps = false;
    texture.flipY = false;
    texture.needsUpdate = true;
    this.idTextureAtom = texture;

    this.idMaterialAtom = new THREE.MeshPhongMaterial
    ({
        ambient: 0x0,
        color: 0x0,
        specular: 0x0,
        shininess: 0,
        shading: THREE.NoShading,
        reflectivity: 0,
        map: this.idTextureAtom,
        transparent: false
    });
    this.idMaterialAtom.packedNormals = true;
    this.idMaterialAtom.idAtom = 1;
    this.idMaterialAtom.blending = THREE.NoBlending;
    this.idMaterialAtom.tonemapOutput = false;

    //this.idMaterialAtom.depthWrite = false;
    //this.idMaterialAtom.depthTest = false;
    this.idTextureAtom.needsUpdate = true;
    this.idMaterialAtom.needsUpdate = true;
};


Autodesk.Nano.MolViewer.MolModel.prototype.toJSONObj = function toJSONObj(){
    var inst,obj = {};
    var assembly = this.getActiveAssembly();
    obj.assembly = assembly ? assembly.assemblyID : 'none';
    obj.instances = [];
    obj.explodeScale = this._explodeScale;
    obj.numInstances = this.activeInstances.length;
    obj.customColors = this.customColors;
    for(var i =0; i < this.activeInstances.length;++i){
        inst = this.activeInstances[i].toJSONObj();
        obj.instances.push(inst);
    }
    return obj;
};

Autodesk.Nano.MolViewer.MolModel.prototype.getNumAtoms = function getNumAtoms(){
    return this.molMetadata.atoms.length;
};

Autodesk.Nano.MolViewer.MolModel.prototype.fromJSONObj = function fromJSONObj(obj){
    if (obj.customColors) {
        this.customColors = obj.customColors;
    }
    if(obj.assembly === "none"){
        this.switchToAssembly(null);
    }else{
        this.switchToAssembly(obj.assembly);
    }
    for(var i =0;i<obj.instances.length;++i){
        this.activeInstances[i].fromJSONObj(obj.instances[i]);
    }
    this.explode(obj.explodeScale);
    this.molMan.bboxIsDirty = true;

};


//should be private
Autodesk.Nano.MolViewer.MolModel.prototype.getBox3FromMinMax = function getBox3FromMinMax(what){
    var b = new THREE.Box3();
    b.min.x = what.minX;
    b.min.y = what.minY;
    b.min.z = what.minZ;
    b.max.x = what.maxX;
    b.max.y = what.maxY;
    b.max.z = what.maxZ;
    return b;
}


Autodesk.Nano.MolViewer.MolModel.prototype.getInstanceFromID = function getInstanceFromID(id) {
    var i;
    for (i = 0; i < this.activeInstances.length; i++) {
        if (this.activeInstances[i].id === id) {
            return this.activeInstances[i];
        }
    }
    return false;
};

Autodesk.Nano.MolViewer.MolModel.prototype.getMaterial = function getMaterial(fragId) {
    var instance;
    var rep = this.loadingRep;
    instance = this.getInstance(rep,fragId);
    if(instance){
        return instance.molReps.getMaterial(fragId,rep);
    }
}

Autodesk.Nano.MolViewer.MolModel.prototype.getInstance = function getInstance(rep,fragId){
    var q, instance;
    for (q = 0; q < this.activeInstances.length; q++) {
        instance = this.activeInstances[q];
        if(instance.getRenderModel(rep,fragId)){
            return instance;
        }
    }
    return null;
};


//returns an object containing visible chains, residues per instance and rep
Autodesk.Nano.MolViewer.MolModel.prototype.getVisible = function getVisible() {
    var assembly = this.activeAssembly === null ? '0' : this.activeAssembly.assemblyID;
    var results = {pdbID: this.id, assemblyID: assembly, instances: {}},
        instances = {},
        visible = {},
        i;

    for(i = 0; i < this.activeInstances.length; i++) {
        visible = this.activeInstances[i].getVisible();
        instances[this.activeInstances[i].id] = visible;
    }
    results.instances = instances;
    return results;
};



Autodesk.Nano.MolViewer.MolModel.prototype.addInstance = function addInstance (inst){

    this.activeInstances.push(inst);

};

Autodesk.Nano.MolViewer.MolModel.prototype._deleteInstances = function _deleteInstances () {
    this.activeInstances = [];

};


Autodesk.Nano.MolViewer.MolModel.prototype.fireSelectionChangedEvent = function() {
    var i,
        event,
        instances = [],instance;

    for (i = 0; i < this.activeInstances.length; i++) {
        instance = this.activeInstances[i];
        if(!instance.selection.atoms.isEmpty()){
            this.molMan.selectedInstances[instance.id] = instance;
        }else{
            delete this.molMan.selectedInstances[instance.id];
        }

        instances.push({
            selection: instance.selection,
            instance: instance
        });
    }

    event = {
        type: Autodesk.Viewing.SELECTION_CHANGED_EVENT,
        instances: instances
    };
    this.viewer.fireEvent(event);
};

/**
 * @param instanceArray [] an array containing objects; each of which contains an instance object
 * and an object specifying the selection, made up of a set of key:value pairs
 * valid key types are 'instance','chain','residue', 'residueID','atom','atomID'.  The value will always be an array
 * of valid values.
 * @param keepSelection if true whether or not to add to current selection
 */
Autodesk.Nano.MolViewer.MolModel.prototype.select = function select(instanceArray, keepSelection) {

    try {
        if (!keepSelection) {
            this.molMan.cmdStack.startGroup();
            this.clearSelection(true);
        }
        var options = {};
        options.molModel = this;
        options.instanceArray = instanceArray;
        options.nofire = false;
        var selectCMD = new Autodesk.Nano.MolViewer.SelectionCmd(options);
        this.molMan.cmdStack.runCmd(selectCMD);

        if(!keepSelection){
            this.molMan.cmdStack.endGroup();
        }
    }catch(e){
        console.log('there was a problem with the select call' + e);
    }

};


Autodesk.Nano.MolViewer.MolModel.prototype.clearSelection = function clearSelection(nofire) {
    var selectCMD = new Autodesk.Nano.MolViewer.SelectionCmd({molModel:this, nofire:nofire});
    this.molMan.cmdStack.runCmd(selectCMD);
};

Autodesk.Nano.MolViewer.MolModel.prototype.getExplodeScale = function getExplodeScale() {
    return parseFloat(this._explodeScale);
};

Autodesk.Nano.MolViewer.MolModel.prototype.explode = function explode(scale) {
    if(scale < 0.0){
        scale = 0.0;
    }else if (scale > 1.0){
        scale = 1.0;
    }
    if(scale === this._explodeScale)
        return;
    this.molMan.bboxIsDirty = true;

    this._explodeScale = scale;
    var cx_mc = new THREE.Vector3();
    var realScale,size;
    var explodeScale = 2.0;   // increase this to decrease explode scale
    var mc,instance,cx,b;
    mc = this.bbox.center();
    size = this.bbox.size();

    // calculate the maximum distance from the system to each instance.
    var maxDist = 0.0;
    var q,d;

    for (q = 0; q < this.activeInstances.length; q++) {
        instance = this.activeInstances[q];

        if (instance !== this.instance) { //this case means we are in an assembly so just blow that up
            cx = instance.center;
            cx_mc.subVectors(cx, mc);
            d = cx_mc.length();
            if (d > maxDist)
                maxDist = d;
        } else { //we need to loop through the entities and blow them up instead for that molmodel
            var entityID, entity;
            var newPt = new THREE.Vector3();
            var howMany = 0;
            for (entityID in this.entities) {
                entity = this.entities[entityID];
                if (!entity.isForAssembly) {
                    b = this.getBox3FromMinMax(entity);
                    cx = b.center();
                    newPt.add(cx);
                    howMany++;
                }
            }

            mc.x = newPt.x / howMany;
            mc.y = newPt.y / howMany;
            mc.z = newPt.z / howMany;

            for (entityID in this.entities) {
                entity = this.entities[entityID];
                if (!entity.isForAssembly) {
                    b = this.getBox3FromMinMax(entity);
                    cx = b.center();
                    cx_mc.subVectors(cx, mc);
                    d = cx_mc.length();
                    if ( d > maxDist) maxDist = d;
                }
            }
        }
    }

    // calculate scaling factor for translating instances.
    if (maxDist == 0.0) {
        realScale = 1.0;
    } else {
        var maxSize = size.x > size.y ? size.x : size.y;
        maxSize = size.z > maxSize ? size.z : maxSize;
        realScale = (scale * maxSize) / (explodeScale * maxDist);
    }
    var pt = new THREE.Vector3();
    // translate each instance.
    for (q = 0; q < this.activeInstances.length; q++) {
        instance = this.activeInstances[q];


        if(instance !== instance.molModel.instance) { //this case means we are in an assembly so just blow that up
            cx = instance.center;
            pt.subVectors(cx, mc);
            pt.multiplyScalar(realScale);
            instance.setExplodeOffset(pt);

        }
        else{ //we need to loop through the entities and blow them up instead for that molmodel
            var entityID, entity;
            var newPt = new THREE.Vector3();
            var howMany = 0;
            for(entityID in this.entities) {
                entity = this.entities[entityID];
                if (!entity.isForAssembly) {
                    b = this.getBox3FromMinMax(entity);
                    cx = b.center();
                    newPt.add(cx);
                    howMany++;
                }
            }

            if (instance.entityExplodeOffsets == null) {
                instance.entityExplodeOffsets = [];
                for (entityID in this.entities) {
                    instance.entityExplodeOffsets[entityID] = new THREE.Vector3();
                }
            }

            mc.x  = newPt.x/howMany;
            mc.y  = newPt.y/howMany;
            mc.z  = newPt.z/howMany;

            for(entityID in this.entities){
                entity = this.entities[entityID];
                if(!entity.isForAssembly){
                    b = this.getBox3FromMinMax(entity);
                    cx = b.center();
                    pt.subVectors(cx, mc);
                    pt.multiplyScalar(realScale);

                    instance.setEntityExplodeOffset(entityID,pt);
                }
            }
        }
    }
    this.viewer.impl.sceneUpdated(true);
    var event = {
        type: Autodesk.Viewing.EXPLODE_CHANGE_EVENT,
        molModel: this
    };
    this.viewer.fireEvent(event);
};

Autodesk.Nano.MolViewer.MolModel.prototype.getAtomIDArray = function getAtomIDArray(){
    var i,length = this.atomMetadata.length;
    var atomIDs = new Array(length);
    for(i =0;i < length;++i){
        atomIDs[i] = i;
    }
    return atomIDs;
};
;// set up namespace...
Autodesk.Viewing.MolViewer = Autodesk.Viewing.MolViewer || {};

Autodesk.Viewing.COLOR_CHANGED_EVENT = Autodesk.Viewing.COLOR_CHANGED_EVENT || 'colorChanged';
Autodesk.Viewing.VISIBILITY_CHANGED_EVENT = Autodesk.Viewing.VISIBILITY_CHANGED_EVENT || 'visibilityChanged';

/**
 * constructor for MolReps object
 * Contains information for each map for each representation, plus the idbuffer.
 * @param {object} viewer - the 3DViewer object.
 */
Autodesk.Viewing.MolViewer.MolReps = function(molModel,instance,viewer) {

    this.id = THREE.Math.generateUUID();
    this.molModel = molModel;
    this.instance = instance;
    this.viewer = viewer;
    var numAtoms = this.molModel.molMetadata.atoms.length;
    this.colorBits = {surface: new BitSet(numAtoms * 4,0), ribbon: new BitSet(numAtoms *4,0),
     stick: new BitSet(numAtoms *4,0),CPK: new BitSet(numAtoms *4,0)};
    //chain = 0, residue = 1, secondary = 2,  bfactor = 3, index = 4, atom = 5, entity  = 6, hydrophobicity = 7, custom = 8, so need 4 bits per color
    this.customColorBits = {
        surface: new BitSet(numAtoms * 5, 0), ribbon: new BitSet(numAtoms * 5, 0),
        stick: new BitSet(numAtoms * 5, 0),
        CPK: new BitSet(numAtoms * 5,0)};
    this.customColorArrays = this.molModel.customColors;
    this.reps = { surface: {opacity:1.0}, CPK: {opacity:1.0},
        stick: {opacity:1.0}, ribbon:{opacity: 1.0}};

}; // end constructor
Autodesk.Viewing.MolViewer.MolReps.prototype.dtor = function dtor(){
    delete this.molModel;
    delete this.instance;
    delete this.reps;

};

Autodesk.Viewing.MolViewer.MolReps.prototype.dtor = function dtor(){
    delete this.molModel;
};
Autodesk.Viewing.MolViewer.MolReps.prototype.toJSONObj = function toJSONObj(){
    var obj = {};
    var list,encoded;
    var type;
    var types;
    var colorTypes;
    var bitType;
    var something,rep;
    obj.reps = {};
    obj.customColorReps = {};
    for(rep in this.colorBits){
        types = this.getBitSetPerType(rep);
        bitType = {};
        something = false;
        for(type in types) {
            something = true;
            list = types[type].toArray();
            encoded = RLE.encode(list);
            bitType[type] = encoded;
        }
        if(something) {
            obj.reps[rep] = bitType;
        }
    }

    //custom color bits
    for (rep in this.customColorBits){
        list = this.customColorBits[rep].toArray();
        encoded = RLE.encode(list);
        obj.customColorReps[rep] = encoded;
    }

    //get opacities per atom
    obj.o = {};
    for(rep in this.reps){
        if(rep ==='surface') {
            list = this.getOpacities(rep);
            encoded = RLE.encode(list);
            obj.o[rep] = encoded;
        }
    }

    return obj;
};

Autodesk.Viewing.MolViewer.MolReps.prototype.fromJSONObj = function fromJSONObj(obj){
    var decoded,
        decArray,
        decItem,
        bitSet,
        rep,
        type,
        len,
        bin,
        opacities = [],
        i;

    //we call this when a saved session as 4 custom color bits instead of 5
    var updateCustomColorBits = function (fourBit) {
        var fiveBit = [];
        var i = fourBit.length;
        for (i = 0; i < fourBit.length; ++i) {
            fiveBit.push(0);
            fiveBit.push(fourBit[i]);
            fiveBit.push(fourBit[i + 1]);
            fiveBit.push(fourBit[i + 2]);
            fiveBit.push(fourBit[i + 3]);
            i = i + 3;
        }
        return fiveBit;
    };

    //custom color bitsets
    for (rep in obj.customColorReps){
        decArray = [];
        for (decItem in obj.customColorReps[rep]){
            decArray.push(obj.customColorReps[rep][decItem]);
        }
        decoded = RLE.decode(decArray);
        if (decoded.length === this.molModel.molMetadata.atoms.length * 4) {
            decoded = updateCustomColorBits(decoded);
        }
        bitSet = new BitSet(this.molModel.molMetadata.atoms.length * 5);
        bitSet.fromArray(decoded);
        this.customColorBits[rep] = bitSet;
    }

    for(rep in obj.reps){
        for(type in obj.reps[rep]) {
            decArray = [];
            for(decItem in obj.reps[rep][type]){
                decArray.push(obj.reps[rep][type][decItem]);
            }
            decoded = RLE.decode(decArray);
            bitSet = new BitSet(this.molModel.molMetadata.atoms.length);
            bitSet.fromArray(decoded);
            this.colorBy(rep, type, bitSet);
        }
    }

    for(rep in obj.o){
        if(rep === 'surface') {
            decArray = [];
            for (decItem in obj.o[rep]) {
                decArray.push(obj.o[rep][decItem]);
            }
            decoded = RLE.decode(decArray);
            bitSet = new BitSet(decoded.length,0);
            bitSet.fromArray(decoded);
            len = decoded.length/8;
            for (i = 0; i < len; ++i) {
                bin = bitSet.get(i * 8) + '' + bitSet.get((i*8) + 1) + '';
                bin += bitSet.get((i*8) + 2) + '' + bitSet.get((i*8) + 3) + '';
                bin += bitSet.get((i*8) + 4) + '' + bitSet.get((i*8) + 5) + '';
                bin += bitSet.get((i*8) + 6) + '' + bitSet.get((i*8) + 7) + '';
                opacities.push(parseInt(bin,2));
            }
            this.setOpacities(rep, opacities);
        }
    }
};



Autodesk.Viewing.MolViewer.MolReps.prototype.createFrom = function createFrom(molReps){
    for(var rep in this.colorBits){
        this.colorBits[rep] = molReps.colorBits[rep].clone();
        this.reps[rep].opacity = molReps.reps[rep].opacity;
        this.reps[rep].getUVColor.data.set(molReps.reps[rep].getUVColor.data);
        this.reps[rep].colorTextureAtom.needsUpdate = true;
        this.reps[rep].colorMaterialAtom.needsUpdate = true;

        if(this.reps[rep].alphaTextureAtom) {
            this.reps[rep].getUVAlpha.data.set(molReps.reps[rep].getUVAlpha.data);
            this.reps[rep].alphaTextureAtom.needsUpdate = true;
        }
        if(this.reps[rep].alphaMaterialAtom) {
            this.reps[rep].alphaMaterialAtom.needsUpdate = true;
        }
    };
};

Autodesk.Viewing.MolViewer.MolReps.prototype.setCustomColorBit = function setCustomColorBit(rep, atomNum, colorIndex) {
    var binString,
        startBit = atomNum * 5,
        i;

    var dec2Bin = function dec2Bin(n,len){
        var output,
            pad = '00000000';
        if(!/^[0-9]{1,64}$/.test(n)||n<0) {
            return 0;
        }
        output = n.toString(2);
        output = pad.substring(0,len - output.length) + output;
        return output;
    };

    if(this.customColorBits) {
        binString = dec2Bin(colorIndex, 5);
        if (binString.length === 5) {
            for (i = 0; i < binString.length; ++i) {
                this.customColorBits[rep].set(startBit + i, binString.substr(i,1));
            }
        }
    }

};

//chain = 0, residue = 1, secondary = 2,  bfactor = 3, index = 4, atom = 5, enity = 6, hydrophobicity = 7, custom = 8, so need 4 bits per color
Autodesk.Viewing.MolViewer.MolReps.prototype.setColorBit = function setColorBit(rep, atomNum, type){
    if(this.colorBits[rep]){
        var startBit = atomNum * 4;
        if(type === 'chain'){
            this.colorBits[rep].set(startBit,0);
            this.colorBits[rep].set(startBit+1,0);
            this.colorBits[rep].set(startBit+2,0);
            this.colorBits[rep].set(startBit+3,0);
        }else if (type == 'residue'){
            this.colorBits[rep].set(startBit,1);
            this.colorBits[rep].set(startBit+1,0);
            this.colorBits[rep].set(startBit+2,0);
            this.colorBits[rep].set(startBit+3,0);
        }else if (type == 'secondary'){
            this.colorBits[rep].set(startBit,0);
            this.colorBits[rep].set(startBit+1,1);
            this.colorBits[rep].set(startBit+2,0);
            this.colorBits[rep].set(startBit+3,0);
        }else if (type == 'bfactor'){
            this.colorBits[rep].set(startBit,1);
            this.colorBits[rep].set(startBit+1,1);
            this.colorBits[rep].set(startBit+2,0);
            this.colorBits[rep].set(startBit+3,0);
        }else if (type == 'index'){
            this.colorBits[rep].set(startBit,0);
            this.colorBits[rep].set(startBit+1,0);
            this.colorBits[rep].set(startBit+2,1);
            this.colorBits[rep].set(startBit+3,0);
        }else if (type == 'atom'){
            this.colorBits[rep].set(startBit,1);
            this.colorBits[rep].set(startBit+1,0);
            this.colorBits[rep].set(startBit+2,1);
            this.colorBits[rep].set(startBit+3,0);
        }else if (type == 'entity'){
            this.colorBits[rep].set(startBit,0);
            this.colorBits[rep].set(startBit+1,1);
            this.colorBits[rep].set(startBit+2,1);
            this.colorBits[rep].set(startBit+3,0);
        }else if (type == 'hydrophobicity'){
            this.colorBits[rep].set(startBit,1);
            this.colorBits[rep].set(startBit+1,1);
            this.colorBits[rep].set(startBit+2,1);
            this.colorBits[rep].set(startBit+3,0);
        }else if (type == 'custom'){
            this.colorBits[rep].set(startBit,0);
            this.colorBits[rep].set(startBit+1,0);
            this.colorBits[rep].set(startBit+2,0);
            this.colorBits[rep].set(startBit+3,1);
        }
    }
};

Autodesk.Viewing.MolViewer.MolReps.prototype.getCustomColorBit = function getCustomColorBit(rep, atomNum){
        var colorVal;
    if(this.customColorBits[rep]) {
        colorVal = this.customColorBits[rep].get(atomNum * 5) + '';
        colorVal += this.customColorBits[rep].get((atomNum * 5) + 1) + '';
        colorVal += this.customColorBits[rep].get((atomNum * 5) + 2) + '';
        colorVal += this.customColorBits[rep].get((atomNum * 5) + 3) + '';
        colorVal += this.customColorBits[rep].get((atomNum * 5) + 4) + '';
        return colorVal;
    }
};

Autodesk.Viewing.MolViewer.MolReps.prototype.getColorBit = function getColorBit(rep, atomNum){
    if(this.colorBits[rep]) {
        var startBit = atomNum * 4;
        var bitOne, bitTwo, bitThree, bitFour;
        bitOne = this.colorBits[rep].get(startBit);
        bitTwo = this.colorBits[rep].get(startBit +1);
        bitThree = this.colorBits[rep].get(startBit +2);
        bitFour = this.colorBits[rep].get(startBit +3);

        if(bitOne){
            if(bitTwo){
                if(bitThree){
                    if(bitFour) {
                        return 'none'; //empty for now
                    } else {
                        return 'hydrophobicity';
                    }

                }else{
                    if(bitFour) {
                        return 'none'; //empty for now
                    } else {
                        return 'bfactor';
                    }
                }
            }else{
                if(bitThree){
                    if(bitFour) {
                        return 'none'; //empty for now
                    } else {
                        return 'atom';
                    }
                }else{
                    if(bitFour) {
                        return 'none'; //empty for now
                    } else {
                        return 'residue';
                    }
                }
            }
        }else{
            if(bitTwo){
                if(bitThree){
                    if(bitFour) {
                        return 'none'; //empty for now
                    } else {
                        return 'entity';
                    }
                }else{
                    if(bitFour) {
                        return 'none'; //empty for now
                    } else {
                        return 'secondary';
                    }
                }
            }else{
                if(bitThree){
                    if(bitFour) {
                        return 'none'; //empty for now
                    } else {
                        return 'index';
                    }
                }else{
                    if(bitFour) {
                        return 'custom';
                    } else {
                        return 'chain';
                    }
                }
            }
        }
    }
};
/**
 *
 * @param rep
 * @param atomBitSet
 * @return dictionary object containing the types, e.g. {'chain':'chain', 'index':'index'}
 */
Autodesk.Viewing.MolViewer.MolReps.prototype.getColorTypes = function getColorTypes(rep,  atomBitSet) {
    var length = this.molModel.molMetadata.atoms.length;
    var i;
    var types = {};
    var type;
    for (i = 0; i < length; ++i) {
        if (!atomBitSet || atomBitSet.get(i)) {
            type = this.getColorBit(rep, i);
            types[type] = type;
        }
    }
    return types;
};
/**
 * Get
 * @param rep
 * @param atomBitSet
 * @returns {{}}
 */
Autodesk.Viewing.MolViewer.MolReps.prototype.getBitSetPerType = function getBitSetPerType(rep) {
    var length = this.molModel.molMetadata.atoms.length;
    var i;
    var types = {};
    var type;
    for (i = 0; i < length; ++i) {
        type = this.getColorBit(rep, i);
        if(!types[type]){
            types[type] = new BitSet(length);
        }
        types[type].set(i,1);
    }
    return types;
};




/**
 * @param rep The representation to use, maybe be 'mesh', 'ballAndStick', 'CPK' , or 'ribbon'
 * @param type The type to show the color by. May be 'chain', 'residue', 'atom', 'index', 'bfactor' or 'secondary'
 * @param atomBitSet
 * @param customColorIndex - customColorArray index
 */
Autodesk.Viewing.MolViewer.MolReps.prototype.colorBy = function colorBy(rep, type, atomBitSet,customColorIndex) {

    //if(this.reps[rep] && (this.molModel.palettes[type] || customColorIndex)) {
    if(this.reps[rep] && (this.molModel.palettes[type] || type === 'custom')) {
        var length = this.molModel.molMetadata.atoms.length;
        var palette = this.molModel.palettes[type];
        var data;
        var meta = this.molModel.molMetadata;
        if(type == 'chain'){
            data = meta.chains;
        }else if (type === 'atom'){
            data = meta.atoms;
        }
        var color,i;
        var atomInfo = this.molModel.molMetadata.metaData;  //ssType and bFactor
        var residues = this.molModel.molMetadata.residues; // residue
        var entities = this.molModel.molMetadata.entityAtoms; //entities
        var resName;

        if(data) {
            for (i = 0; i < length; ++i) {
                if (!atomBitSet || atomBitSet.get(i)) {
                    this.setColorBit(rep, i, type);
                    color = palette[data[i]];
                    if (!color) {
                        color = '#404040';
                    }
                    this.reps[rep].getUVColor.setColor(i, parseInt('0x' + color.substr(1, 2)), parseInt('0x' + color.substr(3, 2)), parseInt('0x' + color.substr(5, 2)));
                }
            }
        }else if(type === 'entity') {
            for (i = 0; i < length; ++i) {
                if (!atomBitSet || atomBitSet.get(i)) {
                    this.setColorBit(rep, i, type);
                    resName = entities[i];
                    color = palette[resName];
                    if (!color) {
                        color = '#404040';
                    }
                    this.reps[rep].getUVColor.setColor(i, parseInt('0x' + color.substr(1, 2)), parseInt('0x' + color.substr(3, 2)), parseInt('0x' + color.substr(5, 2)));
                }
            }
        }else if(type === 'residue') {
            for (i = 0; i < length; ++i) {
                if (!atomBitSet || atomBitSet.get(i)) {
                    this.setColorBit(rep, i, type);
                    resName = residues[i];
                    color = palette[resName];
                    if (!color) {
                        color = '#404040';
                    }
                    this.reps[rep].getUVColor.setColor(i, parseInt('0x' + color.substr(1, 2)), parseInt('0x' + color.substr(3, 2)), parseInt('0x' + color.substr(5, 2)));
                }
            }
        }else if(type === 'index') {
            for (i = 0; i < length; ++i) {
                if (!atomBitSet || atomBitSet.get(i)) {
                    this.setColorBit(rep, i, type);
                    color = palette[i];
                    if (!color) {
                        color = '#404040';
                    }
                    this.reps[rep].getUVColor.setColor(i, parseInt('0x' + color.substr(1, 2)), parseInt('0x' + color.substr(3, 2)), parseInt('0x' + color.substr(5, 2)));
                }
            }
        }else if(type === 'secondary') {
            for (i = 0; i < length; ++i) {
                if (!atomBitSet || atomBitSet.get(i)) {
                    this.setColorBit(rep, i, type);
                    color = palette[atomInfo[i].ssType];
                    if (!color) {
                        color = '#404040';
                    }
                    this.reps[rep].getUVColor.setColor(i, parseInt('0x' + color.substr(1, 2)), parseInt('0x' + color.substr(3, 2)), parseInt('0x' + color.substr(5, 2)));
                }
            }
        }else if(type === 'bfactor') {
            var bFactorMin = this.molModel.molMetadata.bFactorMin;
            var bFactorMax = this.molModel.molMetadata.bFactorMax;
            var diff = 1.0/(bFactorMax  - bFactorMin);
            for (i = 0; i < length; ++i) {
                if (!atomBitSet || atomBitSet.get(i)) {

                    this.setColorBit(rep, i, type);
                    var bFactor = atomInfo[i].bFactor;
                    if(bFactor < bFactorMin){
                        bFactor = bFactorMin;
                    }else if(bFactor >= bFactorMax){
                        bFactor = bFactorMax;
                    }
                    var which = Math.floor( (bFactor - bFactorMin)*diff * length);
                    if(which< 0){
                        which = 0;
                    }else if (which >= length){
                        which = length -1;
                    }
                    color = palette[which];
                    if (!color) {
                        color = '#404040';
                    }
                    this.reps[rep].getUVColor.setColor(i, parseInt('0x' + color.substr(1, 2)), parseInt('0x' + color.substr(3, 2)), parseInt('0x' + color.substr(5, 2)));
                }
            }
        } else if (type === 'custom') {
            for (i = 0; i < length; ++i) {
                if (!atomBitSet || atomBitSet.get(i)) {
                    this.setColorBit(rep, i, type);
                    if(customColorIndex) {
                        this.setCustomColorBit(rep, i, customColorIndex);
                        color = this.molModel.customColors[rep][customColorIndex];
                    } else { // we are getting it from json we get it from the customColorBits
                        color = this.molModel.customColors[rep][parseInt(this.getCustomColorBit(rep, i), 2)];
                    }
                    if (!color) {
                        color = '#404040';
                    }
                    this.reps[rep].getUVColor.setColor(i, parseInt('0x' + color.substr(1, 2)), parseInt('0x' + color.substr(3, 2)), parseInt('0x' + color.substr(5, 2)));
                }
            }

        }

        //var customColors = this.getCustomColorIndexFromSelection(rep,atomBitSet);
        this.reps[rep].colorTextureAtom.needsUpdate = true;
        this.reps[rep].colorMaterialAtom.needsUpdate = true;
        var event = {
            type: Autodesk.Viewing.COLOR_CHANGED_EVENT,
            rep: rep,
            colorType: type,
            atomBitSet:atomBitSet
            //customColors: customColors
        };
        this.viewer.fireEvent(event);
    }else{
        console.log('not proper representation or type in colorBy');
    }
};

/**
 *
 * @param rep {string} - name of representation
 * @param atomBitSet {object} - selection bitset (if not passed, will get colors from entire rep)
 */
Autodesk.Viewing.MolViewer.MolReps.prototype.getCustomColorIndexFromSelection = function getCustomColorIndexFromSelection(rep,atomBitSet) {
    if (!this.customColorBits) {
        return;
    }

    var len = this.customColorBits[rep].numAllocated / 5;
    var i;
    var binColor;
    var decColor;
    var colors = {};
    for (i = 0; i <= len; ++i) {
        if (!atomBitSet || atomBitSet.get(i)) {
            binColor = this.customColorBits[rep].get(i * 5) + '';
            binColor += this.customColorBits[rep].get((i * 5) + 1) + '';
            binColor += this.customColorBits[rep].get((i * 5) + 2) + '';
            binColor += this.customColorBits[rep].get((i * 5) + 3) + '';
            binColor += this.customColorBits[rep].get((i * 5) + 4) + '';
            decColor = parseInt(binColor, 2);
            if(decColor > 0) { // is the null (off) color
                colors[decColor] = decColor;
            }

        }
    }
return colors;
};

Autodesk.Viewing.MolViewer.MolReps.prototype.getAtomsWithCustomColorIndex = function getAtomsWithCustomColorIndex(rep, index) {
    var len = this.customColorBits[rep].numAllocated / 5;
    var colorBitSet = new BitSet(len);
    var i;
    var binColor;
    var decColor;
    for (i = 0; i <= len; ++i) {
        binColor = this.customColorBits[rep].get(i * 5) + '';
        binColor += this.customColorBits[rep].get((i * 5) + 1) + '';
        binColor += this.customColorBits[rep].get((i * 5) + 2) + '';
        binColor += this.customColorBits[rep].get((i * 5) + 3) + '';
        binColor += this.customColorBits[rep].get((i * 5) + 4) + '';
        decColor = parseInt(binColor, 2);
        if (decColor === index) { // is matching color index
            colorBitSet.set(i);
        }
    }
    return colorBitSet;
};


Autodesk.Viewing.MolViewer.MolReps.prototype.getMaterial = function getMaterial(fragId,type) {

    var material = this.reps[type].colorMaterialAtom;
    var repModel = this.molModel.repModels[type];

    if (material) // Save in material so we can map back from material to SVF id.
    {
        repModel.matDefs[material.name] = material;
    }


    var alphaMaterial = this.reps[type].alphaMaterialAtom;
    if (alphaMaterial) // Save in material so we can map back from material to SVF id.
    {
        repModel.matDefs[alphaMaterial.name] = alphaMaterial;

    }
    repModel.fragToMaterials[fragId] = material.name;
    //return material;
    return type === 'surface'?  alphaMaterial : material;
};

Autodesk.Viewing.MolViewer.MolReps.prototype.color = function color(rep,atoms,r,g,b) {
    var i;
    for(i =0;i<atoms.length;++i) {
        this.reps[rep].getUVColor.setColor(atoms[i], r, g, b);
    }
    this.reps[rep].colorTextureAtom.needsUpdate = true;
    this.reps[rep].colorMaterialAtom.needsUpdate = true;
};

Autodesk.Viewing.MolViewer.MolReps.prototype.getCustomOpaqueAtoms = function getCustomOpaqueAtoms(rep) {
    var length = this.molModel.molMetadata.atoms.length;
    var oBitSet = new BitSet(length, 0);
    var i;
    var opacity;
    for(i =0;i<length;++i) {
        opacity = this.reps[rep].getUVAlpha.getAlpha(i);
        if(opacity !== 76 && opacity !== 255) { // the two default opacities
            oBitSet.set(i,1);
        }
    }
    return oBitSet; // returns bitset with custom opaque atoms set to 1
};

Autodesk.Viewing.MolViewer.MolReps.prototype.setOpacityFromSelection = function setOpacityFromSelection(rep,opacity,atomBitSet,fromCustom) {
    var length = this.molModel.molMetadata.atoms.length;
    var opaqueBitSet = this.getCustomOpaqueAtoms(rep); //investigate building this when opacity set instead - ajk
    if(opacity < 0.0){
        opacity = 0.0;
    }else if (opacity > 1.0){
        opacity  = 1.0;
    }

    for (var i = 0; i < length; ++i) {
        if (!atomBitSet || atomBitSet.get(i)) {
            if( !opaqueBitSet.get(i)) { // don't set opacity for atoms with custom opacity set by user
                this.reps[rep].getUVAlpha.setAlpha(i, 0xff * opacity);
            } else if (fromCustom) { // okay to set custom opacities if from the custom opacity slider
                this.reps[rep].getUVAlpha.setAlpha(i, 0xff * opacity);
            }
        }
    }
    if(this.reps[rep].alphaTextureAtom) {
        this.reps[rep].alphaTextureAtom.needsUpdate = true;
    }
    if(this.reps[rep].alphaMaterialAtom) {
        this.reps[rep].alphaMaterialAtom.needsUpdate = true;
    }
    this.viewer.impl.invalidate(true);

};


Autodesk.Viewing.MolViewer.MolReps.prototype.getOpacityFromSelection = function getOpacityFromSelection(rep,atomBitSet) {
    var length = this.molModel.molMetadata.atoms.length;
    var tempOpacity;
    var opacity;
    for (var i = 0; i < length; ++i) {
        if (!atomBitSet || atomBitSet.get(i)) {
            tempOpacity = this.reps[rep].getUVAlpha.getAlpha(i);
            if(opacity && tempOpacity !== opacity){
                opacity = 'multiple';
                return opacity;
            }else{
                opacity = tempOpacity;
            }
        }
    }
    return opacity;

};


/**
 *
 * @param rep
 * @param opacities array of valus already set to 0 to 0xff(255)
 */
Autodesk.Viewing.MolViewer.MolReps.prototype.setOpacities = function setOpacities(rep,opacities) {
    for (var i = 0; i < opacities.length; ++i) {
        this.reps[rep].getUVAlpha.setAlpha(i, opacities[i]);
    }
    if(this.reps[rep].alphaTextureAtom) {
        this.reps[rep].alphaTextureAtom.needsUpdate = true;
    }
    if(this.reps[rep].alphaMaterialAtom) {
        this.reps[rep].alphaMaterialAtom.needsUpdate = true;
    }
    this.viewer.impl.invalidate(true);

};
/**
 * get's opacities from 0-255(0xff)
 * @param rep
 */
Autodesk.Viewing.MolViewer.MolReps.prototype.getOpacities = function getOpacities(rep){
    var length = this.molModel.molMetadata.atoms.length;
    var opacities = [];
    var val;
    var tempBitSet = new BitSet(length*8,0); //opacity from 0-255 so 8 bits per atom
    var tempArray;
    var bin;

    var dec2Bin = function dec2Bin(n,len){
        var output,
            pad = '000000000000';
        if(!/^[0-9]{1,64}$/.test(n)||n<0) {
            return 0;
        }
        output = n.toString(2);
        output = pad.substring(0,len - output.length) + output;
        return output;
    };

    for (var i = 0; i < length; ++i) {
        val = this.reps[rep].getUVAlpha.getAlpha(i);
        opacities.push(val);
    }

    for (i = 0; i < length; ++i) {
        bin = dec2Bin(opacities[i],8);
        tempBitSet.set(i*8, bin.substr(0,1));
        tempBitSet.set((i*8)+1, bin.substr(1,1));
        tempBitSet.set((i*8)+2, bin.substr(2,1));
        tempBitSet.set((i*8)+3, bin.substr(3,1));
        tempBitSet.set((i*8)+4, bin.substr(4,1));
        tempBitSet.set((i*8)+5, bin.substr(5,1));
        tempBitSet.set((i*8)+6, bin.substr(6,1));
        tempBitSet.set((i*8)+7, bin.substr(7,1));
    }
    tempArray = tempBitSet.toArray();

    return tempArray;
};
Autodesk.Viewing.MolViewer.MolReps.prototype.removeMaterials = function removeMaterials(viewer){
    for (var key in this.reps) {
        viewer.impl.matman().removeMaterial(this.reps[key].matName );
        if(this.reps[key].alphaMatName){
            viewer.impl.matman().removeMaterial(this.reps[key].alphaMatName );
        }
    }
};

Autodesk.Viewing.MolViewer.MolReps.prototype.setUpMaterials = function setUpMaterials(viewer) {
    //quick check

    if (!this.reps['surface'].colorMaterialAtom) {
        for (var key in this.reps) {

            this.createColorTextureAtom(key,this.molModel.molMetadata.atoms.length);
            this.reps[key].colorMaterialAtom = new THREE.MeshPhongMaterial
            ({
                ambient: 0x030303,
                color: 0x777777,
                specular: 0x111111,
                shininess: 10,
                shading: THREE.SmoothShading,
                reflectivity: 0,
                map: this.reps[key].colorTextureAtom,
                transparent: false
            });

            //this.reps[key].colorMaterialAtom.packedNormals =  true;
            this.reps[key].matName = this.molModel.id + "." + this.id + "." + key;
            this.reps[key].colorMaterialAtom.name = this.reps[key].matName;
            if(!viewer.impl.matman().hasMaterial(this.reps[key].matName)){
                viewer.impl.matman().addMaterial(this.reps[key].matName, this.reps[key].colorMaterialAtom  );
            }
            this.reps[key].colorMaterialAtom.needsUpdate = true;
            if(key === 'surface'){
                this.createAlphaTextureAtom(key,this.molModel.molMetadata.atoms.length);
                this.reps[key].alphaMaterialAtom = new THREE.MeshPhongMaterial
                ({
                    ambient: 0x030303,
                    color: 0x777777,
                    specular: 0x111111,
                    shininess: 10,
                    shading: THREE.SmoothShading,
                    reflectivity: 0,
                    map: this.reps[key].colorTextureAtom,
                    alphaMap:this.reps[key].alphaTextureAtom,
                    alphaTest: 0.05,
                    transparent: true
                });

                //this.reps[key].alphaMaterialAtom.packedNormals =  true;
                this.reps[key].alphaMatName = this.molModel.id + "." + this.id + ".alpha." + key;
                this.reps[key].alphaMaterialAtom.name = this.reps[key].alphaMatName;

                if(!viewer.impl.matman().hasMaterial(this.reps[key].alphaMatName)){
                    viewer.impl.matman().addMaterial(this.reps[key].alphaMatName, this.reps[key].alphaMaterialAtom  );
                }
            }
        }

        //viewer.impl.renderer().toggleTwoSided(true);

        //here we set up the defaults!
        var length = this.molModel.molMetadata.atoms.length;
        for(var i =0;i<length;++i) {
            this.reps['surface'].getUVAlpha.setAlpha(i, 0xff);
            //this.reps['stick'].getUVAlpha.setAlpha(i, 0xff);
            // this.reps['CPK'].getUVAlpha.setAlpha(i, 0xff);
            //this.reps['ribbon'].getUVAlpha.setAlpha(i, 0xff);
        }


    }
};


Autodesk.Viewing.MolViewer.MolReps.prototype.createColorTextureAtom = function createColorTextureAtom(key,length){

    this.reps[key].getUVColor = new Autodesk.Nano.GetUVs(length);

    var texture = new THREE.DataTexture( this.reps[key].getUVColor.data, this.reps[key].getUVColor.width, this.reps[key].getUVColor.height,
        THREE.RGBFormat,
        THREE.UnsignedByteType,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
        THREE.NearestFilter, THREE.NearestFilter, 0);

    texture.unpackAlignment = 1;
    texture.generateMipmaps = false;
    texture.flipY = false;
    texture.needsUpdate = true;
    this.reps[key].colorTextureAtom  = texture;
};

Autodesk.Viewing.MolViewer.MolReps.prototype.createAlphaTextureAtom = function createAlphaTextureAtom(key,length){

    this.reps[key].getUVAlpha = new Autodesk.Nano.GetUVs(length);

    var texture = new THREE.DataTexture( this.reps[key].getUVAlpha.data, this.reps[key].getUVAlpha.width, this.reps[key].getUVAlpha.height,
        THREE.RGBFormat,
        THREE.UnsignedByteType,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
        THREE.NearestFilter, THREE.NearestFilter, 0);

    texture.unpackAlignment = 1;
    texture.generateMipmaps = false;
    texture.flipY = false;
    texture.needsUpdate = true;
    this.reps[key].alphaTextureAtom  = texture;
};

Autodesk.Viewing.MolViewer.MolReps.prototype.setUpVertexColors = function setUpVertexColors(rep,type){

    return;
    var myData= this.molModel.model.myData;
    for(var obj in myData.fragments.mesh2frag){
        var fragId = myData.fragments.mesh2frag[obj];
        var drawObject = this.viewer.impl.modelQueue().getFragmentList(this.molModel.model).getVizmesh(fragId);
        var bufferGeometry = drawObject.geometry;
        var colors = bufferGeometry.attributes.color.array;

    }

};




Autodesk.Nano = Autodesk.Nano || {};
Autodesk.Nano.MolHelper = function () {
    // http://dx.doi.org/10.1021/jp8111556 (or 2.0)//from ngl
    var VdwRadii = {
        "H": 1.1, "HE": 1.4, "LI": 1.81, "BE": 1.53, "B": 1.92, "C": 1.7,
        "N": 1.55, "O": 1.52, "F": 1.47, "NE": 1.54, "NA": 2.27, "MG": 1.73, "AL": 1.84,
        "SI": 2.1, "P": 1.8, "S": 1.8, "CL": 1.75, "AR": 1.88, "K": 2.75, "CA": 2.31,
        "SC": 2.3, "TI": 2.15, "V": 2.05, "CR": 2.05, "MN": 2.05, "FE": 2.05, "CO": 2.0,
        "NI": 2.0, "CU": 2.0, "ZN": 2.1, "GA": 1.87, "GE": 2.11, "AS": 1.85, "SE": 1.9,
        "BR": 1.83, "KR": 2.02, "RB": 3.03, "SR": 2.49, "Y": 2.4, "ZR": 2.3, "NB": 2.15,
        "MO": 2.1, "TC": 2.05, "RU": 2.05, "RH": 2.0, "PD": 2.05, "AG": 2.1, "CD": 2.2,
        "IN": 2.2, "SN": 1.93, "SB": 2.17, "TE": 2.06, "I": 1.98, "XE": 2.16, "CS": 3.43,
        "BA": 2.68, "LA": 2.5, "CE": 2.48, "PR": 2.47, "ND": 2.45, "PM": 2.43, "SM": 2.42,
        "EU": 2.4, "GD": 2.38, "TB": 2.37, "DY": 2.35, "HO": 2.33, "ER": 2.32, "TM": 2.3,
        "YB": 2.28, "LU": 2.27, "HF": 2.25, "TA": 2.2, "W": 2.1, "RE": 2.05, "OS": 2.0,
        "IR": 2.0, "PT": 2.05, "AU": 2.1, "HG": 2.05, "TL": 1.96, "PB": 2.02, "BI": 2.07,
        "PO": 1.97, "AT": 2.02, "RN": 2.2, "FR": 3.48, "RA": 2.83, "AC": 2.0, "TH": 2.4,
        "PA": 2.0, "U": 2.3, "NP": 2.0, "PU": 2.0, "AM": 2.0, "CM": 2.0, "BK": 2.0,
        "CF": 2.0, "ES": 2.0, "FM": 2.0, "MD": 2.0, "NO": 2.0, "LR": 2.0, "RF": 2.0,
        "DB": 2.0, "SG": 2.0, "BH": 2.0, "HS": 2.0, "MT": 2.0, "DS": 2.0, "RG": 2.0,
        "CN": 2.0, "UUT": 2.0, "FL": 2.0, "UUP": 2.0, "LV": 2.0, "UUH": 2.0
    };
    var DefaultVdwRadius = 2.0;
    //header.bFactorMax, bFactorMin, //bFactor
    var bFactorAnimation = function bFactorAnimation(atoms,atomsOn, positions,bFactorMin,bFactorMax){

        var bFactor;
        var x, y, z;
        var count = 0;
        var scale,radius;
        var diff = 1.0/(bFactorMax - bFactorMin);
        var ii,i;
        for(var ii = 0;ii < atomsOn.length;++ii){
            i = atomsOn[ii];

            bFactor = atoms[i].bFactor;
            x = atoms[i].x;
            y = atoms[i].y;
            z = atoms[i].z;
            if(bFactor > bFactorMin && bFactor <= bFactorMax){
                radius = VdwRadii[atoms[i].elementUpper];
                scale = radius * (bFactor - bFactorMin) *diff;
                x += scale*Math.random();
                y += scale*Math.random();
                z += scale*Math.random();
            }
            positions[count++] = x;
            positions[count++] = y;
            positions[count++] = z;

        };


    };

    var createColorArray = function createColorArray(atoms,getUVColor){

        var i;
        var numAtoms;
        numAtoms = atoms.length; //

        var particleCount = numAtoms;
        var colorArray = new Float32Array (particleCount *3);

        var i1  =0;
        var inv = 1/255.0;
        var col = {r:0,b:0,g:0};
        for (var z = 0; z < numAtoms; ++z) {
            i = atoms[z];
            getUVColor.getColor(i,col);
            colorArray[i1++] = col.r*inv;
            colorArray[i1++] = col.g*inv;
            colorArray[i1++] = col.b*inv;

        }
        return colorArray;
    };
    /**
     *
     * @param atoms This is a list of atoms that we will create with the view
     * @param molModel
     * @returns {{translateArray: null, radiusArray: null, bFactorArray: null}}
     */

    var createCPKViewArrays = function createCPKViewArrays(atoms,getUVColor,molModel,overrideRadius){
        var info = { translateArray: null, radiusArray:null, uvArray: null};
        var i;
        var numAtoms;
        var d = molModel.atomMetadata;
        numAtoms = atoms.length; //

        var particleCount = numAtoms;

        info.translateArray = new Float32Array( particleCount * 3 );
        info.radiusArray = new Float32Array( particleCount  );
        info.uvArray = new Float32Array (particleCount *2);
        //info.bFactorArray = new Float32Array( particleCount  );

        var i1  = 0,i2 = 0;
        var v, rad, z;
        var uv = {u:0, v:0};
        for (z = 0; z < numAtoms; ++z) {
            i = atoms[z];

            info.translateArray[i1++] = d[i].x;
            info.translateArray[i1++] = d[i].y;
            info.translateArray[i1++] = d[i].z;
            v = d[i].elementUpper;
            if(!overrideRadius) {
                rad = VdwRadii[v];
                if (!rad) {
                    rad = DefaultVdwRadius;
                }
            }else{
                rad = overrideRadius;
            }

            info.radiusArray[z] = rad;

            getUVColor.getUV2(i,uv);
            info.uvArray[i2++] = uv.u;
            info.uvArray[i2++] = uv.v;

        }
        return info;
    };


    var createStickViewArrays = function createStickViewArrays(atomsOn,getUVColor,atoms) {
        var info = {positions1: null, positions2: null, uvArray: null};


        var positions1 = [];
        var positions2 = [];
        var uvArray = [];
        var atom, atomIndex;
        var uv = {u: 0, v: 0};
        var positions;
        var x, y, z;
        for (var i = 0; i < atomsOn.length; ++i) {
            atomIndex = atomsOn[i];
            atom = atoms[atomIndex];
            if (atom.bonds.positions.length > 0) {
                getUVColor.getUV2(atomIndex, uv);
                x = atom.x;
                y = atom.y;
                z = atom.z;
                positions = atom.bonds.positions;
                for (var j = 0; j < positions.length; j += 3) {
                    uvArray.push(uv.u);
                    uvArray.push(uv.v);
                    positions1.push(x);
                    positions1.push(y);
                    positions1.push(z);
                    positions2.push(positions[j]);
                    positions2.push(positions[j + 1]);
                    positions2.push(positions[j + 2]);
                }
            }
        }
        info.positions1 = new Float32Array(positions1);
        info.positions2 = new Float32Array(positions2);
        info.uvArray = new Float32Array(uvArray);
        return info;
    };

    return {
        createColorArray: createColorArray,
        createCPKViewArrays : createCPKViewArrays,
        createStickViewArrays: createStickViewArrays,
        bFactorAnimation: bFactorAnimation
    };

};





;// set up namespace...
Autodesk.Viewing.MolViewer = Autodesk.Viewing.MolViewer || {};

//event that fires when viewer.uninitialize starts
Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED = 'beforeViewerUninitialized';
Autodesk.Viewing.METADATA_LOADED_EVENT = 'metadataLoaded';
Autodesk.Viewing.INSTANCES_CHANGED_EVENT = 'instancesChanged';
//custom molviewer load progress event
Autodesk.Viewing.MOLVIEWER_PROGRESS_EVENT = 'molViewerProgress';
//fires when assembly is set
Autodesk.Viewing.ASSEMBLY_SET_EVENT = 'assemblySet';
//fires when representation is changed
Autodesk.Viewing.REP_SET_EVENT = 'repSet';
//fires when model has been restored from url string (eventually from storage...)
Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT = 'modelStateRestored';


/**
 * constructor for MolViewerMan
 * @param {object} viewer - the 3DViewer object.
 * @param {object} apiConnector - the AdskMolView.ApiConnector object.
 * @param {object} viewManager - the AdskMolView.ViewManager object. (null passed in since this is created first)
 * @param {object} stateManager - the AdskMolView.StateManager object.
 * @param {object} loader - the AdskMolView.Loader object.
 * @param {object} molViewer - the AdskMolView.MolViewer object.
 */
Autodesk.Viewing.MolViewer.MolViewerMan = function(viewer,apiConnector,viewManager, stateManager, loader, molViewer) {
    this.viewer = viewer;
    this.apiConnector = apiConnector;
    this.viewManager = viewManager;
    this.stateManager = stateManager;
    this.molViewer = molViewer;
    this.Loader = loader;
    this.cmdStack = new Autodesk.Nano.CmdStack(viewer);
    this.molModels = {};
    this.currentMolModelID = null; //the id of the molModel that's shown in the UI
                                   //this will probably be temporary once we have real support for multiModels
    this.instances = [];
    this.selectedInstances = {};
    this.loadingMolModel = null;
    this.modelIsLoaded = false;
    this.sessionLoadingInfo  = {sessionID: 0,sessionIsLoading : false, data: null, nextModelToLoad: 0}


    var that = this;


    Autodesk.Viewing.MolViewer.MolViewerMan._instance = this;

    this.selectionFilter = 'residueID'; //'chain'; //may be chains residues or atoms.

    //put somewhere this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, giveMeAName);
    //this.viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, giveMeAName);

    this.modelEndLoadedBind = this.modelEndLoaded.bind(this);

    this.viewer.addEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT,this.modelEndLoadedBind);

    this.viewer.addEventListener(Autodesk.Nano.MODEL_LOAD_ERROR_EVENT, function (event){
        if(event.molModel){
            that.deleteMolModel(event.molModel.getID());
        }
    });

    //MZ TODO... MOVE THIS!

     this.vdwRadii = {
        "H" : 1.2,
        "LI" : 1.82,
        "NA" : 2.27,
        "K" : 2.75,
        "C" : 1.7,
        "N" : 1.55,
        "O" : 1.52,
        "F" : 1.47,
        "P" : 1.80,
        "S" : 1.80,
        "CL" : 1.75,
        "BR" : 1.85,
        "SE" : 1.90,
        "ZN" : 1.39,
        "CU" : 1.4,
        "NI" : 1.63,
        "X" : 2
    };

    this.bbox = null; //form myData.bbox from fake dummymodel
    this.bboxIsDirty = false;

    //used by various calcuations, store here instead of reallocating and thrashing memory
    this.cachedSphere = new THREE.Sphere();
    this.cachedTransform = new THREE.Matrix4();
    this.cachedVector = new THREE.Vector3();
    this.cachedBBox =new  THREE.Box3();

}; // end constructor

//mz need to sync with the instancemanager
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.addMolModel = function addMolModel(molModel){
    this.currentMolModelID = molModel.getID();
    this.molModels[this.currentMolModelID] = molModel;
};


/**
 * Get the molModel with that id or if the id is null or undefined get all of the molmodels
 * @param id
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getlMolModel = function getlMolModel(id){
    if (id ===null || id === undefined){
        return this.molModels;
    }else{
        return this.molModels[id];
    }
};
///MZ TODODO should be dict not list
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getInstance = function getInstance(id){
    for(var i =0;i < this.instances.length;++i){
        if(id === this.instances[i].id){
            return this.instances[i];
        }
    }
    return null;
};
/**
 * MZ TODO Make sure this is used everywhere is is correct, and also probably move out of molviewerman
 * @param atom
 * @returns float
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getRadius = function getRadius(atom) {
    if(!atom.elementUpper || typeof(this.vdwRadii[atom.elementUpper]) == "undefined") {
        return 2.0;
    }
    return this.vdwRadii[atom.elementUpper];
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.loadingModelRep = function loadingModelRep(){
    return this.loadingMolModel.loadingRep;
};
/**
 * An instance is added
 * @param instance
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.addInstance = function addInstance(instance){

    this.instances.push(instance);
    instance.molModel.addInstance(instance);
    instance.molReps.setUpMaterials(this.viewer);
    instance.createOverlay();
    var event = {
        type: Autodesk.Viewing.INSTANCES_CHANGED_EVENT,
        instances: this.instances
    };
    this.viewer.fireEvent(event);
};

/**
 * All instances are deleted
 * @param instance
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.deleteInstances = function deleteInstances(molModel,forceInstanceDtor){
    this.clearSelection();
    if(molModel) {
        for (var i = this.instances.length- 1; i >=0; --i) {
            if (molModel === this.instances[i].molModel ) {
                if(forceInstanceDtor || this.instances[i].molModel.deleteIfNotForced(this.instances[i])) {
                    this.instances[i].dtor();
                }
                this.instances.splice(i,1);
            }
        }
    }else {
        for (var i = 0; i < this.instances.length; ++i) {
            if (forceInstanceDtor || this.instances[i].molModel.deleteIfNotForced(this.instances[i])) {
                this.instances[i].dtor();
            }
        }
        delete this.instances;
        this.instances = [];
    }
    var event = {
        type: Autodesk.Viewing.INSTANCES_CHANGED_EVENT,
        instances: this.instances
    };
    if(molModel){
        molModel._deleteInstances();
    }
    else{
        for(var j in this.molModels){
            this.molModels[j]._deleteInstances();
        }
    }
    this.viewer.fireEvent(event);
};

/*
We may remove this later when we do a better job with handling instances with 2d.
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.selectInstance = function selectInstance(instance,what,keepSelection){
    this.selectedInstances[instance.id] = instance;
    instance.select(what,keepSelection);
};

/*
 Handles multiple selected instances.
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.selectInstances = function selectInstances(instances,what,keepSelection) {
    var i,
        keep;
    for (i = 0; i < instances.length; i++) {
        this.selectedInstances[instances[i].id] = instances[i];
        if(i === 0) {
            keep = keepSelection;
        } else {
            keep = true; //for multi selection this needs be true after first iteration of loop
        }
        instances[i].select(what, keep);
    }

};

/*
    The following functions are used by 3D selection, needs to get cleaned up
 */

/**
 *
 * @param result{instance:instance, atomID: atomID}
 * @param keepSelection
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.markObject =  function markObject(result,keepSelection) {
    //result now has the instance in it...

    result.instance.markObject(result,keepSelection);

    /*
    for(var i =0;i< this.instances.length;++i){
        var instance  = this.instances[i];
        if(instance.molModel.getID() === result.model._molID) {
            var rep = instance.reps[result.model._molRep];
            if (result.fragId <= rep.endFrag) {
                var instance = this.instances[i];
                instance.markObject(result, keepSelection);
                this.selectedInstances[instance.id] = instance;
                return;
            }
        }
    }*/

};

//mz to do change this,not sure to what though.
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getSelection = function getSelection() {
    var ret = this.molModels[this.currentMolModelID].instance.getSelection();
    return ret;
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.clearSelection = function clearSelection (nofire) {
    var i;
    for (i in this.molModels) {
        this.molModels[i].clearSelection(nofire);
    }
    delete this.selectedInstances;
    this.selectedInstances = {};
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.numSelected = function numSelected() {
    var what = 0;
    for(var i in this.selectedInstances){
        what += this.selectedInstances[i].numSelected();
    }
    return what;

};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.isSelected = function isSelected(result) {
    var what;
    for(var i in this.selectedInstances){
        what = this.selectedInstances[i].isSelected(result);
        if(what){
            return true;
        }
    }
    return false;
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.toggleSelection = function toggleSelection(resultArray){
    for(var i =0;i< resultArray.length;++i) {
        this.markObject(resultArray[0],true);
    }
}

//not sure what to do there.
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.selectionIsEqual = function selectionIsEqual(resultArray){
    var equal;
    for(var i in this.selectedInstances){
        equal= this.selectedInstances[i].selectionIsEqual(resultArray);
        if(equal){
            return true;
        }
    }
    return false;
}

/*
    End of 3D selection
 */


//when created only ribbon is visible so we turn off the visibility for the other
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.loadingIsVisibleOnCreation = function isVisibleOnCreation(fragId) {
    return (this.loadingMolModel.isVisibleOnCreation(fragId));
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.select= function select(dbId,what,keepSelection) {
    this.molModels[dbId].select(what,keepSelection);
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.loadingFragAdded = function fragAdded(fragId) {
    if(this.loadingMolModel) {
        this.loadingMolModel.fragAdded(fragId);
    }
};


Autodesk.Viewing.MolViewer.MolViewerMan.prototype.loadingGetMaterial = function getMaterial(fragId) {
    return this.loadingMolModel.getMaterial(fragId);
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.loadingGetIDMaterial = function loadingGetIDMaterial() {
    return this.loadingMolModel.idMaterialAtom;
};

/*
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getColorBits = function getColorBit(dbId,rep,atomArray) {
    var i,
        returnArray = [];
    if (!atomArray.length) {
        return false;
    }
    for (i = 0; i < atomArray.length; i++) {
        returnArray.push(this.molModels[dbId].instance.molReps.getColorBit(rep, atomArray[i]));
    }
    return returnArray;
};
*/

//not working great MZ @todo
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.moveEntity = function moveEntity(modelID,entityID,scale,rot,pos) {
    this.molModels[modelID].moveEntity(entityID,scale,rot,pos);
};


Autodesk.Viewing.MolViewer.MolViewerMan.prototype.copyEntity = function copyEntity(modelID,entityID,transform,origMat) {
    this.molModels[modelID].copyEntity(entityID,transform,origMat);
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.setEntityVisible = function setEntityVisible(modelID,entityID,visible,atomBitSet) {
    this.molModels[modelID].setEntityVisible(entityID,visible,atomBitSet);
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.setVisibleFromSelection = function setVisibleFromSelection(rep,visible) {
    var i,repModel;
    var repModels = []; //bvh's that we need to rebuild
    //mz LOCAL CHANGE
    if(this.numSelected() > 0) {
        for (var i in this.selectedInstances) {
            this.selectedInstances[i].setVisibleFromSelection(rep, visible);
            /*mz local
            repModel = this.selectedInstances[i].molModel.repModels[rep];
            repModels.push(repModel);
            */
        }

    }else{
        for (i =0;i < this.instances.length;++i){
            this.instances[i].setVisibleFromSelection(rep, visible);
            /*mz local
            repModel = this.instances[i].molModel.repModels[rep];
            repModels.push(repModel);
            */
        }
    }

    this._fireRepChangedEvent();
    /*
    for(i =0;i< repModels.length;++i) {
        repModels[i]._rebuildBVH();
    }
    */
    this.viewer.impl.invalidate(true);
    this.viewer.impl.sceneUpdated(true);
    this.viewer.impl.invalidate(true);
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getVisibleFromSelection = function getVisibleFromSelection(rep,checkAll){
    //if selected get it from that
    var i;
    var on;
    if (this.numSelected() > 0) {
        for (i in this.selectedInstances) {
            on  = this.selectedInstances[i].getVisibleFromSelection(rep,checkAll);
            if (checkAll) {
                if (!on) {
                    return false;
                }
            } else if (on) {
                return true;
            }
        }
    } else {
        for (i =0; i < this.instances.length; ++i) {
            on = this.instances[i].getVisibleFromSelection(rep,checkAll);
            if (checkAll) {
                if (!on) {
                    return false;
                }
            } else if (on) {
                return true;
            }
        }
    }
    return checkAll;
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getCustomColorIndexFromSelection = function getCustomColorIndexFromSelection(rep) {
    var i;
    var colors = {};
    var newColors = {};
    var newColor;
    if (this.numSelected() > 0) {
        for (i in this.selectedInstances) {
            newColors = this.selectedInstances[i].getCustomColorIndexFromSelection(rep);
            for (newColor in newColors) { //add the new properties
                if(newColors.hasOwnProperty(newColor)) {
                    colors[newColors[newColor]] = newColors[newColor];
                }
            }
        }
    } else {
        for (i =0;i < this.instances.length;++i){
            newColors = this.instances[i].getCustomColorIndexFromSelection(rep);
            for (newColor in newColors) { //add the new properties
                if(newColors.hasOwnProperty(newColor)) {
                    colors[newColors[newColor]] = newColors[newColor];
                }
            }
        }
    }

    return colors;
};


Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getAtomsWithCustomColorIndex = function getAtomsWithCustomColorIndex(rep, index) {
    var i,
        instanceColor,
        instanceColors = [];

    for (i = 0; i < this.instances.length; ++i) {
        instanceColor = this.instances[i].getAtomsWithCustomColorIndex(rep, index);
        instanceColors.push(instanceColor);
    }
    return instanceColors;
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.setColorFromSelection = function setColorFromSelection(rep, type, colorIndex, customSelectionInstances) {
    var that = this;
    this.hideSelectionState();
    if (this.selectionTimeout) {
        window.clearTimeout(this.selectionTimeout);
        delete this.selectionTimeout;
    }

    this.selectionTimeout = window.setTimeout(function () {
        that.showSelectionState();
    }, 3000);
    var i;

    // color everything since nothing selected
    // except for custom colors where select nothing === select nothing
    if (this.numSelected() === 0 && type !== 'custom') {

        for (i =0;i < this.instances.length;++i){
            this.instances[i].setColorFromSelection(rep, type, colorIndex);
        }
    } else {
        if (customSelectionInstances) {
            for (i = 0; i < customSelectionInstances.length; ++i) {
                customSelectionInstances[i].instance.setColorFromSelection(rep, type, colorIndex, customSelectionInstances[i].bitSet);
            }
        }

        if (this.numSelected() > 0) {
            for (i in this.selectedInstances) {
                this.selectedInstances[i].setColorFromSelection(rep, type, colorIndex);
            }
        }
    }

    this.viewer.impl.invalidate(true,true);
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.hideSelectionState = function hideSelectionState() {
    var instance;
    for (instance in this.selectedInstances) {
        if (this.selectedInstances.hasOwnProperty(instance)) {
            this.viewer.impl.highlightObjectByAtoms(this.selectedInstances[instance], this.selectedInstances[instance].atomSelectionState.getSelected(), false);
        }

    }
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.showSelectionState = function showSelectionState() {
    var instance;
    for (instance in this.selectedInstances) {
        if (this.selectedInstances.hasOwnProperty(instance)) {
            this.viewer.impl.highlightObjectByAtoms(this.selectedInstances[instance], this.selectedInstances[instance].atomSelectionState.getSelected(), true);
        }

    }
};


/**
 * Returns the color types from the current selection
 * @param rep Representation
 * @return dictionary object containing the types, e.g. {'chain':'chain', 'index':'index}
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getColorFromSelection = function getColorFromSelection(rep){
    //if selected get it from that
    var i,j;
    var tempType;
    var type = {};
    if(this.numSelected() > 0){
        for(i in this.selectedInstances) {
            tempType = this.selectedInstances[i].getColorFromSelection(rep);
            for(j in tempType){
                type[j] = j;
            }
        }
    }else{
        for (i =0;i < this.instances.length;++i){
            tempType = this.instances[i].getColorFromSelection(rep);
            for(j in tempType){
                type[j] = j;
            }
        }
    }
    return type;

};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.setOpacityFromSelection = function setOpacityFromSelection(modelID,rep,opacity,fromCustom) {
    var i;
    var self = this;
    // hide selection state when changing transparency
    this.hideSelectionState();
    if (this.selectionTimeout) {
        window.clearTimeout(this.selectionTimeout);
        delete this.selectionTimeout;
    }
    this.selectionTimeout = window.setTimeout(function () {
        self.showSelectionState();
    }, 3000);

    if(this.numSelected() > 0) {
        for (i in this.selectedInstances) {
            if (this.selectedInstances.hasOwnProperty(i)) {
                this.selectedInstances[i].setOpacityFromSelection(rep, opacity, fromCustom);
            }
        }
    }else{
        for (i =0;i < this.instances.length;++i){
            this.instances[i].setOpacityFromSelection(rep, opacity, fromCustom);
        }
    }

    this.viewer.impl.invalidate(true);
};
/**
 *
 * @param rep
 * @returns {*} a floating point number if all opacities are the same or the string 'multiple' if they are diffgeterent.
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getOpacityFromSelection = function getOpacityFromSelection(rep){
    //if selected get it from that
    var i,j;
    var tempVal;
    var val;
    if(this.numSelected() > 0){
        for(i in this.selectedInstances) {
            tempVal = this.selectedInstances[i].getOpacityFromSelection(rep);
            if(val && val !== tempVal){
                val = 'multiple';
                return val;
            }else{
                val = tempVal;
            }
        }
    }else{
        for (i =0;i < this.instances.length;++i){
            tempVal = this.instances[i].getOpacityFromSelection(rep);
            if(val && val !== tempVal){
                val = 'multiple';
                return val;
            }else{
                val = tempVal;
            }
        }
    }
    return val;

};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.setDefaultReps = function setDefaultReps(setDefault){
    for(var i =0;i< this.instances.length;++i){
        if(setDefault) {
            this.instances[i].setDefaultReps();
        }else {
            this.instances[i].setRepsFromState();
        }
    }
    this.viewer.impl.invalidate(true);
    this.viewer.impl.sceneUpdated(true);
    this._fireRepChangedEvent();
};




Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getPDBData = function getPDBData() {
    var config3d = {};
    var avp = Autodesk.Viewing.Private;
    var canvasConfig = avp.getParameterByName("canvasConfig");
    if (canvasConfig) {
        config3d.canvasConfig = JSON.parse(canvasConfig);
    }

    var docStructureConfig = avp.getParameterByName("docConfig");
    if (docStructureConfig) {
        config3d.docStructureConfig = JSON.parse(docStructureConfig);
    }

    var extensions = config3d['extensions'] || [],
        svfURL = null;

    config3d.extensions = extensions;

    return {
        config3d : config3d,
        documentId: undefined,
        svf: svfURL,
        initialItemId: undefined,
        isolateObjectId: undefined,
        userInfo : {
            name : "Molecule Viewer"
        },
        libraryName: "src/globalinit.js"
    };
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.isFragTransparent = function isFragTransparent(fragID){
//@todo need to fix for multi model
    return this.molModels[0].isFragTransparent(fragID);
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getAtomPosition = function getAtomPosition(instance,atomID) {
    return instance.getAtomPosition(atomID);

    //return repModel.getAtomPosition(fragId,dbId,atomID);
};



Autodesk.Viewing.MolViewer.MolViewerMan.prototype.explode = function explode(modelID,scale) {
    this.molModels[modelID].explode(scale);
};


Autodesk.Viewing.MolViewer.MolViewerMan.prototype.toJSONObj = function toJSONObj(){
    var model,obj = {};
    obj.models = {};
    for(var i in this.molModels){
        model = this.molModels[i].toJSONObj();
        obj.models[i] = model;
    }
    return obj;
};


Autodesk.Viewing.MolViewer.MolViewerMan.prototype.fromJSONObj = function fromJSONObj(obj){
    for(var i  in  obj.mol.models){
        if(this.molModels[i]){
            this.molModels[i].fromJSONObj(obj.mol.models[i]);
        }else{
            delete obj.mol.models[i]; //not found maybe because md5 no longer exists and we load default instead.
        }
    }
    this.viewer.fireEvent({type: Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT, state: obj}); //state restored from url (or later from storage...)
    this.viewer.restoreState(obj);
};


Autodesk.Viewing.MolViewer.MolViewerMan.prototype.isModelLoaded = function isModelLoaded(){
    return this.modelIsLoaded;
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.isSessionLoading = function isSessionLoading(){
    return this.sessionLoadingInfo.sessionIsLoading;
};


Autodesk.Viewing.MolViewer.MolViewerMan.prototype._fireRepChangedEvent = function _fireRepChangedEvent(){

    var event = {
        type: Autodesk.Viewing.REP_SET_EVENT
    };
    this.viewer.fireEvent(event);

};


Autodesk.Viewing.MolViewer.MolViewerMan.prototype.testSocket = function testSocket() {
    var newURL  = 'ws:' + "//" + window.location.hostname + ":8000";
    var pdbID = '/ZYRACKI';
    newURL +=  pdbID;

    var connection = new WebSocket(newURL, ['soap', 'xmpp']);
    connection.onopen = function () {
        connection.send('Ping'); // Send the message 'Ping' to the server
    };

// Log errors
    connection.onerror = function (error) {
        console.log('WebSocket Error ' + error);
    };

// Log messages from the server
    connection.onmessage = function (e) {
        console.log('Server: ' + e.data);
    };

    return;

    if (!this.myio)
        this.myio = (typeof lmv_io !== "undefined") ? lmv_io : io;

    var serverPath;
    var newURL;// = window.location.protocol + "//" + window.location.host + "/"
    //var socket = this.myio.connect(newURL, { path: '/mol/socket.io','forceNew': true });//   ,transports: ['websocket']});  //serverURL[_currentServer] + "?sessionID=" + sessionID, {path: serverPath, forceNew: true});
    var socket = this.myio();
    socket.on("connect", function () {
        console.log("Connected!");
    });
/*
    _socket.on("connect", onConnect);
    _socket.on("message", onRecv);
    _socket.on("connect_error", onConnectError);
    _socket.on("error", onError);
  */
    socket.on("connect_error", function(error){
        console.log('connecterror');
        console.log(error);
    });
    socket.on("error", function(error){
        console.log('error');
        console.log(error);
    });

    socket.on('news', function (data) {
        console.log(data);
        socket.emit('my other event', { my: 'data' });
    });
    /*
    socket.on("connect", onConnect);
    socket.on("message", onRecv);
    socket.on("connect_error", onConnectError);
    socket.on("error", onError);
    ?*/
};



Autodesk.Viewing.MolViewer.MolViewerMan.prototype.createMolModel = function createMolModel(pdbID,url,md5) {

    var viewer = this.viewer;
    var id = pdbID ? pdbID  : md5;
    var options = {molMan: this, viewer: this.viewer, apiConnector: this.apiConnector, viewManager: this.viewManager, loader: this.Loader, url: url, md5:md5, pdbID:pdbID};
    var molModel = new Autodesk.Nano.MolViewer.MolModel(id, options); //mz need to add some sort of unique identifier..

    var event = {
        type: Autodesk.Nano.MODEL_START_LOADED_EVENT,
        modelType: 'mol',
        model: molModel
    };

    viewer.fireEvent(event);
    this.loadingMolModel = molModel;
    molModel.loadMetadata(url, md5);

};


Autodesk.Viewing.MolViewer.MolViewerMan.prototype.deleteMolModel = function deleteMolModel(id) {
    this.cmdStack.clearStack(); //move to just clear for this model...???
    var molModel = this.molModels[id];
    if(molModel) {
        if(molModel.getID() === this.currentMolModelID){
            var keys = Object.keys(this.molModels);
            this.currentMolModelID = keys && keys.length > 0 ? keys[0] : 0;
        }
        molModel.dtor(); //fires events and does cleanup
        delete this.molModels[id];
    }

};

/**
 * Returns an object that contains the current session information.
 * Currently used by the saveSession function in apiconnector, not for public or API use.
 * @returns {{state: *, snapShots: Array, molModels: {}}}
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.saveSessionState = function saveSessionState() {
    var viewManager = this.viewer.app.ViewManager;  //circular but maybe better than passing in the viewManager?
    var stateButtons;
    if (this.viewer.gui) { //if viewer is GuiMoleculeViewer
        var stateView = viewManager.getTopView('StateView');
        stateButtons = stateView.stateButtons;
    }

    //state = stateView.getSnapshot(), //get compressed state string
        //var state = this.molViewer.getMolViewerState(),
        var state = this.viewer.app.MolViewer.getMolViewerState(),
        snapShot,
        snapShots = [],
        molInfo = [], info,
        i;

    if (viewManager) {
        for (i = 0; i < stateButtons.length; ++i) {
            snapShot = {
                id: stateButtons[i].id,
                name: stateButtons[i].text.value,
                active: stateButtons[i].active,
                state: stateButtons[i].stateString
            };
            snapShots.push(snapShot);
        }
    }

    var molModels = this.getlMolModel();
    for(var id in molModels){
        info  = {pdbID: molModels[id].pdbID, url: molModels[id].url, md5: molModels[id].md5};
        molInfo.push(info);
    }
    var stateObj = {
        state: state,
        snapShots: snapShots,
        molModels: molInfo
    };
    return stateObj;
};



Autodesk.Viewing.MolViewer.MolViewerMan.prototype.saveSessionCookie = function saveSessionCookie(sessionID){
    this.apiConnector.setCookieItem('sessionCookie', sessionID);

};


/**
 * Need to handle error handling.
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.saveSession = function saveSession() {
    this.apiConnector.saveSession();
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.modelEndLoaded = function modelEndLoaded(){
    this.modelIsLoaded = true;
    if(this.sessionLoadingInfo.sessionIsLoading){
        this.sessionLoadingInfo.nextModelToLoad++;
        var data = this.sessionLoadingInfo.data;
        if(this.sessionLoadingInfo.nextModelToLoad < data.molModels.length){
            this.loadNextModelInSession(data);
        }else{
            this.fromJSONObj(data.state);

            this.sessionLoadingInfo.sessionIsLoading = false;
            this.sessionLoadingInfo.data = null;
            this.sessionLoadingInfo.nextModelToLoad = 0;
            var event = {
                type: Autodesk.Nano.SESSION_LOADED_EVENT
            };
            this.viewer.fireEvent(event);
            this.saveSessionCookie(this.sessionLoadingInfo.sessionID);
        }
    }


};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.loadNextModelInSession = function loadNextModelInSession(data) {
    var id,molInfo;

    if(this.sessionLoadingInfo.nextModelToLoad < data.molModels.length){

        molInfo = data.molModels[this.sessionLoadingInfo.nextModelToLoad];
        this.createMolModel(molInfo.pdbID, molInfo.url, molInfo.md5);
    }

}
/**
 * Load the session with that ID. There are two special sessionID's.  One is if the value is 0 or not true
 * the session won't load. The other is default, in which case we load the default protein (1c7d).
 * @param sessionID
 */
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.loadSession = function loadSession(sessionID) {
    var self = this;
    if(sessionID) {
        if(sessionID !== 'default') {
            this.apiConnector.loadSession(sessionID)
                .then(function (data) {

                    //add data from the data object to options
                    self.sessionLoadingInfo.sessionID = sessionID;
                    self.sessionLoadingInfo.sessionIsLoading = true; //mz need to see if one is already loading?? what to do
                    self.sessionLoadingInfo.data = data;
                    self.sessionLoadingInfo.nextModelToLoad = 0;
                    self.loadNextModelInSession(data);

                    if (!self.Loader.options.headless  && data.snapShots) { //this can happen while models are loading
                        self.stateManager.restoreStateButtons(data.snapShots, data.mode);
                    }
                })
                .catch(function (err) {
                    console.error('Failed to load session ' + sessionID + 'error:', err);
                    self.apiConnector.displayError('Failed to load session ' + sessionID + '. Please verify your shared URL.');
                });
        }else{
            self.createMolModel("1C7D");
        }
    }
}

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.startUndoGroup = function startUndoGroup() {
    this.cmdStack.startGroup();
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.endUndoGroup = function endUndoGroup() {
    this.cmdStack.endGroup();
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.clearCmdStack = function clearCmdStack(){
    this.cmdStack.clearStack();
};


Autodesk.Viewing.MolViewer.MolViewerMan.prototype.findHitTestInstance = function findHitTestInstance(ray,atomID){

    var maxDist = Number.MAX_VALUE;
    var instance,inst,dist;
    if(this.instances.length ==1){
        instance = this.instances[0];
    }else{
        var possibleInstances = [];
        for(var i =0 ;i< this.instances.length;++i){
            inst = this.instances[i];
            dist = this.instances[i].doesThisHitSphere(ray);
            if(dist && dist < maxDist){
                possibleInstances.push(inst);
            }
        }
        for(var i =0; i < possibleInstances.length;++i){
            inst = possibleInstances[i];
            dist = inst.doesThisHitAtom(ray,atomID,this.cachedSphere);
            if(dist && dist < maxDist){
                maxDist = dist;
                instance = inst;
            }
        }
    }
    return instance;
};
Autodesk.Viewing.MolViewer.MolViewerMan.prototype.tick = function tick(){

    for(var i =0 ;i < this.instances.length; ++i){
        this.instances[i].tick();
    }
};



Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getSelectionBounds = function getSelectionBounds() {
    var box;
    var i;
    var  total = new THREE.Box3();
    for(i in this.selectedInstances) {
        box = this.selectedInstances[i].getSelectedAtomsBBox();
        if(box){
            total.union(box);
        }
    }
    return total;
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getVisibleBounds = function getVisibleBounds(){

    if(this.bboxIsDirty === true && this.bbox){
        this.bbox.makeEmpty();
        this.bboxIsDirty = false;
        var box;
        var atomIDs;
        var molModel;
        for(var i in this.molModels) {
            molModel = this.molModels[i];
            atomIDs = molModel.getAtomIDArray();
            for(var z =0; z < molModel.activeInstances.length;++z) {
                box = molModel.activeInstances[z].getAtomsBBox(atomIDs);
                if (box) {
                    this.bbox.union(box);
                }
            }
        }
    }
    if(this.bbox) {
        return this.bbox;
    }else {
        return this.cachedBBox.makeEmpty();
    }
};


Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getSelectionCenter = function getSelectionCenter() {
    var pos;
    var posarray = [];
    var i,j;
    var total;
    for(i in this.selectedInstances) {
        pos = this.selectedInstances[i].getSelectedAtomsCenter();
        if(pos){
            posarray.push(pos);
        }
    }
    if(posarray.length> 0) {
        total = {x:0,y:0,z:0};
        for (j = 0; j < posarray.length; ++j) {
            total.x += posarray[j].x;
            total.y += posarray[j].y;
            total.z += posarray[j].z;
        }
        var invlength = 1.0 / posarray.length;
        total.x *= invlength;
        total.y *= invlength;
        total.z *= invlength;
    }
    return total;
};

Autodesk.Viewing.MolViewer.MolViewerMan.prototype.getVisibleCenter = function getVisibleCenter(){
    var bbox = this.getVisibleBounds();
    return bbox.center(); //allocates
};
/*

 options.state = data.state;
 options.svf = dataPath;
 //options.state = LZString144.decompressFromEncodedURIComponent(data.state);
 options.snapShots = data.snapShots;


window.ApiConnector.loadSession(sessionID)
    .then(function(data) {
        //here we get the url from the id
        //MolViewer.resetViewer(); //make sure it's cleaned, go through and load it up
        var options = self.getOptionsFromQueryString();
        var options = TheMolMan.loadSessionState(data,options);
        self.loadViewData(options);
    })
    .catch(function(err) {
        console.error('Failed to load session ' + session + 'error:', err);
        ApiConnector.displayError('Failed to load session ' + session +'. Please verify your shared URL.' );
    });


var svfURL = options.svf;
this.options = options;
if(this.options.state) {
    viewer.addEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT, function() {
        TheMolMan.fromJSONObj(loader.options.state);
    });
}

this.loadTopViews(viewer,options);
viewer.start();
if(svfURL !== '') {
    viewer.load(svfURL);
} else {
    ViewManager.getTopView('StatusView').hide();
}
viewer.setQualityLevel(false, true);


if (options.config3d && options.config3d.autocamDuration) {
    viewer.autocam.shotParams.duration = options.config3d.autocamDuration;
}

if (options.config3d && options.config3d.autocamDestinationPercent) {
    viewer.autocam.shotParams.destinationPercent = options.config3d.autocamDestinationPercent;
}



 */;Autodesk.Nano = Autodesk.Nano || {};
Autodesk.Nano.MolViewer = Autodesk.Nano.MolViewer || {};
/**
 * constructor for MolModel
 * @param {object} viewer - the 3DViewer object.
 */
Autodesk.Nano.MolViewer.RepModel = function(viewer,molModel,renderModel,rep) {
    this.molModel = molModel;
    this.entities = molModel.entities;
    this.renderModel = renderModel;
    renderModel._molRep = rep;
    renderModel._molID = molModel.getID();
    this.rep = rep;
    this.fragIds = []; //list of fragment id's that make up this guy
    this.viewer = viewer;

    //set up information from metadata
    var i;

    this.dbIdsMetadata =  renderModel.myData.metadata['custom json'].dbIdsMetadata;
    this.fragId2dbId = renderModel.myData.fragments.fragId2dbId;
    this.entity2dbIdAndFrags = {};
    this.fragToAtoms = [];
    this.matDefs = {};
    this.fragToMaterials = []; //what materialDef each frag points to

    for(i =0;i< this.fragId2dbId.length;++i){
        var dude = [];
        this.fragToAtoms.push(dude);
        this.fragToMaterials.push(0);
    }
    var dbId;
    var type,entityID;
    var entity;

    var rm = renderModel;
    var fragList = rm.getFragmentList();
    fragList.origFragLength = fragList.vizflags.length;


    for(dbId in this.dbIdsMetadata){
        type = this.dbIdsMetadata[dbId].rep;
        entityID = this.dbIdsMetadata[dbId].entityID;
        //for each entity contains the frags, the instances (represented by frag start/end pair, and the original frag length after load
        this.entity2dbIdAndFrags[entityID] = {frags:[], origFragLength: 0, instances:[], geometries:{}};
    }
    for (i = 0;i< this.fragId2dbId.length;++i){
        dbId = (this.fragId2dbId[i]); //mz todo revisit this dbid to hold instance in addition to type and entity?
        entityID = this.dbIdsMetadata[dbId].entityID;
        this.entity2dbIdAndFrags[entityID].frags.push(i);
        //not used but maybe later, we'll see in a bit,this.fragToInstance.push(this.instance);
    }


    var atomToFrags = this.readAtomMeshData(renderModel);
    this.molModel.instance.setAtomToFrags(rep,atomToFrags);

    for(entity in this.entities){
        var entityAndFrags =  this.entity2dbIdAndFrags[entity];
        entityAndFrags.origFragLength = entityAndFrags.frags.length;
    }
}; // end constructor


Autodesk.Nano.MolViewer.RepModel.prototype.dtor = function dtor() {
    this.deleteGeometries();
    this.viewer.impl.unloadModel(this.renderModel);
    delete this.geometries;
    delete this.renderModel;
    delete this.molModel;

};
Autodesk.Nano.MolViewer.AtomToMesh = function(data){
    this.pfr = new Autodesk.LMVTK.PackFileReader(data);
};

Autodesk.Nano.MolViewer.AtomToMesh.prototype.getAtomFrags = function getAtomFrags(atomIndex,renderModel) {

    var atomFrags = [];
    var key, i;
    var tse = this.pfr.seekToEntry(atomIndex);
    var mesh2frag = renderModel.myData.fragments.mesh2frag;
    var numPacks = this.pfr.stream.getUint32();
    for (i = 0; i < numPacks; ++i) {
        key = this.pfr.readString();
        var splits = key.split('.');
        var newKey = splits[0] + ':' + splits[2];
        var fragId = mesh2frag[newKey];
        var obj = {fragId: fragId, indices: []};
        var numTris = this.pfr.stream.getUint32();
        for (var z = 0; z < numTris; ++z) {
            var index = this.pfr.stream.getUint32();
            obj.indices.push(index);
        }
        atomFrags.push(obj);
    }
    return atomFrags;
}


Autodesk.Nano.MolViewer.AtomToMesh.prototype.setUpFragsAndAtoms = function setUpFragsAndAtoms(fragToAtoms,atomToFrags,renderModel,numAtoms) {

    var tse, numPacks, i,z;
    var mesh2frag = renderModel.myData.fragments.mesh2frag;//also delete this?
    var key;

    for(z =0; z < numAtoms;++z) {
        tse = this.pfr.seekToEntry(z);
        numPacks = this.pfr.stream.getUint32();
        for (i = 0; i < numPacks; ++i) {
            key = this.pfr.readString();
            var splits = key.split('.');
            var newKey = splits[0] + ':' + splits[2];
            var fragId = mesh2frag[newKey];
            atomToFrags[z].push(fragId);
            fragToAtoms[fragId].push(z);
            var numTris = this.pfr.stream.getUint32();
            this.pfr.stream.offset += (numTris * 4);
        }
    }
};


Autodesk.Nano.MolViewer.RepModel.prototype.setUpGeometries = function setUpGeometries(){
    var entity;
    var rm = this.renderModel;
    var fragList = rm.getFragmentList();
    for(entity in this.entities){
        var entityAndFrags =  this.entity2dbIdAndFrags[entity];
        if(this.entities[entity].isForAssembly){
            //set up the geometry objects per orig frag for each assembly
            for(var i =0; i < entityAndFrags.origFragLength;++i){
                var geometry = {origGeometryId: fragList.getGeometryId(entityAndFrags.frags[i]), newGeometries :{} };
                entityAndFrags.geometries[entityAndFrags.frags[i]] = geometry;
            }
        }
    }
};

Autodesk.Nano.MolViewer.RepModel.prototype.readAtomMeshData = function readAtomMeshData(renderModel) {
    var metadata = renderModel.myData.metadata;

    var data = null;
    if (metadata.atomMeshStick) {
        this.rep = 'stick';
        data = metadata.atomMeshStick;
    } else if (metadata.atomMeshRibbon) {
        this.rep = 'ribbon';
        data = metadata.atomMeshRibbon;
    } else if (metadata.atomMeshSurface) {
        this.rep = 'surface';
        data = metadata.atomMeshSurface;
    } else {
        return;
    }

    this.atomToMesh =  new Autodesk.Nano.MolViewer.AtomToMesh(data);


    var atomToFrags = [];
    var numAtoms = this.molModel.getNumAtoms();
    for (var z = 0;z < numAtoms;z++){
        var obj = [];
        atomToFrags.push(obj);
    }
    this.atomToMesh.setUpFragsAndAtoms(this.fragToAtoms,atomToFrags,renderModel,numAtoms);
    return atomToFrags;

};



Autodesk.Nano.MolViewer.RepModel.prototype.getGeometry = function getGeometry(entityID,origFragId,geometry,meshIndices){
    var  entityFrag = this.entity2dbIdAndFrags[entityID];
    var geometries = entityFrag.geometries[origFragId];
    var hash = md5(meshIndices);
    var newGeometry = geometries.newGeometries[hash];
    if(!newGeometry){
        newGeometry = this.newGeometryBuffer(geometry);
        newGeometry.ib = meshIndices;
        geometries.newGeometries[hash] = newGeometry;
        newGeometry.elementsNeedUpdate = true;
        newGeometry.molUpdateIB = true;
    }
    return newGeometry;
};


//not being called yet will revisit.
Autodesk.Nano.MolViewer.RepModel.prototype.moveEntity = function moveEntity(entityID,scale,rot,pos) {
    var entity = this.entity2dbIdAndFrags[entityID];
    if (entity && entity.frags) {
        var fragList = this.renderModel.getFragmentList();
        //var pt = new THREE.Vector3();
        var frags = entity.frags;
        for (var j = 0; j < frags.length; j++) {
            fragList.updateAnimTransform(frags[j], scale, rot, pos);
        }
        this.renderModel.visibleBoundsDirty = true;
        //force a repaint and a clear
        this.viewer.impl.sceneUpdated(true);
    }
};
Autodesk.Nano.MolViewer.RepModel.prototype.resetAnimTransforms = function resetAnimTransforms(){
    var rm = this.renderModel;
    var fragList = rm.getFragmentList();
    fragList.resetAnimTransforms();
};
//but also does fragId2dbId
Autodesk.Nano.MolViewer.RepModel.prototype.resizeFragListArrays  = function resizeFragListArrays(numNewFragments){
    var rm = this.renderModel;
    var fragList = rm.getFragmentList();
    fragList.fixedSize = false;
    //get these guys back to original
    var entity;

    for(entity in this.entity2dbIdAndFrags){
        this.entity2dbIdAndFrags[entity].frags = this.entity2dbIdAndFrags[entity].frags.slice(0,this.entity2dbIdAndFrags[entity].origFragLength);
    }

    fragList.setNextAvailableFragmentId(fragList.origFragLength);

    var fragId2dbId,nflags,ntransforms,nboxes,nids,nmids,pg;
    var nlen =  fragList.origFragLength +  numNewFragments;
    var currentLen = this.fragId2dbId.length;
    if(nlen > currentLen) {
        fragId2dbId = new Uint32Array(nlen);
        fragId2dbId.set(this.fragId2dbId);
        this.fragId2dbId = fragId2dbId;
        rm.myData.fragments.fragId2dbId = fragId2dbId;

        nflags = new Uint8Array(nlen);
        nflags.set(fragList.vizflags);
        fragList.vizflags = nflags;

        if (fragList.transforms) {
            ntransforms = new Float32Array(nlen * 12);
            ntransforms.set(fragList.transforms);
            fragList.transforms = ntransforms;

        }
        if (fragList.boxes) {
            nboxes = new Float32Array(nlen * 6);
            nboxes.set(fragList.boxes);
            fragList.boxes = nboxes;

        }

        if (fragList.geomids) {
            nids = new Int32Array(nlen);
            nids.set(fragList.geomids);
            fragList.geomids = nids;

        }

        if (fragList.materialids) {
            nmids = new Int32Array(nlen);
            nmids.set(fragList.materialids);
            fragList.materialids = nmids;
        }
        if (fragList.fragments.polygonCounts) {
            pg = new Uint32Array(nlen);
            pg.set(fragList.fragments.polygonCounts);
            fragList.fragments.polygonCounts = pg;
        }
    }else{
        this.fragId2dbId = this.fragId2dbId.subarray(0,nlen);
        rm.myData.fragments.fragId2dbId = this.fragId2dbId;


        fragList.vizflags =  fragList.vizflags.subarray(0,nlen);

        if (fragList.transforms) {
            ntransforms = fragList.transforms.subarray(0,nlen * 12);
            fragList.transforms = ntransforms;
            fragList.fragments.transforms = fragList.transforms;
        }
        if (fragList.boxes) {
            nboxes = fragList.boxes.subarray(0,nlen * 6);
            fragList.boxes = nboxes;
            fragList.fragments.boxes = fragList.boxes;
        }

        if (fragList.geomids) {
            nids = fragList.geomids.subarray(0,nlen);
            fragList.geomids = nids;

        }

        if (fragList.materialids) {
            nmids = fragList.materialids.subarray(0,nlen);
            fragList.materialids = nmids;
        }
        if (fragList.fragments.polygonCounts) {
            pg = fragList.fragments.polygonCounts.subarray(0,nlen);
            fragList.fragments.polygonCounts = pg;
        }
    }
    fragList.fragments.length = nlen;
};

Autodesk.Nano.MolViewer.RepModel.prototype.getOrigMat = function getOrigMat (mat,fragList,fragIndex) {
    var transforms = fragList.fragments.transforms;
    var z = fragIndex * 12;
    mat.elements[0] = transforms[z];
    mat.elements[1] = transforms[z+1];
    mat.elements[2] = transforms[z+2];
    mat.elements[4] = transforms[z+3];
    mat.elements[5] = transforms[z+4];
    mat.elements[6] = transforms[z+5];
    mat.elements[8] = transforms[z+6];
    mat.elements[9] = transforms[z+7];
    mat.elements[10] = transforms[z+8];
    mat.elements[12] = transforms[z+9];
    mat.elements[13] = transforms[z+10];
    mat.elements[14] = transforms[z+11];
};


Autodesk.Nano.MolViewer.RepModel.prototype.setFragTransformAndBox = function setFragTransformAndBox(fragList,fragID,oldFragID,transform,boxTransform){

    var i = fragID * 12;
    var cur = transform.elements;
    var orig = fragList.transforms;

    if (orig) {
        orig[i] = cur[0];
        orig[i + 1] = cur[1];
        orig[i + 2] = cur[2];
        orig[i + 3] = cur[4];
        orig[i + 4] = cur[5];
        orig[i + 5] = cur[6];
        orig[i + 6] = cur[8];
        orig[i + 7] = cur[9];
        orig[i + 8] = cur[10];
        orig[i + 9] = cur[12];
        orig[i + 10] = cur[13];
        orig[i + 11] = cur[14];
    }
    i = fragID * 6;
    var oldi = oldFragID * 6;
    orig = fragList.fragments.boxes; //original cached.
    var newBox = fragList.boxes;
    var b = new THREE.Box3();
    b.min.x = orig[oldi];
    b.min.y = orig[oldi+1];
    b.min.z = orig[oldi+2];
    b.max.x = orig[oldi+3];
    b.max.y = orig[oldi+4];
    b.max.z = orig[oldi+5];
    b.applyMatrix4(boxTransform);

    if(newBox){
        newBox[i] = b.min.x;
        newBox[i+1] = b.min.y;
        newBox[i+2] = b.min.z;
        newBox[i+3] = b.max.x;
        newBox[i+4] = b.max.y;
        newBox[i+5] = b.max.z;
    }
    fragList.fragments.polygonCounts[fragID] = fragList.fragments.polygonCounts[oldFragID];
};

Autodesk.Nano.MolViewer.RepModel.prototype.setEntityVisible = function setEntityVisible(entityID,visible,atomBitSet) {
    var entity = this.entity2dbIdAndFrags[entityID];
    if (entity && entity.frags) {
        var frags = entity.frags;
        var atoms = [];
        var state =  this.molModel.instance.atomSelectionState;
        for(var i = 0;i < state.atoms.length;++i) {
            if (state.bitSet.get(i)) {
                atoms.push(i);
            }
        }
        var rm  = this.renderModel;
        for (var j = 0; j < frags.length; j++) {
            this.viewer.impl.visibilityManager.setVisibilityOnNode(frags[j],visible,rm);
        }
        if(atoms.length > 0) {
            state.markObjects(atoms);
        }
        this.entities[entityID].isVisible = visible;
        this.viewer.impl.invalidate(true);
    }else{
        console.log("there was an error setting visibility with an improper type")
    }
};

Autodesk.Nano.MolViewer.RepModel.prototype.copyEntity = function copyEntity(entityID,instance,transform,origMat) {
    var entity = this.entity2dbIdAndFrags[entityID];
    if (entity && entity.frags) {
        var j;
        var rm = this.renderModel;
        var fragList = rm.getFragmentList();
        //var pt = new THREE.Vector3();
        var frags = entity.frags;
        var fragID,oldFragID;
        var newFrags = [];
        var type,dbID;
        var mesh;
        var tmpMatrix = new THREE.Matrix4();
        //this.resizeFragListArrays(fragList,frags.length);
        var start = fragList.getNextAvailableFragmentIdNoIncrement();
        instance.reps[this.rep].startFrag = start;
        instance.reps[this.rep].endFrag = start + entity.origFragLength-1;
        for (j = 0; j < entity.origFragLength; j++) {
            oldFragID = frags[j];
            fragID = fragList.getNextAvailableFragmentId();
            this.getOrigMat(origMat,fragList,oldFragID);
            origMat.multiply(transform);
            this.setFragTransformAndBox(fragList,fragID,oldFragID,origMat,transform);
            newFrags.push(fragID);
            //update our data structures
            dbID = this.fragId2dbId[oldFragID];
            this.fragId2dbId[fragID] = dbID;
            //copy atoms over
            var atomsInFrag = this.fragToAtoms[oldFragID];
            for(var z = 0;z < atomsInFrag.length;++z){
                instance.reps[this.rep].atomToFrags[atomsInFrag[z]].push(fragID);
            }
            fragList.getOriginalWorldMatrix(fragID, tmpMatrix);
            mesh = this.viewer.impl.getRenderProxy(rm, oldFragID);
            var m = this.viewer.impl.setupMesh(rm, mesh.geometry,instance.molReps.reps[this.rep].matName, tmpMatrix,fragID);
            rm.activateFragment(fragID, m);
            var visible = false;//this.molModel.isVisibleOnCreation(fragID,true);
            this.viewer.impl.visibilityManager.setVisibilityOnNode(fragID,visible,rm);

        }
        //this is slow we instead just copy later!g!!instance._setRepsFromState();
        for(var i = 0;i<newFrags.length;++i){
            entity.frags.push(newFrags[i]);
        }

    }
};

Autodesk.Nano.MolViewer.RepModel.prototype.isFragTransparent = function isFragTransparent(fragID){
    return this.rep ==='surface';  // this.dbIdsMetadata[this.fragIDs2DbId[i]] == 'surface' ? true : false;

};

//@todo need to fix this for multiple models
Autodesk.Nano.MolViewer.RepModel.prototype._rebuildBVH = function _rebuildBVH() {
    var svf = {};
    var rm = this.renderModel;

    svf.bvh = new avp.BVHBuilder(rm.getFragmentList(),rm.getFragmentList().fragments,this.fragToMaterials, this.matDefs);
    svf.bvh.build({isWeakDevice : av.isMobileDevice()});
    rm.setBVH(svf.bvh.nodes, svf.bvh.primitives);

    rm.visibleBoundsDirty = true;
    rm.getVisibleBounds();


};


// get atom position from atomID
Autodesk.Nano.MolViewer.RepModel.prototype.getAtomPosition = function getAtomPosition(fragID,dbId,atomID) {
    var dbMetadata = this.dbIdsMetadata[dbId];
    var entityID = dbMetadata.entityID;
    //var entityInfo = this.entity2dbIdAndFrags[entityID];
    var pt = this.molModel.getLocalAtomPosition(atomID,this.entities[entityID].isForAssembly);
    var dst = new THREE.Matrix4();
    this.renderModel.getFragmentList().getWorldMatrix(fragID, dst);
    pt.applyMatrix4(dst);

    return {x: pt.x, y: pt.y, z: pt.z};
};
////////////////////////////////




Autodesk.Nano.MolViewer.RepModel.prototype.newGeometryBuffer = function newGeometryBuffer(oldGeom) {
    var geometry = Autodesk.Viewing.Private.BufferGeometryUtils.createBufferGeometry();
    var rm  = this.renderModel;

    geometry.byteSize = oldGeom.byteSize;

    geometry.vb = oldGeom.vb;

    geometry.vbstride = oldGeom.vbstride;
    geometry.isLines = oldGeom.isLines;
    geometry.is2d = oldGeom.is2d;

    geometry.numInstances = oldGeom.numInstances;

    for (var attributeName in oldGeom.attributes) {
        geometry.attributes[attributeName] = oldGeom.attributes[attributeName];
    }

    geometry.attributes.index = oldGeom.attributes.index;
    geometry.ib = oldGeom.ib;

    geometry.attributesKeys = oldGeom.attributesKeys;

    var gm = rm.getGeometryList();
    geometry.boundingBox = new THREE.Box3();
    geometry.boundingBox.min.x =gm.geomBoxes[oldGeom.svfid * 6];
    geometry.boundingBox.min.y = gm.geomBoxes[oldGeom.svfid * 6 + 1];
    geometry.boundingBox.min.z = gm.geomBoxes[oldGeom.svfid * 6 + 2];
    geometry.boundingBox.max.x = gm.geomBoxes[oldGeom.svfid * 6 + 3];
    geometry.boundingBox.max.y = gm.geomBoxes[oldGeom.svfid * 6 + 4];
    geometry.boundingBox.max.z = gm.geomBoxes[oldGeom.svfid * 6 + 5];
    geometry.boundingSphere = oldGeom.boundingSphere;

    //MEM
    geometry.drawcalls = oldGeom.drawcalls;
    geometry.offsets = oldGeom.offsets;
    var geomId = rm.getGeometryList().addGeometry(geometry, 0, -1);

    return geometry;
};


Autodesk.Nano.MolViewer.RepModel.prototype.explode = function explode(realScale) {

    var instance,model,fragList;
    var cx, q, b;
    //Input scale is in the range 0-1, where 0
    //means no displacement, and 1 maximum reasonable displacement.
    var mc = this.bbox.center();



};

Autodesk.Nano.MolViewer.RepModel.prototype.addInstance = function addInstance (inst) {
    for (var entityID in inst.entityIDs) {
        this.entity2dbIdAndFrags[inst.entityIDs[entityID]].instances.push(inst);
    }
};

Autodesk.Nano.MolViewer.RepModel.prototype.deleteGeometries = function deleteGeometries () {
    var entityFrag;
    var geometry; //{origGeometryId: fragList.getGeometryId(entityAndFrags.frags[i]), newGeometries:{} };
    var rm = this.renderModel;
    for (var entityID in this.entity2dbIdAndFrags) {
        entityFrag = this.entity2dbIdAndFrags[entityID];
        entityFrag.instances = [];
        for (var i = 0; i < entityFrag.geometries.length; ++i) {
            geometry = entityFrag.geometries[i];
            for (var id in geometry.newGeometries) {
                var newGeometry = geometry.newGeometries[id];
                rm.getGeometryList().removeGeometry(newGeometry.svfid); //mz not sure this actually free's memory so added the below
                delete geometry.newGeometries[id]; //safe per standard
            }
        }
    }
}


;//constructor
Autodesk.Viewing.MolViewer.ViewManager2D = function ViewManager2D(app) {
    this.getViewer = function() {
        return app.MoleculeViewer;
    };

    this.app = app;
    this.molMan = app.MolMan;
    this.molViewer = app.MolViewer;

    //events
    Autodesk.Viewing.BROWSER_RESIZED_EVENT = 'browserResized';

    Autodesk.Viewing.OPENSTATE_CHANGE_EVENT = 'openStateChanged';

    Autodesk.Viewing.SELECTION_CHANGED_UPDATE = 'selectionChangedUpdate';

    Autodesk.Viewing.INSPECTOR_LOADED = 'inspectorLoaded';

    Autodesk.Viewing.VIEW_CREATED_EVENT = 'viewCreated';

    Autodesk.Viewing.MolViewer.MAX_TABLET_MODE_RESOLUTION = 1280;
    Autodesk.Viewing.MolViewer.MAX_PHONE_MODE_RESOLUTION = 768;


    //Autodesk.Viewing.MolViewer.ViewManager2D._instance = this;
    //window.ViewManager = Autodesk.Viewing.MolViewer.ViewManager2D._instance;


    var _initialize = function() {
        this.isSafari = navigator.userAgent.toLowerCase().match(/safari/) && !navigator.userAgent.toLowerCase().match(/chrome/) ? true : false;
        this.viewState = {};
        this.disabledKeyCodes = {};
    };

    var isSafari = navigator.userAgent.toLowerCase().match(/safari/) && !navigator.userAgent.toLowerCase().match(/chrome/) ? true : false;
    var longNames = {
        'A': 'ALA',
        'R': 'ARG',
        'N': 'ASN',
        'D': 'ASP',
        'B': 'ASX',
        'C': 'CYS',
        'E': 'GLU',
        'Q': 'GLN',
        'Z': 'GLX',
        'G': 'GLY',
        'H': 'HIS',
        'I': 'ILE',
        'L': 'LEU',
        'K': 'LYS',
        'M': 'MET',
        'F': 'PHE',
        'P': 'PRO',
        'S': 'SER',
        'T': 'THR',
        'W': 'TRP',
        'Y': 'TYR',
        'V': 'VAL',
        'DA': 'A',
        'DT': 'T',
        'DU': 'U',
        'DC': 'C',
        'DG': 'G',
        'HOH': 'HOH'
    };

    var shortNames = {
        'ALA': 'A',
        'ARG': 'R',
        'ASN': 'N',
        'ASP': 'D',
        'ASX': 'B',
        'CYS': 'C',
        'GLU': 'E',
        'GLN': 'Q',
        'GLX': 'Z',
        'GLY': 'G',
        'HIS': 'H',
        'ILE': 'I',
        'LEU': 'L',
        'LYS': 'K',
        'MET': 'M',
        'PHE': 'F',
        'PRO': 'P',
        'SER': 'S',
        'THR': 'T',
        'TRP': 'W',
        'TYR': 'Y',
        'VAL': 'V',
        'A': 'A',
        'T': 'T',
        'U': 'U',
        'C': 'C',
        'G': 'G',
        'DA': 'A',
        'DT': 'T',
        'DU': 'U',
        'DC': 'C',
        'DG': 'G',
        'HOH': 'HOH',
        'MG': 'Mg',
        'CL': 'Cl',
        'GLC': 'GLC'
    };

    var fullnames = {
        'ALA': 'Alanine',
        'ARG': 'Arginine',
        'ASN': 'Asparagine',
        'ASP': 'Aspartic Acid',
        'ASX': 'Asparagine/Aspartic Acid',
        'CYS': 'Cysteine',
        'GLU': 'Glutamic Acid',
        'GLN': 'Glutamine',
        'GLX': 'Glutamine/Glutamic Acid',
        'GLY': 'Glycine',
        'HIS': 'Histidine',
        'ILE': 'Isoleucine',
        'LEU': 'Leucine',
        'LYS': 'Lysine',
        'MET': 'Methionine',
        'PHE': 'Phenylalanine',
        'PRO': 'Proline',
        'SER': 'Serine',
        'THR': 'Threonine',
        'TRP': 'Tryptophan',
        'TYR': 'Tyrosine',
        'VAL': 'Valine',
        'A': 'Adenine',
        'T': 'Thymine',
        'U': 'Uracil',
        'C': 'Cytosine',
        'G': 'Guanine',
        'DA': 'Adenine',
        'DT': 'Thymine',
        'DU': 'Uracil',
        'DC': 'Cytosine',
        'DG': 'Guanine',
        'HOH': 'Water',
        'MG': 'Magnesium',
        'CL': 'Chlorine',
        'GLC': 'Glucose',
        'HEM': 'Heme'
    };


    var _initializeDivs = function() {
        this.browser = this.app.container.querySelector('#browser-' + app.appID);
        this.inspector = this.app.container.querySelector('#inspectorPanel-' + app.appID);
        this.center = this.app.container.querySelector('#center-' + app.appID);
        this.viewer3d = this.app.container.querySelector('#viewer3d-' + app.appID);
        setViewerSize.call(this);
    };


    var _initializeEvents = function(viewer) {
        var self = this;
    };


    var toggleInspector = function(forceState) {
        if (!isTouchDevice() || window.innerWidth > Autodesk.Viewing.MolViewer.MAX_TABLET_MODE_RESOLUTION) {
            if (forceState === "off") {
                this.obj.hideInspector();
            } else if (forceState === "on") {
                this.obj.showInspector();
            } else {
                if (this.inspector.classList.contains('hide')) {
                    this.obj.showInspector();
                } else {
                    this.obj.hideInspector();
                    return false;
                }
            }
        } else {
            if (forceState === "off") {
                self.inspector.classList.remove('inspector-active');
            } else if (forceState === "on") {
                self.inspector.classList.add('inspector-active');
            } else {
                self.inspector.classList.toggle('inspector-active');
            }
        }

    };

    var toggleBrowser = function() {
        if (this.browser.style.display === 'none') {
            this.obj.showBrowser();
            this.molMan.viewer.fireEvent(Autodesk.Viewing.BROWSER_RESIZED_EVENT);
            return true;
        } else {
            this.obj.hideBrowser();
            return false;
        }
    };

    var selectionChanged = function(event) {
        if (!event.instances[0] || !event.instances[0].selection) {
            return;
        }
        var view,
            views = this.obj.viewRegistry,
            i,
            instance;

        for (view in views) {
            if (views.hasOwnProperty(view)) {
                for (i = 0; i < event.instances.length; i++) {
                    instance = event.instances[i].id ? event.instances[i] : event.instances[i].instance;
                    if (views[view].instance === instance || views[view].type === 'instance') {
                        views[view].itemList.showSelectedItems();
                    }
                }
            }
        }

    };

    var updateOpenStates = function(event) {
        //here we will examine the event type (open/close), the parent object that
        //was clicked, and call the appropriate method
        var parentView = event.parentView,
            parent = event.parent;

        if (event.state === 'closed') {
            this.obj.removeChildView(parentView, parent, true);
        } else {
            this.obj.addChildViews(parentView, parent, true);
        }
    };


    var registerView = function(view) {
        this.obj.viewRegistry[view.id] = view;
    };

    var unRegisterView = function(view) {
        delete this.obj.viewRegistry[view.id];
    };

    var destroyView = function(view, element, selfDestruct) {
        var children;
        if (element) {
            if (this.obj.hasChildView(view, element)) {
                children = this.obj.getChildViews(element, false);
                for (var i = 0; i < children.length; i++) {
                    this.obj.destroyView(children[i], false, true);
                }
            }
        } else {
            if (this.obj.hasChildView(view)) {
                children = this.obj.getChildViews(view, true);
                for (var i = 0; i < children.length; i++) {
                    this.obj.destroyView(children[i], false, true);
                }
            }
        }

        if (selfDestruct && view) {
            view.destroy();
        }
    };


    var hasChildView = function(view, element) {
        if (element) {
            return findViews.call(this,'upstreamElement', element).length > 0;
        } else {
            return findViews.call(this,'upstreamView', view).length > 0;
        }
    };

    var findViews = function(property, value) {
        var view,
            val,
            results = [];

        for (view in this.obj.viewRegistry) {
            if (this.obj.viewRegistry.hasOwnProperty(view)) {
                if (this.obj.viewRegistry[view][property] === value) {
                    results.push(this.obj.viewRegistry[view]);
                }
            }
        }
        return results;
    };

    var getChildViews = function(obj, isView) {
        if (isView) {
            return findViews.call(this,'upstreamView', obj);
        }
        return findViews.call(this,'upstreamElement', obj);
    };

    var getRootView = function() {
        var views = this.obj.listViewData,
            view;
        for (view in views) {
            if (views.hasOwnProperty(view)) {
                if (views[view].isRoot) {
                    return view;
                    break;
                }
            }
        }
    };

    var getDownstreamView = function(viewType) {
        var views = this.obj.listViewData,
            view;
        for (view in views) {
            if (views.hasOwnProperty(view)) {
                if (view === viewType) {
                    return views[view].downstreamViewType;
                }
            }
        }
        return null;
    };

    var getUpstreamView = function(viewType) {
        var views = this.listViewData,
            view;
        for (view in views) {
            if (views.hasOwnProperty(view)) {
                if (views[view].upstreamView === viewType) {
                    return view;
                }
            }
        }
        return null;
    };

    //add a child view
    var addView = function(viewName, passedArgs, register) {
        var args = this.obj.getArgsFromName(this.obj.listViewData, viewName),
            ViewObj,
            newView,
            container,
            panelView,
            event;

        if (!args) {
            return;
        }
        args.viewType = viewName;
        args.app = this.app;
        var arg;
        for (arg in passedArgs) {
            if (passedArgs.hasOwnProperty(arg)) {
                args[arg] = passedArgs[arg];
            }
        }
        ViewObj = this.obj.parseObjectName(args.viewObject);
        newView = new ViewObj(args);
        container = this.app.container.querySelector(args.container);
        panelView = this.obj.getTopView(args.panelView);
        if (register) {
            this.obj.registerView(newView);
        }

        if (panelView.minimized) { //expand minimized panel when adding a child
            panelView.restoreView();
        }

        this.obj.appendView(panelView[args.container], newView);
        panelView.setWrapperHeight();
        this.app.MoleculeViewer.fireEvent({type: Autodesk.Viewing.BROWSER_RESIZED_EVENT});

        //synthetic scroll event
        event = new MouseEvent('scroll', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });

        //here we scroll the element into view and  update the custom scrollbar
        event.deltaY = newView.el.offsetTop - 30;
        panelView.el.querySelector('.browser-wrapper').scrollTop = event.deltaY;
        panelView.el.querySelector('.browser-wrapper').dispatchEvent(event);
        this.app.MoleculeViewer.fireEvent({type: Autodesk.Viewing.VIEW_CREATED_EVENT, panelType: panelView.type});
        return newView;
    };

    var appendView = function(container, view) {
        var i,
            j,
            divs = container.querySelectorAll('.' + view.el.className),
            testArray,
            valArray;

        if (view.el.querySelector('.title')) {

            valArray = view.el.querySelector('.title').textContent.split(' ');

            for (i = 0; i < divs.length; i++) {
                if (view.el.querySelectorAll('.title').length === 2) { // this one has 2 titles
                    if (divs[i].querySelectorAll('.title')[1].textContent >= view.el.querySelectorAll('.title')[1].textContent &&
                        parseInt(divs[i].querySelectorAll('.title')[0].textContent.split(' ')[1], 10) > parseInt(view.el.querySelectorAll('.title')[0].textContent.split(' ')[1], 10)) {
                        container.insertBefore(view.el, divs[i]);
                        return;
                    }
                } else {
                    testArray = divs[i].querySelector('.title').textContent.split(' ');

                    for (j = 0; j < testArray.length; j++) {
                        if (isNaN(parseInt(testArray[j], 10))) {
                            if (testArray[j] > valArray[j]) {
                                container.insertBefore(view.el, divs[i]);
                                return;
                            }
                        } else {
                            if (parseInt(testArray[j], 10) > parseInt(valArray[j], 10)) {
                                container.insertBefore(view.el, divs[i]);
                                return;
                            }
                        }
                    }
                }
            }
        }
        container.appendChild(view.el);
    };



    var _bindEvents = function() {
        delete this.eventQueue;
        this.createEventQueue.call(this);
        this.viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_UPDATE, self.selectionChanged);
        this.viewer.addEventListener(Autodesk.Viewing.OPENSTATE_CHANGE_EVENT, self.updateOpenStates);
        this.viewer.addEventListener(Autodesk.Nano.MODEL_DELETED_EVENT, self.destroyRootViewsBind);

    };

    var _unbindEvents = function() {
        self.viewer.removeEventListener(Autodesk.Viewing.SELECTION_CHANGED_UPDATE, self.selectionChanged);
        self.viewer.removeEventListener(Autodesk.Viewing.OPENSTATE_CHANGE_EVENT, self.updateOpenStates);
        self.viewer.removeEventListener(Autodesk.Nano.MODEL_DELETED_EVENT, self.destroyRootViewsBind);
    };




    var createEventQueue = function() {
        return new Autodesk.Nano.EventQueue(this.getViewer(), this.obj.selectionChangedUpdate, 150, Autodesk.Viewing.SELECTION_CHANGED_EVENT, false);
    };

    var getInstanceFromID = function(id) {
        var instances = this.molMan.molModels[this.molMan.currentMolModelID].activeInstances,
            i,
            instance = null;
        for (i = 0; i < instances.length; i++) {
            if (instances[i].id === id) {
                instance = instances[i];
                i = instances.length;
            }
        }
        return instance;
    };

    var getInstanceIndexFromID = function(id) {
        var self = this;
        var instances = self.molMan.molModels[self.molMan.currentMolModelID].activeInstances,
            i;
        for (i = 0; i < instances.length; ++i) {
            if (instances[i].id === id) {
                return i;
            }
        }
        return -1;
    };

    var getBitSetIDs = function(atoms) {
        var j,
            results = [],
            len = this.molMan.molModels[this.molMan.currentMolModelID].molMetadata.atoms.length;  //bitSet.size is longer than # of atoms
        for (j = 0; j < len; j++) {
            results.push(j);
        }
        return results;
    };

    var getBitSetSelected = function(atoms) {
        var j,
            results = [],
            len = atoms.size;
        for (j = 0; j < len; j++) {
            if (atoms.get(j)) {
                results.push(j);
            }
        }
        return results;
    };

    var getBitSetAll = function(atoms) {
        var j,
            results = [],
            len = atoms.size;
        for (j = 0; j < len; j++) {
            results.push(j);
        }
        return results;
    };

    var clearBitSetSelected = function(atoms, selected) {
        var j;
        for (j = 0; j < selected.length; j++) {
            if (atoms.get(selected[j])) {
                atoms.set(selected[j], 0);
            }
        }
    };

    var clearBitSet = function(atoms) {
        atoms.clear();
    };

    var getShortName = function(residue) {
        return this.obj.shortNames[residue];
    };


    var getLongName = function(residue) {
        return this.obj.longNames[residue];
    };

    var getFullName = function(residue) {
        return this.obj.fullnames[residue];
    };
    var showInspector = function() {
        var viewcube = this.app.container.querySelector('.viewcube');
        var guiviewer3d = this.app.container.querySelector('#guiviewer3d-toolbar');

        this.inspector.classList.remove('hide');
        this.obj.setViewerSize();
        if (viewcube) {
            viewcube.classList.remove('no-inspector');
        }
        if (guiviewer3d) {
            guiviewer3d.classList.remove('no-inspector');
        }
    };


    var hideInspector = function() {
        var that = this;
        var viewcube = this.app.container.querySelector('.viewcube');
        var guiviewer3d = this.app.container.querySelector('#guiviewer3d-toolbar');


        that.inspector.classList.add('hide');
        that.obj.setViewerSize();

        if (viewcube) {
            viewcube.classList.add('no-inspector');
        }
        if (guiviewer3d) {
            guiviewer3d.classList.add('no-inspector');
        }
    };


    var showBrowser = function() {
        var bv = this.obj.getTopView('BrowserView');
        var isSafari = navigator.userAgent.toLowerCase().match(/safari/);
        if (isSafari) {
            this.browser.style.display = '-webkit-flex';
        } else {
            this.browser.style.display = 'flex';
        }
        bv.updateWidth();
    };


    var hideBrowser = function() {
        this.browser.style.display = 'none';
        this.obj.setViewerSize();
    };

    var showMacro = function() {
        var that = this;
        that.macro.style.display = 'flex';
        that.obj.setViewerSize();
    };


    var hideMacro = function() {
        var that = this;
        that.macro.style.display = 'none';
        that.obj.setViewerSize();
    };


    var setViewerSize = function(args) {
        var that = this,
            browserWidth,
            resizerWidth,
            inspectorWidth,
            offsetWidth;
        if (!that.browser) {
            that.browser = that.app.container.querySelector('#browser-' + that.app.appID);
            that.inspector = that.app.container.querySelector('#inspectorPanel-' + that.app.appID);
            that.center = that.app.container.querySelector('#center-' + that.app.appID);
            that.viewer3d = that.app.container.querySelector('#viewer3d-' + that.app.appID);
        }

        if (args) {
            browserWidth = args.browserWidth;
            resizerWidth = args.resizerWidth;
            inspectorWidth = args.inspectorWidth;
        } else {
            browserWidth = that.browser ? that.browser.clientWidth : 0;
            resizerWidth = that.browser && that.browser.nextSibling.classList.contains('resize-column') ? that.browser.nextSibling.clientWidth : 0;
            inspectorWidth = that.inspector ? that.inspector.clientWidth : 0;
        }


        //var offsetWidth = this.browser.clientWidth + this.browser.nextSibling.clientWidth + this.inspector.clientWidth;
        offsetWidth = browserWidth + resizerWidth + inspectorWidth;
        if (that.isSafari) {
            that.center.style.width = '-webkit-calc(100% - ' + Math.max(0, (offsetWidth - 10)) + 'px)';
            that.viewer3d.style.height = '100%';
        } else {
            that.center.style.width = 'calc(100% - ' + Math.max(0, (offsetWidth - 10)) + 'px)';
            that.viewer3d.style.height = '100%';
        }

        if (that.app.MoleculeViewer.impl) {
            that.app.MoleculeViewer.resize();
        }
    };


    var updateViewer = function(viewer, svfURL) {
        var view;
        this.viewer = viewer;
        this._bindEvents();
        this.molViewer.updateMolViewer(viewer);
        for (view in this.topViews) {
            if (this.topViews.hasOwnProperty(view)) {
                if (this.topViews[view].viewer) {
                    this.topViews[view].updateViewer(viewer);
                }
                if (this.topViews[view].svfName) {
                    this.topViews[view].updateSvfName("Pending");
                }
            }
        }

        this.addView(ViewManager.getRootView(), {viewer: viewer, upstreamElement: null}, true);
        TheAnnotateMan.updateViewer(viewer);
    };


//get the top view and list view data from the temporary Autodesk.Viewing.topViewData object
    var parseTopViewData = function() {
        var view;
        this.app.ViewManager.topViewData = Autodesk.Viewing.topViewData.views;
        this.app.ViewManager.listViewData = Autodesk.Viewing.topViewData.listViews;
        this.app.ViewManager.topViewManifest = Autodesk.Viewing.topViewData.manifest;
        delete Autodesk.Viewing.topViewData;
    };

    var createTopView = function(viewName, passedArgs) {
        var args = getArgsFromName(this.app.ViewManager.topViewData, viewName),
            viewObj,
            view;

        if (!args) {
            return;
        }
        args.type = viewName;
        args.app = app;
        if (!args.insertTarget) {
            args.insertElement += '-' +app.appID;
        }
          if (args.parentElement !== 'body') {
            args.parentElement += '-' + app.appID;
        }

        var arg;
        for (arg in passedArgs) {
            if (passedArgs.hasOwnProperty(arg)) {
                args[arg] = passedArgs[arg];
            }
        }
        viewObj = parseObjectName(args.viewObject);
        view = new viewObj(args);
        registerTopView.call(this,view);
        return true;
    };


    var parseObjectName = function(objectName) {
        var nsArray = objectName.split('.');
        var i;
        var obj = window[nsArray[0]];
        for (i = 1; i < nsArray.length; i++) {
            obj = obj[nsArray[i]];
        }
        return obj;
    };

    var getArgsFromName = function(viewsObject, viewName) {
        var view;
        for (view in viewsObject) {
            if (viewsObject.hasOwnProperty(view)) {
                if (view === viewName) {
                    return viewsObject[view];
                }
            }
        }
        return {};
    };


    var registerTopView = function(view) {
        this.obj.topViews[view.type] = view;
    };

    var getTopView = function(viewType) {
        return this.obj.topViews[viewType];
    };

    var getTopViews = function() {
        return this.obj.topViews;
    };

    var destroyTopView = function(view) {
        var topview;
        for (topview in this.obj.topViews) {
            if (this.obj.topViews.hasOwnProperty(topview)) {
                if (this.obj.topViews[topview] === view) {
                    delete this.obj.topViews[topview];
                }
            }
        }
    };

    var destroyRootViews = function() {
        var rootViews = this.obj.findViews('isRoot', true);
        var i;
        for (i = 0; i < rootViews.length; i++) {
            this.obj.destroyView(rootViews[i], false, true);
        }
    };

    //var destroyRootViewsBind = destroyRootViews.bind(this);

    var addStyleSheet = function(name) {
        var sheet = document.querySelector('#' + name);
        if (sheet) {
            return;
        }
        var head = document.querySelector('head');
        var link = document.createElement('link');
        link.id = name;
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/' + name + '.css';
        link.media = 'all';
        head.appendChild(link);
    };

    var clearOtherViews = function(view) {
        var obj;

        for (obj in this.obj.viewRegistry) {
            if (this.obj.viewRegistry.hasOwnProperty(obj)) {
                if (view.type !== this.obj.viewRegistry[obj].type) {
                    this.obj.viewRegistry[obj].selection = [];
                }
            }

        }
    };

    var setSelectionFromViews = function() {
        var view,
            instance,
            instances = {},
            instanceArray = [],
            i;

        for (view in this.obj.viewRegistry) {
            if (this.obj.viewRegistry.hasOwnProperty(view)) {
                if (this.obj.viewRegistry[view].selection.length > 0) {
                    if (this.obj.viewRegistry[view].upstreamView) {


                        instance = this.obj.viewRegistry[view].instance;
                        if (!instances[instance.id]) {
                            instances[instance.id] = {};
                            instances[instance.id].instance = instance;
                            instances[instance.id].what = {};
                        }

                        if (instances[instance.id].what[this.obj.viewRegistry[view].type]) {
                            instances[instance.id].what[this.obj.viewRegistry[view].type] = instances[instance.id].what[this.obj.viewRegistry[view].type].concat(this.obj.viewRegistry[view].selection);
                        } else {
                            instances[instance.id].what[this.obj.viewRegistry[view].type] = this.obj.viewRegistry[view].selection;
                        }
                    } else { //instance view is special...
                        for (i = 0; i < this.obj.viewRegistry[view].selection.length; i++) {
                            if (!instances[this.obj.viewRegistry[view].selection[i]]) {
                                instances[this.obj.viewRegistry[view].selection[i]] = {};
                                instances[this.obj.viewRegistry[view].selection[i]].instance = this.molMan.molModels[this.molMan.currentMolModelID].getInstanceFromID(this.obj.viewRegistry[view].selection[i]);
                                instances[this.obj.viewRegistry[view].selection[i]].what = {instance: [this.obj.viewRegistry[view].selection[i]]};
                            }
                        }
                    }
                }


            }
        }

        for (instance in instances) {
            if (instances.hasOwnProperty(instance)) {
                instanceArray.push(instances[instance]);
            }
        }

        this.molMan.molModels[this.molMan.currentMolModelID].select(instanceArray, false);
    };

//This method is triggered by this.eventQueue after its timeout expires.
//The views listen to SELECTION_CHANGED_UPDATE instead of SELECTION_CHANGED_EVENT
//in order to cut down on the number of view re-renderings
    var selectionChangedUpdate = function(event) {
        var newEvent = {
            type: Autodesk.Viewing.SELECTION_CHANGED_UPDATE,
            instances: event.instances
        };
        if (this.app.MoleculeViewer && this.app.MoleculeViewer.canvas) { //added this since when we clean up this timed event may want to be thrown with an old viewer.
            this.app.MoleculeViewer.fireEvent(newEvent);
        }
    };

    var isUpstreamView = function(view, testView) {
        if (testView === view.upstreamView) {
            return true;
        } else if (testView.upstreamView === null) {
            return false;
        } else {
            this.isUpstreamView(view, testView.upstreamView);
        }
    };


    var markUpstreamElements = function(view, unMark) {
        var upstreamElement = view.upstreamElement;
        var upstreamView = view.upstreamView;
        if (upstreamElement) {
            if (unMark) {
                upstreamElement.parentNode.classList.remove('parent');
            } else {
                upstreamElement.parentNode.classList.add('parent');
            }
        }
        if (upstreamView) {
            this.markUpstreamElements(upstreamView, unMark);
        }
    };

    var setViewState = function(configViews) {
        var self = this;
        this.viewState = configViews;

        if (configViews.hideBrowser) {
            self.app.container.querySelector('#browser-' + app.appID).style.display = 'none';
        }

        if (configViews.hideInspector) {
            self.app.container.querySelector('#inspectorPanel-' + app.appID).classList.add('hide');
        }

        if (configViews.disableBrowser) {
            self.app.container.querySelector('#browser-' + app.appID).style.display = 'none';
            self.app.container.querySelectorAll('.open-button')[0].style.display = 'none';
            self.obj.disabledKeyCodes[66] = true;
            self.obj.disabledKeyCodes[98] = true;
        }

        if (configViews.disableInspector) {
            self.app.container.querySelector('#inspectorPanel-' + app.appID).classList.add('hide');
            self.app.container.querySelectorAll('.open-button')[1].style.display = 'none';
            self.obj.disabledKeyCodes[73] = true;
            self.obj.disabledKeyCodes[105] = true;
        }

        if (configViews.hideHeader) {
            self.app.container.querySelector('#header-' + app.appID).classList.add('hidden');
            self.app.container.querySelector('#main-' + app.appID).style.height = '100%';
        }
    };


//return true if keyCode is not in the disabledKeyCodes object
    var checkKeyCode = function(keyCode) {
        var self = this;
        var key;
        for (key in self.obj.disabledKeyCodes) {
            if (self.obj.disabledKeyCodes.hasOwnProperty(key)) {
                if (parseInt(key, 10) === keyCode) {
                    return false;
                }
            }
        }
        return true;
    };

    var getViewer = function() {
        return app.MoleculeViewer;
    };

    _initialize();
    _initializeEvents(app.MoleculeViewer);
    app.MoleculeViewer.addEventListener(Autodesk.Viewing.INSPECTOR_LOADED, _initializeDivs);


    this.topViewData = {};

    //view registration objects
    this.viewRegistry = {};

    //top view registry
    this.topViews = {};



    this.obj ={
        fullnames: fullnames,
        longNames: longNames,
        shortNames: shortNames,
        toggleBrowser: toggleBrowser.bind(this),
        toggleInspector: toggleInspector.bind(this),
        selectionChanged: selectionChanged.bind(this),
        updateOpenStates: updateOpenStates.bind(this),
        registerView: registerView.bind(this),
        unRegisterView: unRegisterView.bind(this),
        destroyView: destroyView.bind(this),
        hasChildView: hasChildView.bind(this),
        findViews: findViews.bind(this),
        getChildViews: getChildViews.bind(this),
        getRootView: getRootView.bind(this),
        getDownstreamView: getDownstreamView.bind(this),
        getUpstreamView: getUpstreamView.bind(this),
        addView: addView.bind(this),
        appendView: appendView.bind(this),
        //createEventQueue: createEventQueue.bind(this),
        getInstanceFromID: getInstanceFromID.bind(this),
        getInstanceIndexFromID: getInstanceIndexFromID.bind(this),
        getBitSetIDs: getBitSetIDs.bind(this),
        getBitSetSelected: getBitSetSelected.bind(this),
        clearBitSetSelected: clearBitSetSelected.bind(this),
        clearBitSet: clearBitSet.bind(this),
        getShortName: getShortName.bind(this),
        getLongName: getLongName.bind(this),
        getFullName: getFullName.bind(this),
        showInspector: showInspector.bind(this),
        hideInspector: hideInspector.bind(this),
        showBrowser: showBrowser.bind(this),
        hideBrowser: hideBrowser.bind(this),
        showMacro: showMacro.bind(this),
        hideMacro: hideMacro.bind(this),
        setViewerSize: setViewerSize.bind(this),
        updateViewer: updateViewer.bind(this),
        parseTopViewData: parseTopViewData.bind(this),
        createTopView: createTopView.bind(this),
        parseObjectName: parseObjectName.bind(this),
        getArgsFromName: getArgsFromName.bind(this),
        registerTopView: registerTopView.bind(this),
        getTopView: getTopView.bind(this),
        getTopViews: getTopViews.bind(this),
        destroyTopView: destroyTopView.bind(this),
        destroyRootViews: destroyRootViews.bind(this),
        addStyleSheet: addStyleSheet.bind(this),
        clearOtherViews: clearOtherViews.bind(this),
        setSelectionFromViews: setSelectionFromViews.bind(this),
        selectionChangedUpdate: selectionChangedUpdate.bind(this),
        isUpstreamView: isUpstreamView.bind(this),
        markUpstreamElements: markUpstreamElements.bind(this),
        setViewState: setViewState.bind(this),
        checkKeyCode: checkKeyCode.bind(this),
        isSafari: isSafari,
        eventQueue: {},
        disabledKeyCodes: {},
        topViews: this.topViews,
        listViewData: this.listViewData,
        topViewManifest: this.topViewManifest,
        viewRegistry: {},
        destroyRootViewsBind: destroyRootViews.bind(this)
    };

    var eventQueueBind = createEventQueue.bind(this);
    this.obj.eventQueue = eventQueueBind();
    //var destroyRootViewsBind = thereturn.destroyRootViews.bind(thereturn);
    app.MoleculeViewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_UPDATE, this.obj.selectionChanged);
    app.MoleculeViewer.addEventListener(Autodesk.Viewing.OPENSTATE_CHANGE_EVENT, this.obj.updateOpenStates);
    app.MoleculeViewer.addEventListener(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED, this.obj.destroyRootViewsBind);
    app.MoleculeViewer.addEventListener(Autodesk.Nano.MODEL_DELETED_EVENT, this.obj.destroyRootViewsBind);

    return this.obj;

};;// set up namespace...
Autodesk.Viewing.MolViewer = Autodesk.Viewing.MolViewer || {};


/**
 * constructor for MolViewerMan
 * @param {object} viewer - the 3DViewer object.
 */
Autodesk.Viewing.MolViewer.AnnotateMan = function(app) {
    var _app = app;
    var _molMan = app.MolMan;
    var _viewer = app.MoleculeViewer;
    var _loader = app.Loader;
    var _annotations = [];
    var _that = this;
    var _shown = false;

    function onCameraChange() {
        _that.updateLabelPositions();
    }

    function onModelDeleted(event) {
        var i;
        for (i = 0; i < _annotations.length; ++i) {
            if (_annotations[i].modelID === event.id) {
                _that.removeAnnotationById(_annotations[i].id);
                i -= 1;
            }
        }
    }

    function onExplodeChange() {
        var annotations;
        if (_molMan.instances.length === 0) {
            return;
        }
        if (_that.annotationType === 'caption') {
            return; //captions don't listen to this event
        }

        annotations = _that.getAnnotationsByType('annotation');

        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var selectedInstances = annotation.selectedInstances;

            for (var j = 0; j < selectedInstances.length; j++) {
                var id = selectedInstances[j];
                var instance = _molMan.getInstance(id);
                var isForAssembly = instance.isForAssembly();
                //mz may need to rework this..
                if (isForAssembly) {
                    var explodeOffset = instance.explodeOffset;
                    annotation.xyzPoint.x = annotation.xyzOrigPoint.x + explodeOffset.x;
                    annotation.xyzPoint.y = annotation.xyzOrigPoint.y + explodeOffset.y;
                    annotation.xyzPoint.z = annotation.xyzOrigPoint.z + explodeOffset.z;
                }
                else if (instance.entityExplodeOffsets != null) {
                    var explodeOffset = instance.entityExplodeOffsets[annotation.entityID];
                    annotation.xyzPoint.x = annotation.xyzOrigPoint.x + explodeOffset.x;
                    annotation.xyzPoint.y = annotation.xyzOrigPoint.y + explodeOffset.y;
                    annotation.xyzPoint.z = annotation.xyzOrigPoint.z + explodeOffset.z;
                }
            }
        }

        _that.updateLabelPositions();

        /*
         _that.deactivateAnnotateMode();
         _that.showAnnotations(false);
         */
    }

    function onReset() {
        _that.deactivateAnnotateMode();
        _that.clearAnnotations();
    }

    function onSelection() {
        var annotate = {
            id: 'C' + THREE.Math.generateUUID(),
            type: 'annotation',
            string: null,
            xyzPoint: null,
            xyzOrigPoint: null,
            selectedInstances: null,
            entityID: null,
            xOffset: 0,
            yOffset: 0,
            label: null,
            clientWidth: 0,
            clientHeight: 0,
            x: 0,
            y: 0,
            width: null,
            height: null
        };
        _that.addAnnotation(annotate, true);
    }

    function addMainCaption() {
        var caption = {
            id: 'C' + THREE.Math.generateUUID(),
            type: 'caption',
            string: null,
            xyzPoint: null,
            xyzOrigPoint: null,
            selectedInstances: null,
            entityID: null,
            label: null,
            clientWidth: 0,
            clientHeight: 0,
            x: '1',
            y: '2',
            width: null,
            height: '50'
        };
        _that.addAnnotation(caption, false);
    }

    function addLabel(annotate) {
        var label, textarea, close, arrow;
        label = annotate.label = document.createElement('div');
        label.setAttribute('class', 'atom-label annotate');
        if (_shown) {
            label.classList.add('visible');
        }
        arrow = document.createElement('div');
        arrow.className = "arrow";
        label.appendChild(arrow);
        textarea = document.createElement('textarea');
        textarea.className = "annotate";
        if (annotate.string) {
            textarea.value = annotate.string;
        } else {
            textarea.placeholder = "Type something";
        }
        textarea.setAttribute('autofocus', 'true');
        textarea.setAttribute('spellcheck', 'false');
        textarea.addEventListener('keyup', function () {
            textarea.style.height = '20px';
            textarea.style.height = textarea.scrollHeight + 'px';
        });
        textarea.addEventListener('change', function () {
            textarea.style.height = '20px';
            textarea.style.height = textarea.scrollHeight + 'px';
        });
        label.appendChild(textarea);
        close = document.createElement('div');
        close.className = "close-annotate";
        close.id = "close-annotate";
        close.setAttribute('data-annotate-id', annotate.id);
        close.addEventListener('click', function (event) {
            deleteAnnotation(event);
        });
        label.appendChild(close);

        _viewer.container.appendChild(label);
        textarea.style.height = '20px';
        textarea.style.height = textarea.scrollHeight + 'px';
        textarea.focus();
        _annotations.push(annotate);
    }

    function dragStart(event) {
        event.dataTransfer.setData('text/plain', this.id);
        event.dataTransfer.effectAllowed = 'move';
        this.y1 = event.clientY;
        this.x1 = event.clientX;
    }

    //here we need to differentiate based on view type (i.e. desktop/gallery, mobile/presentation)
    function addCaption(caption) {
        var label, textarea, close, topBar, width, parentElement,
            isPresentation = (_loader.options && _loader.options.topViews) === 'presentation';


        label = caption.label = document.createElement('div');
        label.setAttribute('id', caption.id);
        label.setAttribute('class', 'atom-label caption');

        textarea = document.createElement('textarea');
        textarea.className = "caption";
        if (caption.string) {
            textarea.value = caption.string;
        } else {
            textarea.placeholder = "Enter caption";
        }

        if (_shown) {
            label.classList.add('visible');
        }

        if (isPresentation) {
            label.appendChild(textarea);
            parentElement = app.ViewManager.getTopView('StateView').captionDiv;
            parentElement.appendChild(label);
        } else {

            label.style.top = caption.y + '%';
            label.style.left = caption.x + '%';

            label.setAttribute('draggable', 'true');

            topBar = document.createElement('div');
            topBar.setAttribute('class', 'caption-bar');
            label.appendChild(topBar);

            textarea.setAttribute('autofocus', 'true');
            textarea.setAttribute('spellcheck', 'false');
            if (caption.height) {
                textarea.style.height = caption.height;
            }
            if (caption.width) {
                textarea.style.width = caption.width;
            } else {
                width = (_viewer.container.clientWidth - (_viewer.viewCubeUi && _viewer.viewCubeUi.viewcube ? 160 : 40)) + 'px';
                label.style.maxWidth = width;
                textarea.style.maxWidth = width;
                textarea.style.width = width;
            }
            textarea.addEventListener('keyup', function () {
                textarea.style.height = '20px';
                textarea.style.height = textarea.scrollHeight + 'px';
            });
            textarea.addEventListener('change', function () {
                textarea.style.height = '20px';
                textarea.style.height = textarea.scrollHeight + 'px';
            });

            textarea.addEventListener('dragstart', function (event) {
                event.stopPropagation();
            });
            textarea.addEventListener('drag', function (event) {
                event.stopPropagation();
            });

            label.appendChild(textarea);
            label.addEventListener('click', function (event) {
                //event.stopPropagation();
            });

            _that.dragStartBind = dragStart.bind(label);

            label.addEventListener('dragstart', _that.dragStartBind);

            _viewer.container.addEventListener('dragover', function (event) {
                event.preventDefault();
            });

            label.addEventListener('dragend', function (event) {
                event.stopPropagation();
            });
            if (!_viewer.container.hasListener) {
                _viewer.container.addEventListener('drop', function (event) {
                    event.preventDefault();
                    var top;
                    var left;
                    var canvasHeight = _viewer.container.querySelector('#canvas3D').clientHeight;
                    var canvasWidth = _viewer.container.querySelector('#canvas3D').clientWidth;
                    var annotationId = event.dataTransfer.getData('text/plain');
                    var obj = _viewer.container.querySelector('#' + annotationId);

                    if (obj.style.top.match(/.*\%$/)) {
                        top = (parseFloat(obj.style.top) * canvasHeight) / 100;
                        left = (parseFloat(obj.style.left) * canvasWidth) / 100;
                    } else {
                        top = parseInt(obj.style.top, 10);
                        left = parseInt(obj.style.left, 10);
                    }


                    obj.style.top = (((top + (event.clientY - obj.y1)) * 100) / canvasHeight) + '%';
                    obj.style.left = (((left + (event.clientX - obj.x1)) * 100) / canvasWidth) + '%';
                    _that.updateAnnotation(annotationId, 'x', ((left + (event.clientX - obj.x1)) * 100) / canvasWidth);
                    _that.updateAnnotation(annotationId, 'y', ((top + (event.clientY - obj.y1)) * 100) / canvasHeight);
                });
                _viewer.container.hasListener = true;
            }


            close = document.createElement('div');
            close.className = "close-annotate";
            close.id = "close-annotate";
            close.setAttribute('data-annotate-id', caption.id);
            close.addEventListener('click', function (event) {
                deleteAnnotation(event);
                event.stopPropagation(); // so in closing we don't open a new one...
            });
            label.appendChild(close);

            _viewer.container.appendChild(label);
            textarea.style.height = textarea.scrollHeight + 'px';
            textarea.focus();

        }
        _annotations.push(caption);
        updateTitleWidth();
    }



    function deleteAnnotation(event) {
        //_that.removeNthAnnotation(event.target.dataset.annotateId);
        _that.removeAnnotationById(event.target.dataset.annotateId);
    }

    function clearAnnotations() {
        _that.clearAnnotations();
    }

    function updateTitleWidth() {
        var viewerWidth = _viewer.container.clientWidth,
            offsetWidth = (_loader.options && _loader.options.topViews === 'presentation') ? 25 : 150,
            maxWidth = (viewerWidth - offsetWidth),
            i,
            newWidth,
            annotation,
            textArea;

        for (i = 0; i < _annotations.length; ++i) {
            annotation = _annotations[i];
            if (annotation.type === 'caption') {

                newWidth =  (maxWidth - annotation.label.offsetLeft);
                textArea = annotation.label.querySelector('textarea');
                // Without this conditional the title will auto-size
                // not sure if this is the desired behavior or not; for now will leave auto-size on - ajk
                //if (annotation.label.clientWidth + annotation.label.offsetLeft > maxWidth) {
                    textArea.style.width = '200px';
                    textArea.style.width = (newWidth - 2) + 'px';
                //}

                textArea.style.maxWidth = (newWidth - 2) + 'px';

                annotation.label.style.maxWidth = newWidth + 'px';

                textArea.style.height='20px';
                textArea.style.height = textArea.scrollHeight+'px';


            }
        }
    }

    _viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, updateTitleWidth);
    _viewer.addEventListener(Autodesk.Nano.MODEL_DELETED_EVENT,clearAnnotations);

    function unbindEvents() {
        _viewer.removeEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT,clearAnnotations);
        _viewer.removeEventListener(Autodesk.Nano.MODEL_DELETED_EVENT,clearAnnotations);
        _viewer.removeEventListener(Autodesk.Viewing.SELECTION_CHANGED_UPDATE, onSelection);
        _viewer.removeEventListener(Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT, stateRestoredCBBind);
        _viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, updateTitleWidth);
    }

    function bindEvents() {
        _viewer.addEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT,clearAnnotations);
        _viewer.addEventListener(Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT, stateRestoredCBBind);
        _viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, updateTitleWidth);
        _viewer.addEventListener(Autodesk.Nano.MODEL_DELETED_EVENT,clearAnnotations);
    }




    this.setAnnotationType = function setAnnotationType(type) {
        _that.annotationType = type;
    };

    //clear annotations when changing assemblies
    _viewer.addEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT,clearAnnotations);

    this.updateViewer = function updateViewer(viewer){
        unbindEvents();
        _viewer = viewer;
        this.clearAnnotations();
        bindEvents();

    };


    /**
     * This needs to be called first to turn on the annotation and register it's events.
     * @param fromJSON (string) - true if this is being called from fromJsonObj
     */
    this.activate = function activate(fromJSON) {
        var annotations = _that.getAnnotationsByType(_that.annotationType);
        var i;
        this.showAnnotations(true);
        if(_that.annotationType === 'annotation') {
            _viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_UPDATE, onSelection);
        }


        if (annotations.length > 0) {
            for (i = 0; i < annotations.length; ++i) {
                annotations[i].label.querySelector('.close-annotate').classList.remove('hide');
                annotations[i].label.querySelector('.close-annotate').addEventListener('click', function(event) {deleteAnnotation(event);});
                if (_that.annotationType === 'caption') {
                    annotations[i].label.classList.remove('inactive');
                }
            }
        }
        if (_that.annotationType === 'annotation') {
            this.updateLabelPositions();
        } else {
            if (annotations.length === 0 && !fromJSON) {
                addMainCaption();
            }
        }

        this.enableEdit();
    };

    /**
     * This will deactivate annotate mode but not turn off existing annotation.
     */
     this.deactivateAnnotateMode = function deactivateAnnotateMode () {
         var annotations;
         if (_that.annotationType) {
             annotations = _that.getAnnotationsByType(_that.annotationType);
         } else {
             annotations = _annotations;
         }


         var i;

         for (i = 0; i < annotations.length; ++i) {
             if(annotations[i].label.querySelector('.close-annotate')) {
                 annotations[i].label.querySelector('.close-annotate').classList.add('hide');
                 annotations[i].label.querySelector('.close-annotate').removeEventListener('click', function(event) {deleteAnnotation(event);});
             }

             if (annotations[i].type === 'caption') {
                 annotations[i].label.classList.add('inactive');
             }
         }

        this.disableEdit();
        _viewer.removeEventListener(Autodesk.Viewing.SELECTION_CHANGED_UPDATE, onSelection);

     };



    /**
     * Add an annotation
     * @param annotate  The annotate object that contains the following values:
     *   string  The string for the annotation label
     *   xyzPoint  xyz coordinates of the selection
     *   xOffset:  x-offset. If not following the x pixel position of the object, note -x means from the right side. If following, an x offset
     *             added onto the calculated position.
     *   yOffset:  y-offset. If not following the y pixel position of the object, note -y means from the bottom. If following, an y offset
     *             added onto the calculated position.
     * @param useSelection  Whether or not to use the current selection. If true and something is selected, the label will follow the average position
     */
    this.addAnnotation = function addAnnotation(annotate, useSelection) {
        var annotations;
        if(useSelection) {
            annotate.xyzPoint = _molMan.getSelectionCenter();
            if(annotate.xyzPoint) {
                annotate.xyzOrigPoint = new THREE.Vector3();
                annotate.xyzOrigPoint.x = annotate.xyzPoint.x;
                annotate.xyzOrigPoint.y = annotate.xyzPoint.y;
                annotate.xyzOrigPoint.z = annotate.xyzPoint.z;
                //annotate.entityID = _molMan.getSelected();
                annotate.selectedInstances = [];
                var selectedInstances = _molMan.selectedInstances;

                for (var i in selectedInstances) {
                    var instance = selectedInstances[i];
                    annotate.selectedInstances.push(selectedInstances[i].id);
                    annotate.modelID = selectedInstances[i].molModel.id;
                    var atoms = instance.atomSelectionState.getSelected();
                    var entityAtoms = instance.molMetadata.entityAtoms;
                    var atomID = atoms[0];
                    annotate.entityID = entityAtoms[atomID];

                }
            }
        }

        if (annotate.xyzPoint) {
            annotations = _that.getAnnotationsByType('annotation');
            if (annotations.length === 0) {
                _viewer.addEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT, onExplodeChange);
                _viewer.addEventListener(Autodesk.Viewing.RESET_EVENT, onReset);
                _viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCameraChange);
                _viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, onCameraChange);
                _viewer.addEventListener(Autodesk.Nano.MODEL_DELETED_EVENT, onModelDeleted);
            }

            addLabel(annotate);
            this.updateLabelPositions();
            onExplodeChange();
        } else if (annotate.type === 'caption') {
            addCaption(annotate);
        }

    };

    /**
     * returns annotations by type.
     * @param {string} type - type (either 'caption' or 'annotation')
     * @returns {Array} Annotations of type.
     */
    this.getAnnotationsByType = function getAnnotationCount(type) {
        var i;
        var output = [];
        for (i = 0; i < _annotations.length; ++i) {
            if (_annotations[i].type === type) {
                output.push(_annotations[i]);
            }
        }
        return output;
    };

    /**
     * returns annotations by id.
     * @param {string} id - id of the annotation object
     * @returns {object} Annotation with id (or false).
     */
    this.getAnnotationById = function getAnnotationById(id) {
        var i;
        for (i = 0; i < _annotations.length; ++i) {
            if(_annotations[i].id === id) {
                return _annotations[i];
            }
        }
        return false;
    };

    /**
     * updates an annotation object.
     * @param {string} id - id of the annotation object
     * @param {string} key - key to update
     * @param {string|float|int|object} value - new value for key
     * @returns {object} Annotation with id (or false).
     */
    this.updateAnnotation = function updateAnnotation(id,key,value) {
        var i;
        var annotation;
        for (i = 0; i < _annotations.length; ++i) {
            if (_annotations[i].id === id) {
                annotation = _annotations[i];
                break;
            }
        }
        if (!annotation) {
            return false;
        }

        if (!annotation[key]) {
            return false;
        }
        annotation[key] = value;
        return true;
    };

    /**
     * Get how many annotations there are.
     * @returns {Number} Number of annotations.
     */
    this.getAnnotationCount = function getAnnotationCount() {
        return _annotations.length;
    };
    /**
     * Get the nth annotation.
     * @param nth {Number} The 0-based index for the annotation to get.
     * @returns {*} Returns the annotation object.
     */
    this.getNthAnnotation = function getNthAnnotation(nth) {
        if (nth >= 0 && nth < _annotations.length) {
            return _annotations[nth];
        }
        return null;
    };
    /**
     * Remove the nth annotation.
     * @param nth {Number} The 0-based index for the annotation to remove.
     */
    this.removeNthAnnotation = function removeNthAnnotation(nth) {
        if (nth >= 0 && nth < _annotations.length) {
            var label = _annotations[nth].label;
            label.parentNode.removeChild(label);
            _annotations.splice(nth, 1);
        }
        this.updateLabelPositions();

        if (_annotations.length === 0) {
            _viewer.removeEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT,onExplodeChange);
            _viewer.removeEventListener(Autodesk.Viewing.RESET_EVENT, onReset);
            _viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCameraChange);
            _viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, onCameraChange);
            _viewer.removeEventListener(Autodesk.Nano.MODEL_DELETED_EVENT, onModelDeleted);

        }

    };

    /**
     * Remove annotations by ID.
     */
    this.removeAnnotationById = function removeAnnotationById(id) {
        for(var i = 0; i < _annotations.length; i++) {
            if (_annotations[i].id == id) {
                this.removeNthAnnotation(i);
                break;
            }
        }
    };
    /**
     * Remove all annotations and hide them.
     */
    this.clearAnnotations = function(){
        //his.showAnnotations(false);
        var label;
        for (var i = 0; i < _annotations.length; ++i) {
            label = _annotations[i].label;
            label.parentNode.removeChild(label);
        }
        _annotations = [];
        _viewer.removeEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT,onExplodeChange);
        _viewer.removeEventListener(Autodesk.Viewing.RESET_EVENT, onReset);
        _viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCameraChange);
        _viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, onCameraChange);
        _viewer.removeEventListener(Autodesk.Nano.MODEL_DELETED_EVENT, onModelDeleted);

    };

    /**
     * Whether or not to show or hide the annotations. By default, once activated, the annotations are shown.
     * @param show {Boolean}  If true show the annotations, if false hide them.
     * @param type {string} - current types are 'annotation' and 'caption'
     */
    this.showAnnotations = function(show) {
        var i;
        if (show != _shown) {
            _shown = show;
            /* for now always on but not a big fan of this, but would require annotations not being shown as default.
            if (show) {
                _viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
            } else {
                _viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

            }*/
            for (i = 0; i < _annotations.length; ++i) {
                var label = _annotations[i].label;
                if(show && _annotations[i].type === _that.annotationType){
                    label.classList.add('visible');
                }else {
                    label.classList.remove('visible');
                }
            }
        }
    };

    this.toJSONObj  = function(){
        var obj ={};
        obj.annotations = [];
        var annotate;
        var textarea;
        var i;
        for (i =0;i<_annotations.length;++i) {
            textarea = _annotations[i].label.querySelector('textarea');
            annotate = {id: _annotations[i].id, type: _annotations[i].type, string: _annotations[i].label.querySelector('textarea').value,
                        xyzPoint: _annotations[i].xyzPoint, xyzOrigPoint: _annotations[i].xyzOrigPoint, xOffset: _annotations[i].xOffset,
                        yOffset: _annotations[i].yOffset, selectedInstances : _annotations[i].selectedInstances, entityID: _annotations[i].entityID,
                        label: null, clientWidth: textarea.clientWidth, clientHeight: textarea.clientHeight,
                        x: _annotations[i].x, y: _annotations[i].y,width: _annotations[i].width, height: _annotations.height};
            obj.annotations.push(annotate);
        }
        obj.shown = _shown;
        return obj;
    };

    this.fromJSONObj = function(obj){
        var anno = obj.annotate;
        this.annotationType = null;
        this.deactivateAnnotateMode();
        _annotations = [];
        if(anno.shown){
            this.activate(true); //pass the fromJSON parameter as true
        }

        for(var i =0;i<anno.annotations.length;++i){
            var annotate = {id: anno.annotations[i].id, type: anno.annotations[i].type, string: anno.annotations[i].string,
                            xyzPoint: anno.annotations[i].xyzPoint, xyzOrigPoint: anno.annotations[i].xyzOrigPoint,
                            xOffset: anno.annotations[i].xOffset, yOffset: anno.annotations[i].yOffset, label: null,
                            selectedInstances: anno.annotations[i].selectedInstances, entityID: anno.annotations[i].entityID,
                            clientWidth: anno.annotations[i].clientWidth, clientHeight: anno.annotations[i].clientHeight,
                            x: anno.annotations[i].x, y: anno.annotations[i].y,width: anno.annotations[i].width, height: anno.annotations[i].height};
            this.addAnnotation(annotate, false);
        }
        this.updateLabelPositions();
        this.deactivateAnnotateMode();
    };

    /**
     * Disable the ability to edit text of the annotations
     */
    this.disableEdit = function() {
        var i, label, textarea;
        var deleteList = [];
        for (i = 0; i < _annotations.length; ++i) {
            label = _annotations[i].label;
            textarea = label.querySelector('textarea');
            textarea.setAttribute('disabled', 'true');
            textarea.style.resize = 'none';
            if(textarea.value.length === 0) {
                deleteList.push(_annotations[i].id);
            }
        }
        for(i = 0; i < deleteList.length; ++i) {
            this.removeAnnotationById(deleteList[i]);
        }
    };

    /**
     * Enable the ability to edit text of the annotations
     */
    this.enableEdit = function() {
        var i,
            label;
        var type = this.annotationType;
        for (i = 0; i < _annotations.length; ++i) {
            if (_annotations[i].type === type) {
                label = _annotations[i].label;
                label.querySelector('textarea').removeAttribute('disabled');
                label.querySelector('textarea').style.resize = 'both';
            }

        }
    };

    //these guys should be made non-public

    this.labelsOverlapDetection = function(label1, label2) {

        var rect1 = label1.getBoundingClientRect();
        var rect2 = label2.getBoundingClientRect();

        //if ((rect2.top <= rect1.bottom && rect2.top >= rect1.top) || (rect2.bottom <= rect1.bottom && rect2.bottom >= rect1.top)) {
        if (rect2.top <= rect1.bottom && rect2.bottom >= rect1.top) {
            if (rect2.right >= rect1.left && rect2.right <= rect1.right) {
                label2.style.left = parseInt(label2.style.left, 10) - (rect2.right - rect1.left) + 'px';
            }
            else if (rect2.left >= rect1.left && rect2.left <= rect1.right) {
                label2.style.left = parseInt(label2.style.left, 10) + (rect1.right - rect2.left) + 'px';
            }
            else if (rect2.left <= rect1.left && rect2.right >= rect1.right) {
                label2.style.left = parseInt(label2.style.left, 10) + (rect1.right - rect2.left) + 'px';
            }
        }
    };



    this.updateLabelPositions = function () {
        if(!_annotations.length){
            return;  //fast exit if needed
        }
        function project(x, y, z) {
            var camera = _viewer.navigation.getCamera(),
                containerBounds = _viewer.navigation.getScreenViewport(),
                p = new THREE.Vector3(x, y, z);

            p = p.project(camera);

            // if the z value of the projected label position is behind the camera
            // then set the x and y coordinates outside of the screen.
            if (Math.abs(p.z) > 1.0 || isNaN(p.z) ) {
                return {x: -2, y: -2};
            }

            return {
                x: Math.round(( p.x + 1) / 2 * containerBounds.width),
                y: Math.round((-p.y + 1) / 2 * containerBounds.height)
            };
        }

        var i, label, a, xOffset, yOffset;
        var containerBounds = _viewer.navigation.getScreenViewport();

        for (i = 0; i < _annotations.length; ++i) {
            a = _annotations[i];
            label = a.label;
            xOffset = a.xOffset;
            yOffset = a.yOffset;
            if(a.xyzPoint) {
                var xy = project(a.xyzPoint.x,a.xyzPoint.y, a.xyzPoint.z ); // TODO: avoid collisions for labels

                // if the projected label position is outside of the screen then hide the annotation.
                if ( xy.x < 0 )  {
                    label.classList.remove('visible');
                } else {
                    label.classList.add('visible');
                    label.style.top = xy.y + yOffset + 'px';
                    label.style.left = xy.x + xOffset + 'px';
                }
            }else{
                if(yOffset < 0){
                    yOffset = containerBounds.height + yOffset;
                }
                if(xOffset < 0){
                    xOffset = containerBounds.width + xOffset;
                }
                label.style.top = yOffset + 'px';
                label.style.left = xOffset + 'px';
            }
        }

        // for (i = 0; i < _annotations.length; i++) {
        //     for (var j = 0; j < i; j++) {
        //         this.labelsOverlapDetection(_annotations[j].label, _annotations[i].label);
        //     }
        // }
    };

    this.stateRestoredCB = function stateRestoredCB(event) {
        if(event.state && event.state.annotate && event.state.annotate.annotations.length > 0) {
            this.fromJSONObj(event.state);
            _viewer.loadedExtensions['Autodesk.Annotate'].enableAnnotateTool(false); //turn off annotation tool when restoring state
        }
    };

    var stateRestoredCBBind = this.stateRestoredCB.bind(this);

    _viewer.addEventListener(Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT,this.stateRestoredCB.bind(this));

    this.updateTitleWidth = updateTitleWidth;
}; // end constructor








;/**
 * Created by andrewkimoto on 8/8/16.
 */
// set up namespace...
Autodesk.Viewing.MolViewer = Autodesk.Viewing.MolViewer || {};

/**
 * constructor for MolViewerMan
 * @param {object} viewer - the 3DViewer object.
 */
Autodesk.Viewing.MolViewer.MeasureMan = function(app) {
    var _app = app,
        _viewer = app.MoleculeViewer,
        _molMan = app.MolMan,
        _labels = [],
        _angleLabel,
        _endPoints = {first: {}, second: {}},
        _edges = {first: {}, second: {}},
        _faces = {first: {}, second: {}},
        kHudOffset = 4, // pixels
        kLineEndColor = 0xFF9900,
        kLineEndOpacity = 1.0,
        _consumeSingleClick = false,
        _units = "",
        _precision = 3,
        kIndicatorColor = 0x1E8FFF,
        kIndicatorOpacity = 0.7,
        kEndPointOverlayName = 'MeasureTool-endPoint',
        kExtensionLineOverlayName = 'MeasureTool-extensionLine',
        _lines = {
            xyz: {axis: false, color: 'FF9900'},
            x:   {axis: true,  color: 'F12C2C'},
            y:   {axis: true,  color: '0BB80B'},
            z:   {axis: true,  color: '2C2CF1'}
        },
        _materialPoint = new THREE.MeshBasicMaterial({
            color: kLineEndColor,
            depthTest: false,
            depthWrite: false
        });
    //each measurement should be {
    // id: string,
    // p1: THREE.Vector3,
    // p2: THREE.Vector3,
    // distance: float
    // line: THREE.Line
    // lines: {
    //    xyz: {axis: false, color: 'FF9900'},
    //    x:   {axis: true,  color: 'F12C2C'},
    //    y:   {axis: true,  color: '0BB80B'},
    //    z:   {axis: true,  color: '2C2CF1'}
    // }
    //}

    var _measurements = [];
    var _that = this;
    var _shown = false;
    var _distances = {};
    var _angle = 0;
    var _redraw = false;

    this.onCameraChange = function onCameraChange() {
        this.updateLabelPositions();
    };

    this.onExplodeChange = function onExplodeChange() {
        // For now we hide measurements when explode is turned on.
        // If there is a use case for having measurement active during explode we can revisit
        var explodeScale = _molMan.molModels[_molMan.currentMolModelID].getExplodeScale();
        var labels = _viewer.container.querySelectorAll('.measure-length');
        var i;

        if (!_viewer.impl.overlayScenes['MeasureTool-xyz']) {
            return;
        }

        if (explodeScale === 0) {
            for (i = 0; i < labels.length; ++i) {
                labels[i].classList.add('visible');
            }
            _viewer.impl.overlayScenes['MeasureTool-xyz'].scene.visible = true;
        } else {
            for (i = 0; i < labels.length; ++i) {
                labels[i].classList.remove('visible');
            }
            _viewer.impl.overlayScenes['MeasureTool-xyz'].scene.visible = false;
        }

        _viewer.impl.invalidate(false, false, true);
    };

    this.onModelDeleted = function onModelDeleted(event) {
        this.removeMeasurements();
    };

    this.onAssemblySet = function onAssemblySet() {
        this.removeMeasurements();
    };

    this.onReset = function onReset() {
        this.removeMeasurements();
    };

    this.onCameraChangeBind = this.onCameraChange.bind(this);
    this.onExplodeChangeBind = this.onExplodeChange.bind(this);
    this.onResetBind = this.onReset.bind(this);
    this.onModelDeletedBind = this.onModelDeleted.bind(this);
    this.onAssemblySetBind = this.onAssemblySet.bind(this);

    this.createMeasurementObj = function(p1,p2,name,clickStatus,isSnapped) {
        var self = this;
        var material =  new THREE.LineBasicMaterial({
            color: parseInt('FF9900', 16),
            linewidth: 2.3,
            depthTest: false,
            depthWrite: false
        });

        var geometry = new THREE.Geometry();
        geometry.vertices.push(p1);
        geometry.vertices.push(p2);

        var line = new THREE.Line(geometry, material);
        var p1Geometry = new THREE.SphereGeometry(1.0);
        var p1EndPoint = new THREE.Mesh(p1Geometry, _materialPoint);
        var p2Geometry = new THREE.SphereGeometry(1.0);
        var p2EndPoint = new THREE.Mesh(p2Geometry, _materialPoint);

        var measurement = {
            id: THREE.Math.generateUUID(),
            name: name,
            p1: p1,
            p2: p2,
            distance: p1.distanceTo(p2),
            material: material,
            geometry: geometry,
            line: line,
            p1EndPoint: p1EndPoint,
            p2EndPoint: p2EndPoint,
            color: 'FF9900'
        };
        return this.addMeasurement(measurement,clickStatus,isSnapped);
    };

    this.addMeasurement = function(m,clickStatus,isSnapped) {
        var self = this;

        if (clickStatus && m.name === 'xyz' && isSnapped) {
            _measurements.push(m);
            console.log('line added: ',m);
        }

        return m;
    };

    this.removeMeasurement = function removeMeasurement(id) {
        var m = this.getMeasurementById(id);
        var i;
        var measurements = this.getMeasurements();
        var label = _app.container.querySelector('#label-' + m.id);
        if (m) {
            _viewer.impl.removeOverlay(m.overlayName, m.line);
            _viewer.impl.removeOverlay(m.overlayName, m.p1EndPoint);
            _viewer.impl.removeOverlay(m.overlayName, m.p2EndPoint);
            _viewer.impl.invalidate(false, false, true);
            if(label) {
                _viewer.container.removeChild(label);
            }
            for (i = measurements.length -1; i >= 0; --i) {
                if (measurements[i].id === m.id) {
                    measurements.splice(i,1);
                }
            }
        }
    };

    this.removeMeasurements = function removeMeasurements() {
        var labels = _viewer.container.querySelectorAll('.measure-length');
        var i;
        for (i = 0; i < labels.length; ++i) {
            _viewer.container.removeChild(labels[i]);
        }
        _measurements = [];
        _viewer.impl.clearOverlay('MeasureTool-xyz');
        _viewer.impl.clearOverlay('MeasureTool-endPoint');
        _viewer.impl.invalidate(false,false,true);
    };

    this.getMeasurements = function() {
        return _measurements;
    };

    this.getMeasurementById = function(id) {
        var m;
        for (m in _measurements) {
            if (_measurements.hasOwnProperty(m)) {
                if (_measurements[m].id === id) {
                    return _measurements[m];
                }
            }
        }
        return false;
    };

    this.getMeasurementByEndpoints = function(p1,p2) {
        var m;
        for (m in _measurements) {
            if (_measurements.hasOwnProperty(m)) {
                if (this.comparePoints(p1,_measurements[m].p1) && this.comparePoints(p2,_measurements[m].p2)) {
                    return _measurements[m];
                }
            }
        }
        return false;
    };

    this.comparePoints = function(p1,p2) {
        return (p1.x === p2.x && p1.y === p2.y && p1.z === p2.z);
    };


    this.updateLabelPositions = function () {
        var lines = this.getMeasurements();
        function project(x, y, z) {
            var camera = _viewer.navigation.getCamera(),
                containerBounds = _viewer.navigation.getScreenViewport(),
                p = new THREE.Vector3(x, y, z);

            p = p.project(camera);

            // if the z value of the projected label position is behind the camera
            // then set the x and y coordinates outside of the screen.
            if (Math.abs(p.z) > 1.0 || isNaN(p.z) ) {
                return {x: -2, y: -2};
            }

            return {
                x: Math.round(( p.x + 1) / 2 * containerBounds.width) + 5,    // Add 5px to make the label not to be on the object
                y: Math.round((-p.y + 1) / 2 * containerBounds.height) + 5    // Add 5px to make the label not to be on the object
            };
        }

        function placeLabelXYZ(item) {
            var p1 = item.p1,
                p2 = item.p2,
                p1xy = project(p1.x, p1.y, p1.z),
                p2xy = project(p2.x, p2.y, p2.z),
                dx = p2xy.x - p1xy.x,
                dy = p2xy.y - p1xy.y,
                xy = project(p2.x, p2.y, p2.z),
                x = xy.x,
                y = xy.y,
                labelRect = item.label.getBoundingClientRect();

            if (0 < dy) {
                y += kHudOffset;
            } else {
                y -= (labelRect.height + kHudOffset);
            }
            if ((dx < 0) || (0 < dy)) {
                x -= (labelRect.width + kHudOffset);
            } else {
                x += kHudOffset;
            }

            return {x: x, y: y};
        }

        function placeLabelAxis(item, itemXYZ) {
            var p1 = item.p1,
                p2 = item.p2,
                mx = p1.x + (p2.x - p1.x) / 2,
                my = p1.y + (p2.y - p1.y) / 2,
                mz = p1.z + (p2.z - p1.z) / 2,
                xy = project(mx, my, mz),
                x = xy.x,
                y = xy.y,
                p1xyz = itemXYZ.p1,
                p2xyz = itemXYZ.p2,
                p1xy = project(p1xyz.x, p1xyz.y, p1xyz.z),
                p2xy = project(p2xyz.x, p2xyz.y, p2xyz.z),
                cx = (x + p1xy.x + p2xy.x) / 3,
                cy = (y + p1xy.y + p2xy.y) / 3,
                dx = x - cx,
                dy = y - cy,
                labelRect = item.label.getBoundingClientRect(),
                halfLabelWidth = labelRect.width / 2,
                halfLabelHeight = labelRect.height / 2;

            x -= halfLabelWidth;
            y -= halfLabelHeight;

            if (0 < dx) {
                x += halfLabelWidth;
            } else {
                x -= halfLabelWidth;
            }

            if (0 < dy) {
                y += halfLabelHeight;
            } else {
                y -= halfLabelHeight;
            }

            return {x: x, y: y};
        }

        for (var name = 0; name < lines.length; ++name) {
            var item = lines[name],
                label = item.label;

            if (label) {
                var xy = item.axis ? placeLabelAxis(item, _lines.xyz) : project((item.p1.x + item.p2.x)/2, (item.p1.y + item.p2.y)/2, (item.p1.z + item.p2.z)/2); // TODO: avoid collisions for labels
                label.style.top  = xy.y + 'px';
                label.style.left = xy.x + 'px';
                _labels.push(label);
            }
        }

        if (_angleLabel) {

            label = _angleLabel.label;

            if (label) {
                var xy = project((_angleLabel.p1.x + _angleLabel.p2.x)/2, (_angleLabel.p1.y + _angleLabel.p2.y)/2, (_angleLabel.p1.z + _angleLabel.p2.z)/2); // TODO: avoid collisions for labels
                label.style.top = xy.y + 'px';
                label.style.left = xy.x + 'px';
                _labels.push(label);
            }
        }

        for (var name in _faces) {
            if (_faces.hasOwnProperty(name)) {
                var face = _faces[name],
                    label = face.label,
                    point = face.intersectPoint;

                if (label && point) {
                    var xy = project(point.x, point.y, point.z); // TODO: avoid collisions for labels
                    label.style.top  = xy.y + 'px';
                    label.style.left = xy.x + 'px';
                    _labels.push(label);
                }
            }
        }

        for (var name in _edges) {
            if (_edges.hasOwnProperty(name)) {
                var edge = _edges[name],
                    label = edge.label,
                    point = edge.intersectPoint;

                if (label && point) {
                    var xy = project(point.x, point.y, point.z); // TODO: avoid collisions for labels
                    label.style.top  = xy.y + 'px';
                    label.style.left = xy.x + 'px';
                    _labels.push(label);
                }
            }
        }

        for (var name in _endPoints) {
            if (_endPoints.hasOwnProperty(name)) {
                var endPoint = _endPoints[name],
                    label = endPoint.label,
                    point = endPoint.position;

                if (label && point) {
                    var xy = project(point.x, point.y, point.z); // TODO: avoid collisions for labels
                    label.style.top  = xy.y + 'px';
                    label.style.left = xy.x + 'px';
                    _labels.push(label);
                }
            }
        }

        for (var i = 0; i < _labels.length; i++) {
            for (var j = 0; j < i; j++) {
                this.labelsOverlapDetection(_labels[j], _labels[i]);
            }
        }
        _labels = [];
    };

    this.labelsOverlapDetection = function(label1, label2) {

        var rect1 = label1.getBoundingClientRect();
        var rect2 = label2.getBoundingClientRect();

        //if ((rect2.top <= rect1.bottom && rect2.top >= rect1.top) || (rect2.bottom <= rect1.bottom && rect2.bottom >= rect1.top)) {
        if (rect2.top <= rect1.bottom && rect2.bottom >= rect1.top) {
            if (rect2.right >= rect1.left && rect2.right <= rect1.right) {
                label2.style.left = parseInt(label2.style.left, 10) - (rect2.right - rect1.left) + 'px';
            }
            else if (rect2.left >= rect1.left && rect2.left <= rect1.right) {
                label2.style.left = parseInt(label2.style.left, 10) + (rect1.right - rect2.left) + 'px';
            }
            else if (rect2.left <= rect1.left && rect2.right >= rect1.right) {
                label2.style.left = parseInt(label2.style.left, 10) + (rect1.right - rect2.left) + 'px';
            }
        }
    };

    // This is a workaround to deal with the limitation on linewidth on Windows due to the ANGLE library
    this.drawLineAsCylinder = function(geom, material, linewidth) {

        var line;

        if (geom.vertices.length == 2) {
            line = this.cylinderMesh(geom.vertices[0], geom.vertices[1], material, linewidth);
            this.setCylinderScale(line);
        }

        return line;
    };

    this.cylinderMesh = function(pointX, pointY, material, linewidth) {

        var direction = new THREE.Vector3().subVectors(pointY, pointX);
        var orientation = new THREE.Matrix4();
        orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
        orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
            0, 0, 1, 0,
            0, -1, 0, 0,
            0, 0, 0, 1));

        var edgeGeometry = new THREE.CylinderGeometry(0.1 * linewidth, 0.1 * linewidth, direction.length(), 8, 1, true);
        var edge = new THREE.Mesh(edgeGeometry, material);
        edge.applyMatrix(orientation);
        edge.position.x = (pointY.x + pointX.x) / 2;
        edge.position.y = (pointY.y + pointX.y) / 2;
        edge.position.z = (pointY.z + pointX.z) / 2;

        return edge;
    };

    // Set scale for cylinder
    this.setCylinderScale = function (cylinderMesh) {

        var scale = this.setScale(cylinderMesh.position);
        cylinderMesh.scale.x = scale;
        cylinderMesh.scale.z = scale;
    };

    // Set scale for vertex and extension dashed line
    this.setScale = function (point) {

        var pixelSize = 5;

        var navapi = _viewer.navigation;
        var camera = navapi.getCamera();

        var view = navapi.getEyeVector();
        var position = navapi.getPosition();

        var p = point.clone();

        var distance = camera.isPerspective ? p.sub(position).dot(view.normalize())
            : navapi.getEyeVector().length();

        var fov = navapi.getVerticalFov();
        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

        var viewport = navapi.getScreenViewport();
        var devicePixelRatio = window.devicePixelRatio || 1;
        var scale = pixelSize * worldHeight / (viewport.height * devicePixelRatio);

        return scale;
    };

    this.toJSONObj  = function(){
        var obj ={};
        obj.measurements = [];
        var measurement;
        var i;
        for (i =0;i<_measurements.length;++i) {
            measurement = {
                id: _measurements[i].id,
                name: _measurements[i].name,
                p1: _measurements[i].p1,
                p2: _measurements[i].p2,
                distance: null,
                material: _measurements[i].material,
                geometry: _measurements[i].geometry,
                line: _measurements[i].line,
                p1EndPoint: _measurements[i].p1EndPoint,
                p2EndPoint: _measurements[i].p2EndPoint,
                color: _measurements[i].color
            };
            obj.measurements.push(measurement);
        }
        obj.shown = true;
        return obj;
    };

    this.fromJSONObj = function(obj){
        var measure = obj.measure,
            measurement,
            m,
            geometry,
            p1Geometry,
            p2Geometry,
            material =  new THREE.LineBasicMaterial({
            color: parseInt('FF9900', 16),
            linewidth: 2.3,
            depthTest: false,
            depthWrite: false
            });
        this.removeMeasurements();

        _measurements = [];

        for (var i = 0; i < measure.measurements.length; ++i){
            measurement = measure.measurements[i];
            measurement.p1 = new THREE.Vector3(measurement.p1.x, measurement.p1.y, measurement.p1.z);
            measurement.p2 = new THREE.Vector3(measurement.p2.x, measurement.p2.y, measurement.p2.z);
            _consumeSingleClick = true;
            this.drawLine(measurement.p1, measurement.p2, true, true);
        }

        this.deactivateMeasureMode();
    };


    /**
     * This needs to be called first to turn on the measure and register it's events.
     */
    this.activate = function activate() {
        var measurements = this.getMeasurements();
        var i;


        if (measurements.length > 0) {
            for (i = 0; i < measurements.length; ++i) {
                measurements[i].label.querySelector('.close-annotate').classList.remove('hide');
                measurements[i].label.querySelector('.close-annotate').addEventListener('click', function(event) {deleteAnnotation(event);});
                if (_that.annotationType === 'caption') {
                    measurements[i].label.classList.remove('inactive');
                }
            }
        }
        this.updateLabelPositions();
    };



    /**
     * This will deactivate annotate mode but not turn off existing annotation.
     */
    this.deactivateMeasureMode = function deactivateMeasureMode () {

        var i,
            label,
            container = _viewer.container;

        for (i = 0; i < _measurements.length; ++i) {

            label = container.querySelector('#label-'+_measurements[i].id);
            label.classList.add('inactive');
        }

    };


    this.stateRestoredCB = function stateRestoredCB(event) {
        if(event.state && event.state.measure && event.state.measure.measurements && event.state.measure.measurements.length > 0) {
            this.fromJSONObj(event.state);
            _viewer.loadedExtensions['Autodesk.Measure'].enableMeasureTool(false); //turn off annotation tool when restoring state
        }
    };

    var stateRestoredCBBind = this.stateRestoredCB.bind(this);

    _viewer.addEventListener(Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT,this.stateRestoredCB.bind(this));


    // Draw distance measurement
    this.drawLine = function( p1, p2, /*optional*/ hideXYZ, snapped )
    {
        var self = this;
        function updateLine(name, x1, y1, z1, x2, y2, z2, showAxis, isSnapped) {
            var p1 = new THREE.Vector3(x1, y1, z1),
                p2 = new THREE.Vector3(x2, y2, z2),
                label,
                snapper = _viewer.toolController.getTool('snapper'),
                line = self.getMeasurementByEndpoints(p1,p2);

            isSnapped = isSnapped ? isSnapped : snapper.isSnapped();

            // no measurements allowed with zero distance
            if (p1.x === p2.x && p1.y === p2.y && p1.z === p2.z && _consumeSingleClick) {
                self.hideFirstVertex(p1);
                self.hideSecondVertex(p2);
                return;
            }

            if(self.currentLine) {
                _viewer.impl.removeOverlay(self.currentLine.overlayName, self.currentLine.line );
                _viewer.impl.removeOverlay(self.currentLine.overlayName, self.currentLine.p1EndPoint );
                _viewer.impl.removeOverlay(self.currentLine.overlayName, self.currentLine.p2EndPoint );
            }



            if (!line) {
                line = self.createMeasurementObj(p1,p2,name,_consumeSingleClick,isSnapped);
                line.overlayName = 'MeasureTool-' + line.name;
                if (!_viewer.impl.overlayScenes[line.overlayName]) {
                    _viewer.impl.createOverlayScene(line.overlayName);
                }
                self.currentLine = line;

            }


            if (line && _consumeSingleClick && !isSnapped) { //user clicked on empty space
                _viewer.impl.removeOverlay(line.overlayName,line.line);
                line = null;
            }

            if (label) {
                label.classList.remove('visible');
            }

            if (line && p1.distanceTo(p2) >= Math.pow(0.1, _precision) && showAxis) {

                var show = (name === 'xyz' || (!_simple && _consumeSingleClick));

                // make the rubber band 50% transparent.
                if (_consumeSingleClick) {
                    line.material.opacity = 1;
                    self.currentLine = null;
                }
                else {
                    line.material.opacity = kIndicatorOpacity;
                }

                self.hideFirstVertex(p1);
                self.hideSecondVertex(p2);

                var p1Scale = self.setScale(p1);
                line.p1EndPoint.scale.x = p1Scale;
                line.p1EndPoint.scale.y = p1Scale;
                line.p1EndPoint.scale.z = p1Scale;
                line.p1EndPoint.position.set(line.p1.x, line.p1.y, line.p1.z);
                line.p1EndPoint.visible = true;

                var p2Scale = self.setScale(p2);
                line.p2EndPoint.scale.x = p2Scale;
                line.p2EndPoint.scale.y = p2Scale;
                line.p2EndPoint.scale.z = p2Scale;
                line.p2EndPoint.position.set(line.p2.x, line.p2.y, line.p2.z);
                line.p2EndPoint.visible = true;

                _viewer.impl.addOverlay(line.overlayName, line.line);
                _viewer.impl.addOverlay(line.overlayName, line.p1EndPoint);
                _viewer.impl.addOverlay(line.overlayName, line.p2EndPoint);
                _viewer.impl.invalidate(false,false,true);

                line.visible = show;

                line.p1 = p1;
                line.p2 = p2;

                if (name != 'xyz' || _consumeSingleClick) {

                    line.label = document.createElement('div');
                    line.label.className = 'measure-length';
                    line.label.id = 'label-' + line.id;

                    if (name === 'xyz') {
                        var text = document.createElement('div');
                        text.className = 'measure-length-text';
                        line.label.appendChild(text);
                        var closeBox = document.createElement('div');
                        closeBox.setAttribute('class','close-measure');
                        line.label.appendChild(closeBox);
                        closeBox.addEventListener('click',self.removeMeasurement.bind(self,line.id));

                        // This button is for Markup and Comments
                        //var button = document.createElement('div');
                        //button.className = 'measure-length-button';
                        //button.style.cursor = 'pointer';
                        //button.addEventListener('click', function (event) {
                        //
                        //}, true);
                        //label.appendChild(button);

                    } else {
                        line.label.style.pointerEvents = 'none';
                    }

                    if (line.axis) {
                        line.label.className = 'adsk-icon-axis-' + name + ' measure-label-axis measure-label-axis-' + name;
                        line.label.id = 'label-' + line.id;
                    }

                    _viewer.container.appendChild(line.label);
                }

                if (line.label) {
                    self.updateDistance(line);
                    line.label.classList.toggle('visible', show);
                }

            }
        }

        // If the line aligns with one of axis, then don't show axis
        function displayAxis(p1, p2) {
            var prec = Math.pow(0.1, _precision);

            if ((Math.abs(p1.x - p2.x) >= prec && Math.abs(p1.y - p2.y) < prec && Math.abs(p1.z - p2.z) < prec)
                || (Math.abs(p1.y - p2.y) >= prec && Math.abs(p1.x - p2.x) < prec && Math.abs(p1.z - p2.z) < prec)
                || (Math.abs(p1.z - p2.z) >= prec && Math.abs(p1.x - p2.x) < prec && Math.abs(p1.y - p2.y) < prec)) {
                return false;
            }

            return true;
        }

        updateLine('xyz', p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, true, snapped);

        var up = _viewer.navigation.getAlignedUpVector(),
            x = Math.abs(up.x),
            y = Math.abs(up.y),
            z = Math.abs(up.z);

        var showAxis = hideXYZ ? false : displayAxis(p1, p2);

        this.updateLabelPositions();
    };

    this.updateDistance = function (line) {
        var label = line.label;
        if (label) {
            label.children[0].textContent = this.getDistance(line);
        }
    };

    this.getDistance = function (line) {

        if (_viewer.model && _viewer.model.isLoadDone()) {
            var d = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _units, line.distance || 0);
            return Autodesk.Viewing.Private.formatValueWithUnits(d, _units, 3, _precision);
        }
    };

    this.showFirstVertex = function( position )
    {
        var scale = this.setScale(position);
        this.showEndPoint('first', position, scale);
    };

    this.showSecondVertex = function( position )
    {
        var scale = this.setScale(position);
        this.showEndPoint('second', position, scale);
    };

    this.hideFirstVertex = function( position )
    {
        var scale = this.setScale(position);
        this.showEndPoint('first', position, scale, true);
    };

    this.hideSecondVertex = function( position )
    {
        var scale = this.setScale(position);
        this.showEndPoint('second', position, scale, true);
    };

    this.showEndPoint = function (name, position, scale, hide) {
        if (!_materialPoint) {
            _materialPoint = new THREE.MeshBasicMaterial({
                color: kLineEndColor,
                depthTest: false,
                depthWrite: false
            });
            if(!_viewer.impl.overlayScenes[kEndPointOverlayName]) {
                _viewer.impl.createOverlayScene(kEndPointOverlayName);
            }
        }

        if (hide) {
            _viewer.impl.clearOverlay(kEndPointOverlayName);
            _endPoints = {first: {}, second: {}};
            return;
        }

        var endPoint = _endPoints[name],
            mesh = endPoint.mesh;

        if (!mesh) {
            endPoint.geometry = new THREE.SphereGeometry(1.0);
            mesh = endPoint.mesh = new THREE.Mesh(endPoint.geometry, _materialPoint);
            if(!_viewer.impl.overlayScenes[kEndPointOverlayName]) {
                _viewer.impl.createOverlayScene(kEndPointOverlayName);
            }
            _viewer.impl.addOverlay(kEndPointOverlayName, mesh);
        }

        mesh.scale.x = scale;
        mesh.scale.y = scale;
        mesh.scale.z = scale;
        mesh.position.set(position.x, position.y, position.z);
        mesh.visible = true;
        _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);

        if (_consumeSingleClick || _redraw) {
            this.updateLabelPositions();
        }
    };

    // Set scale for vertex and extension dashed line
    this.setScale = function (point) {

        var pixelSize = 5;

        var navapi = _viewer.navigation;
        var camera = navapi.getCamera();

        var view = navapi.getEyeVector();
        var position = navapi.getPosition();

        var p = point.clone();

        var distance = camera.isPerspective ? p.sub(position).dot(view.normalize())
            : navapi.getEyeVector().length();

        var fov = navapi.getVerticalFov();
        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

        var viewport = navapi.getScreenViewport();
        var devicePixelRatio = window.devicePixelRatio || 1;
        var scale = pixelSize * worldHeight / (viewport.height * devicePixelRatio);

        return scale;
    };

    // Update scale for vertex and extension dash line
    this.updateScale = function() {
        var scene;
        var i;
        var dashScale;
        var overlay = _viewer.impl.overlayScenes[kEndPointOverlayName];
        if (overlay) {
            scene = overlay.scene;

            for (i = 0; i < scene.children.length; i++) {
                var pointMesh = scene.children[i];
                if (pointMesh) {

                    var scale = this.setScale(pointMesh.position);
                    pointMesh.scale.x = scale;
                    pointMesh.scale.y = scale;
                    pointMesh.scale.z = scale;
                }
            }
        }

        overlay = _viewer.impl.overlayScenes[kExtensionLineOverlayName];
        if (overlay) {
            scene = overlay.scene;

            for (i = 0; i < scene.children.length; i++) {
                var extensionLine = scene.children[i];
                if (extensionLine) {

                    dashScale = this.setScale(extensionLine.geometry.vertices[0]);
                    extensionLine.material.dashSize = dashScale * 4;
                    extensionLine.material.gapSize = dashScale * 2;
                }
            }
        }
    };

    this.setConsumeSingleClick = function(val) {
        _consumeSingleClick = val;
    };

    this.getConsumeSingleClick = function() {
        return _consumeSingleClick;
    };


    _viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBind);
    _viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onCameraChangeBind);
    _viewer.addEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT,this.onExplodeChangeBind);
    // Note: RESET_EVENT is not currently being fired anywhere.  We may want to revist that and
    // fire it when we reset the model via the settings menu in headerview.js
    //_viewer.addEventListener(Autodesk.Viewing.RESET_EVENT, this.onResetBind);
    _viewer.addEventListener(Autodesk.Nano.MODEL_DELETED_EVENT, this.onModelDeletedBind);
    _viewer.addEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT, this.onAssemblySetBind);
};;

// set up namespace...
Autodesk.Viewing.MolViewer = Autodesk.Viewing.MolViewer || {};


Autodesk.Viewing.MolViewer.AtomRepState = function( instance) {


    this.instance = instance;
    this.numAtoms = instance.molModel.getNumAtoms();
    //bit's go ribbon, stick,surface, cpk (cpk not used)
    this.bitSets = {
        'ribbon': new BitSet(this.numAtoms),
        'stick': new BitSet(this.numAtoms),
        'surface': new BitSet(this.numAtoms),
        'CPK': new BitSet(this.numAtoms)
    };

    this.dtor = function dtor(){
        delete this.instance;

    };

    this.toJSONObj = function toJSONObj(){
        var obj = {};
        var list,encoded;
        for(var rep in this.bitSets){
            list = this.bitSets[rep].toArray();
            encoded = RLE.encode(list);
            obj[rep] = encoded;
        }
        return obj;
    };

    this.fromJSONObj = function fromJSONObj(obj){
        var decArray,decItem,decoded;
        for(var rep in obj){
            decArray = [];
            for(decItem in obj[rep]){
                decArray.push(obj[rep][decItem]);
            }
            decoded = RLE.decode(decArray);
            this.bitSets[rep].fromArray(decoded);
        }

    };

    this.isVisible = function isVisible(atomID){
        for(var rep in this.bitSets) {
            if(this.bitSets[rep].get(atomID)){
                return true;
            }
        }
        return false;
    };

    this.createFrom = function createFrom(atomRepState){
        for(var rep in this.bitSets) {
            this.bitSets[rep] = atomRepState.bitSets[rep].clone();
        }
    }
    this.setAtomRep = function setAtomRep(rep, which,val) {
        this.bitSets[rep].set(which ,  val);
    };

    this.getAtomRep = function getAtomRep(rep, which) {
        return this.bitSets[rep].get(which);
    };


    this.setAtomsRep = function setAtomsRep(rep,atoms,val){
        var i;
        if(!atoms || atoms.length <=0){
            for (i = 0; i < this.numAtoms;++i ){
                this.setAtomRep(rep,i,val);
            }
        }else{
            for (i =0;i<atoms.length;++i){
                this.setAtomRep(rep,atoms[i],val);
            }
        }
    };
    this.getAtomsRep = function getAtomsRep(rep,atoms,checkAll){
        if(!atoms || atoms.length <=0){
            return !(this.bitSets[rep].isEmpty());
        }
        var i;
        if(!checkAll) {
            for (i = 0; i < atoms.length; ++i) {
                if (this.bitSets[rep].get(atoms[i])) {
                    return true;
                }
            }
            return false;
        }else{
            for (i = 0; i < atoms.length; ++i) {
                if (!this.bitSets[rep].get(atoms[i])) {
                    return false;
                }
            }
            return true;
        }
    };

    // optional selAtoms array of atomIDs lets us input an arbitrary array of
    // atoms instead of all atoms (useful when we need to get a list of visible
    // atoms for3d print).
    //also if onlyRegular if true will not return het or ligands
    this.getWhichAtomsOn = function getWhichAtomsOn(rep,selAtoms,onlyRegular){
        var atomMetadata = this.instance.molModel.atomMetadata;
        var atoms = [],
            i;
        if (!selAtoms) {

            for(i =0;i< this.numAtoms;++i){
                if(this.bitSets[rep].get(i)){
                    if(!onlyRegular || !atomMetadata[i].isHet) {
                        atoms.push(i);
                    }
                }
            }
            return atoms;
        } else {
            for (i = 0; i < selAtoms.length; ++i) {
                if (this.bitSets[rep].get(selAtoms[i])) {
                    if(!onlyRegular || !atomMetadata[selAtoms[i]].isHet) {
                        atoms.push(selAtoms[i]);
                    }
                }
            }
            return atoms;
        }

    };



};
;

// set up namespace...
Autodesk.Viewing.MolViewer = Autodesk.Viewing.MolViewer || {};

Autodesk.Viewing.MolViewer.AtomSelectionState = function( instance,viewer) {
    this.instance = instance;
    this.atoms = instance.molModel.atomMetadata;
    this.numSel = 0;
    this.bitSet = instance.selection.atoms;
    this.viewer = viewer;
    var _that = this;
    viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT, function(event) {
        if(!event.instances) {
            return;
        }
        var i,
            j,
            instance,
            atoms;
        for (j = 0; j < event.instances.length; j++) {
            instance = (event.instances[j].id ? event.instances[j] : event.instances[j].instance);
            if (instance === _that.instance) {
                atoms = [];
                for (i = 0; i < _that.atoms.length; ++i) {
                    if (_that.bitSet.get(i)) {
                        atoms.push(i);
                    }
                }
                _that.viewer.impl.highlightObjectByAtoms(_that.instance, atoms,  true);
            }
        }
    });

    this.dtor = function dtor(){
        delete this.instance;
        delete this.atoms;
        delete this.bitSet;
    };


    this.isAtomSelected = function isAtomSelected(which) {
        return this.bitSet.get(which);
    };

    this.setAtomSelected = function setAtomSelected(which,val) {
        var current = this.isAtomSelected(which);
        if(current !== val){
            this.bitSet.set(which, val);
            if(val){
                this.numSel++;
            }else{
                this.numSel--;
            }
        }
    };

    this.setAtomsSelected = function setAtomsSelected(atoms,val){
        for (var i =0;i<atoms.length;++i){
            this.setAtomSelected(atoms[i],val);
        }
        //this.parentData = this.getParentData();
    };

    this.numSelected = function numSelected() {
        return this.numSel;
    };

    this.getSelected = function getSelected(){
        var j;
        var results = [];
        if(this.numSel ===0){
            for(j = 0; j < this.atoms.length; j++) {
                    results.push(j);
                }
        }
        else{
            for (j = 0; j < this.atoms.length; j++) {
                if (this.isSelected(j)) {
                    results.push(j);
                }
            }
        }
        return results;
    };

    this.isSelected = function isSelected(result) {
        var whichAtom;
        if(result.node) {
            whichAtom = this.getAtomNumFromResult(result);
        }else{
            whichAtom = result;
        }
        return this.isAtomSelected(whichAtom);
    };

    this.clearSelection = function clearSelection(){
        var atoms = [];
        for(var i = 0;i < this.atoms.length;++i) {
            if (this.bitSet.get(i)) {
                atoms.push(i);
            }
            this.setAtomSelected(i,0);
        }
        this.viewer.impl.highlightObjectByAtoms(this.instance,atoms, false);

    };
    this.getAtomNumFromResult = function(result){
        /*
        var fragID = this.model.myData.fragments.packIds[result.node.fragIds];
        var entityIndex = this.model.myData.fragments.entityIndexes[result.node.fragIds];
        var fragName = fragID.toString() + '.pf.' + entityIndex.toString();
        var selectedAtom = parseInt(metadata.meshInfoPerFace[fragName][result.faceIndex/3]);
        */
        var selectedAtom = result.atomID;
        return selectedAtom;
    };


    this.markObjects = function markObjects(atoms){
        this.viewer.impl.highlightObjectByAtoms(this.instance, atoms, true);

    };

    this.unmarkObjects = function unmarkObjects(atoms) {
        this.viewer.impl.highlightObjectByAtoms(this.instance, atoms, false);
    };


};
;
/**
 Created by Michael Zyracki Jan 3, 2017
 */

Autodesk.Nano.MolViewer.BaseView = function(scene,instance,viewer,options) {

    this.id = THREE.Math.generateUUID();
    this.instance = instance;
    this._viewer = viewer;
    this._meshes = {};
    this._meshesByEntityID = this._meshes; //array of meshes by entity, by default same as _meshes but different for ribbon view, used for explosions
    this.scene = scene;
    this.overlayName = "selection" + ":" + instance.id; //use the instance overlay name
};

Autodesk.Nano.MolViewer.BaseView.prototype.dtor = function(){
    this.deleteMeshes();

};

//keep meshes around since they hold transofroms
Autodesk.Nano.MolViewer.BaseView.prototype.hide = function(){
    var scene = this.scene;
    var mesh,proxy;
    for(var i in this._meshes){
        mesh = this._meshes[i];
        scene.remove(mesh);
        proxy = mesh._selectionProxy;
        if(proxy && proxy.parent){
            proxy.parent.remove(proxy);
        }
    }
};

Autodesk.Nano.MolViewer.BaseView.prototype.deleteMeshes = function deleteMeshes(){
    this.hide();
    delete this._meshes;
    this._meshes = {};

};

Autodesk.Nano.MolViewer.BaseView.prototype.hitTestBoundingSpheres = function hitTestBoundingSpheres(ray){
    var maxDist = Number.MAX_VALUE;
    return maxDist;
};


Autodesk.Nano.MolViewer.BaseView.prototype.createFrom = function createFrom(view, molRepRep) {

};


Autodesk.Nano.MolViewer.BaseView.prototype.create = function create(id,options){

};

Autodesk.Nano.MolViewer.BaseView.prototype.hitTestBoundingSpheres = function hitTestBoundingSpheres(ray){
    var maxDist = Number.MAX_VALUE;
    for(var i in this._meshes){
        var sphere = this._meshes[i].worldSphere;
        var val = ray.intersectSphere(sphere);
        if(val) {
            var diffx = val.x - sphere.center.x;
            var diffy = val.y - sphere.center.y;
            var diffz = val.z - sphere.center.z;
            var dist = diffx * diffx + diffy * diffy + diffz * diffz;
            if(dist < maxDist) {
                maxDist = dist;
            }
        }
    }
    return maxDist;
};
//currently this is called when setting up an assembly or an explosion on an asembly instance
Autodesk.Nano.MolViewer.BaseView.prototype.setTransforms = function setTransforms(mat4) {
    var mesh;
    for(var id in this._meshes){
        mesh = this._meshes[id];
        if (mesh.matrix)
            mesh.matrix.copy(mat4);
        mesh.matrixWorld.copy(mat4);
        if(mesh.geometry.boundingSphere){
            if(!mesh.worldSphere) {
                mesh.worldSphere = new THREE.Sphere(mesh.geometry.boundingSphere.center.clone(), mesh.geometry.boundingSphere.radius);
            }
            mesh.worldSphere.center.x = mesh.geometry.boundingSphere.center.x;
            mesh.worldSphere.center.y = mesh.geometry.boundingSphere.center.y;
            mesh.worldSphere.center.z = mesh.geometry.boundingSphere.center.z;
            mesh.worldSphere.center.applyMatrix4(mat4);
        }
    }
};
// since meshes are created on demand we may need to explode after the mesh is created.
Autodesk.Nano.MolViewer.BaseView.prototype.explodeIfNeeded = function explodeIfNeeded(entityID){
    if(this._entityTransforms && this._entityTransforms[entityID]){
        this.setEntityTransforms(entityID,this._entityTransforms[entityID]);
    }
};

//only called when exploding entities currently.  need to wrap in api.
Autodesk.Nano.MolViewer.BaseView.prototype.setEntityTransforms = function setEntityTransforms(entityID,mat4) {
    //the meshe's are id'd based upon entities, either as entityID or entityID.xxx.xxx.xx.
    //in the later case there are multiple meshes per entity.
    var meshes = [];
    var mesh;
    mesh = this._meshesByEntityID[entityID];
    if(mesh) {
        if(mesh instanceof Array){
            meshes = mesh;
        }else{
            meshes.push(mesh);
        }
        if(this._entityTransforms && this._entityTransforms[entityID]){
            delete this._entityTransforms[entityID];
        }
    }else{
        //okay not created yet we need to cache it out and then set it when created
        if(!this._entityTransforms){
            this._entityTransforms = {};
        }
        if(!this._entityTransforms[entityID]){
            this._entityTransforms[entityID] = new THREE.Matrix4(); //
        }
        this._entityTransforms[entityID].copy(mat4);

    }
    for(var i =0; i< meshes.length; ++i){
        mesh = meshes[i];
        if (mesh.matrix)
            mesh.matrix.copy(mat4);
        mesh.matrixWorld.copy(mat4);
        if(mesh.geometry.boundingSphere){
            if(!mesh.worldSphere) {
                mesh.worldSphere = new THREE.Sphere(mesh.geometry.boundingSphere.center.clone(), mesh.geometry.boundingSphere.radius);
            }
            mesh.worldSphere.center.x = mesh.geometry.boundingSphere.center.x;
            mesh.worldSphere.center.y = mesh.geometry.boundingSphere.center.y;
            mesh.worldSphere.center.z = mesh.geometry.boundingSphere.center.z;
            mesh.worldSphere.center.applyMatrix4(mat4);
        }
    }
};
/**
 * For now we don't use the atoms but return three meshes
 * @param atoms
 */
Autodesk.Nano.MolViewer.BaseView.prototype.getSelectionMeshes = function getSelectionMeshes(atoms){
    var meshes = [];
    for(var id in this._meshes){
        var mesh = this._meshes[id];
        if(mesh.parent) {
            var proxy = mesh._selectionProxy;
            if(!proxy){
                proxy = new THREE.Mesh(mesh.geometry, mesh.material, true);
                //selectionProxy.atomsShown = 0;
                proxy.matrix = mesh.matrixWorld;
                proxy.matrixAutoUpdate = false;
                proxy.matrixWorldNeedsUpdate = true;
                proxy.frustumCulled = false;
                mesh._selectionProxy = proxy;
            }else{
                proxy.geometry = mesh.geometry; //need to share geometry in order to get the geometry that's updated when the atoms get hidden
            }
            meshes.push(proxy);
        }
    }
    return meshes;

};

;


/**
 Created by Michael Zyracki Jan 3, 2017
 */



Autodesk.Nano.MolViewer.MeshView = function(scene,instance,viewer,options) {

    Autodesk.Nano.MolViewer.BaseView.call(this,scene,instance,viewer);

};



Autodesk.Nano.MolViewer.MeshView.prototype = Object.create(Autodesk.Nano.MolViewer.BaseView.prototype);
Autodesk.Nano.MolViewer.MeshView.prototype.constructor = Autodesk.Nano.MolViewer.BaseView.prototype;





Autodesk.Nano.MolViewer.MeshView.prototype.drawBoundingSpheres = function drawBoundingSpheres() {
    var geometry,mesh;
    var material = new THREE.MeshPhongMaterial
    ({
        ambient: 0x030303,
        color: 0xff000000,
        specular: 0x111111,
        shininess: 10,
        shading: THREE.SmoothShading,
        wireframe: true,
        reflectivity: 0,
        transparent: false
    });
    for(var i in this._meshes) {
        var sphere = this._meshes[i].worldSphere;

        geometry = new THREE.SphereGeometry(sphere.radius, 12, 12);

        mesh = new THREE.Mesh(geometry, material);

        mesh.translateX(sphere.center.x);
        mesh.translateY(sphere.center.y);
        mesh.translateZ(sphere.center.z);
        mesh.updateMatrix();

        this.scene.add(mesh);
    }

};

Autodesk.Nano.MolViewer.MeshView.prototype.setNewGeometry = function setNewGeometry(mesh,id,allAtoms, atomsOn,bitSet,viewType)
{
    var newGeometry, where, newIndices =[];
    var geometry = mesh.geometry;
    var indices;
    var faceToAtom = geometry.faceToAtom;
    var dataID = md5(atomsOn);
    for(var i =0;i< faceToAtom.length;++i){

        if(bitSet.get(faceToAtom[i])){
            where = i*3;
            newIndices.push(geometry.origIndex[where]);
            newIndices.push(geometry.origIndex[where+1]);
            newIndices.push(geometry.origIndex[where+2]);
        }
    }
    if(newIndices.length) {
        indices = new Uint32Array(newIndices);
    }
    if(indices){
        newGeometry = this.instance.molMan.view3DMan.gC.getGeometryCache(id,viewType,dataID);
        if(!newGeometry){
            newGeometry = new THREE.BufferGeometry();
            newGeometry.faceToAtom = geometry.faceToAtom;
            newGeometry.origIndex = geometry.origIndex;
            newGeometry.boundingSphere = geometry.boundingSphere;
            for (var attr in geometry.attributes) {
                var sourceAttr = geometry.attributes[attr];
                if(attr !== 'index') {
                    newGeometry.addAttribute(attr, sourceAttr);
                }else{
                    newGeometry.addAttribute(attr, sourceAttr.clone()); //need to clone the index

                }
            }
            newGeometry.attributes.index.array = indices;
            newGeometry.attributes.index.needsUpdate = true;
            this.instance.molMan.view3DMan.gC.addGeometryCache(id,viewType,newGeometry,dataID);
        }
        mesh.geometry = newGeometry;
        mesh.needsUpdate = true;

    }else{
        if (mesh.parent) { //quick check to see if in scene.
            this.scene.remove(mesh);
        }
    }
}



Autodesk.Nano.MolViewer.MeshView.prototype.createFrom = function createFrom(view, molRepRep) {
    var material = molRepRep.colorMaterialAtom;
    this.deleteMeshes();
    var newMesh;
    var mesh;
    for(var id in view._meshes){
        mesh = view._meshes[id];
        newMesh = new THREE.Mesh(mesh.geometry, material);
        newMesh.atomsOn = mesh.atomsOn.slice(0);
        newMesh.matrixAutoUpdate = false;
        this._meshes[id]= (newMesh);
        this.scene.add(newMesh);
    }
};





Autodesk.Nano.MolViewer.MeshView.prototype.create = function create(id,options){


};

;

/**
 Created by Michael Zyracki Oct 21, 2016
 */
Autodesk.Nano.MolViewer.createSphereMaterials = function createSphereMaterials(id, instance, molRepRep) {

    function createMaterial(instance,id,molRepRep,type){
        var map = molRepRep.colorTextureAtom;

        var shader, material;
        var matName;
        if(!type || type === 'id' || type === 'selectionBase' || type === 'selectionTop'){
            shader = THREE.ShaderLib['nano_sphere'];
            var viewer = instance.viewer;
            var matman = viewer.impl.matman();
            matName =  instance.id + '.Sphere.' + id + '.' + type;

            material = new THREE.RawShaderMaterial( {
                uniforms: shader.uniforms,
                attributes: shader.attributes,
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            } );

            material.depthTest= true;
            material.depthWrite = true;
            //material.ambient = new THREE.Color(0x161616);
            material.ambient = new THREE.Color(0x010101);

            //material.color = new THREE.Color(0x777777);
            material.color = new THREE.Color(0xffffff);

            material.emissive = new THREE.Color( 0x000000 );
            material.specular = new THREE.Color( 0x111111 );

            material.shininess = 10;
            material.opacity = 1.0;

            material.isImposter = true;
            if(type ==='id'){
                material.idAtom = 1;
                matName += '.ID';
                material.map = instance.molModel.idTextureAtom;
                material.map.needsUpdate = true;

            }else if (type ==='selectionBase'){
                matName += '.SELECTIONBASE';
                material.depthTest = true;
                material.depthWrite = true;
                material.color = new THREE.Color( 0x000000 );
                material.specular = new THREE.Color( 0x000000 );
                material.emissive =  new THREE.Color( 0x2F51FF );
                material.alphaTest = 0.5;
                material.ambient =  new THREE.Color( 0x000000 );
                material.opacity = 1.0;
                material.alphaMap = instance.selectionAlphaTextureAtom;
                material.transparent = false;
            }
            else if (type ==='selectionTop'){
                matName += '.SELECTIONTOP';
                material.depthTest = true;
                material.depthWrite = true;
                material.color = new THREE.Color( 0x000000 );
                material.specular = new THREE.Color( 0x000000 );
                material.emissive =  new THREE.Color( 0x2F51FF );
                material.alphaTest = 0.15;
                material.ambient =  new THREE.Color( 0x000000 );
                material.opacity = 0.15;
                material.alphaMap = instance.selectionAlphaTextureAtom;
                material.transparent = true;
            }
            else{
                material.map = map;
                material.map.needsUpdate = true;

                //material.emissive =  0x0f0f0f;
                material.transparent = false;

            }
            material.needsUpdate = true;
            map.needsUpdate = true;
            matman.addMaterialNonHDR(matName,material);

            return material;
        }else if (type === 'depth'){

        }
    };

    var out = { material:null, idMaterial: null, selectionMaterialBase: null};
    var material = createMaterial(instance,id,molRepRep);
    out.material = material;
    var idMaterial = createMaterial(instance,id,molRepRep,'id');
    out.idMaterial = idMaterial;
    var selectionMaterialBase = createMaterial(instance,id,molRepRep,'selectionBase');
    out.selectionMaterialBase = selectionMaterialBase;

    material.overrides = {};
    material.overrides['id'] = this.idMaterial;
    return out;
};

Autodesk.Nano.MolViewer.createSphereGeometry = function createSphereGeometry(id, instance, atomsOn, molRepRep,getUVColor,optionalRadius){



    function computeBoundingSphere (positions,geometry) {

        var box = new THREE.Box3();
        var vector = new THREE.Vector3();


        if ( geometry.boundingSphere === null ) {

            geometry.boundingSphere = new THREE.Sphere();

        }


        if ( positions ) {

            box.makeEmpty();

            var center = geometry.boundingSphere.center;

            for (var i = 0, il = positions.length; i < il; i += 3) {

                vector.set(positions[i], positions[i + 1], positions[i + 2]);
                box.expandByPoint(vector);

            }

            box.center(center);

            // hoping to find a boundingSphere with a radius smaller than the
            // boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

            var maxRadiusSq = 0;

            for (var i = 0, il = positions.length; i < il; i += 3) {

                vector.set(positions[i], positions[i + 1], positions[i + 2]);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));

            }

            geometry.boundingSphere.radius = Math.sqrt(maxRadiusSq);

            if (isNaN(geometry.boundingSphere.radius)) {

                THREE.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.');

            }
        }
    };
    var molModel = instance.molModel;
    var helper = new Autodesk.Nano.MolHelper();
    var dataID = md5(atomsOn);
    var geometry = instance.molMan.view3DMan.gC.getGeometryCache(id,'cpk',dataID);
    if(!geometry) {
        var info = helper.createCPKViewArrays(atomsOn, getUVColor, molModel, optionalRadius);
        geometry = new THREE.InstancedBufferGeometry();
        geometry.copy(new THREE.PlaneBufferGeometry(2.0, 2.0));
        geometry.addAttribute("translate", new THREE.InstancedBufferAttribute(info.translateArray, 3, 1));
        geometry.addAttribute("radius", new THREE.InstancedBufferAttribute(info.radiusArray, 1, 1));
        geometry.addAttribute("uvArray", new THREE.InstancedBufferAttribute(info.uvArray, 2, 1));
        instance.molMan.view3DMan.gC.addGeometryCache(id,'cpk',geometry,dataID);
        computeBoundingSphere(info.translateArray,geometry);
    }
    return geometry;
};

Autodesk.Nano.MolViewer.CPKView = function(scene,instance,viewer,options) {
    Autodesk.Nano.MolViewer.BaseView.call(this,scene,instance,viewer);
    //CPK and stick have their own selection scenes since the override shaders are unique.
    this.overlayName = "selection" + ":" + this.id; //base

};
Autodesk.Nano.MolViewer.CPKView.prototype = Object.create(Autodesk.Nano.MolViewer.BaseView.prototype);
Autodesk.Nano.MolViewer.CPKView.prototype.constructor = Autodesk.Nano.MolViewer.BaseView.prototype;


Autodesk.Nano.MolViewer.CPKView.prototype.dtor = function(){

    this.deleteMeshes();
    this._viewer.impl.removeOverlayScene(this.overlayName);

};

Autodesk.Nano.MolViewer.CPKView.prototype.create = function create(id,options){
    var atomsOn  = options.atomsOn;
    var molRepRep = options.molRepRep;
    var getUVColor = molRepRep.getUVColor;
    var geometry = Autodesk.Nano.MolViewer.createSphereGeometry(id, this.instance, atomsOn,molRepRep,getUVColor);
    var mesh = this._meshes[id];
    if(!mesh){
        var out = Autodesk.Nano.MolViewer.createSphereMaterials(id,this.instance,molRepRep);
        this.material = out.material;
        this.idMaterial = out.idMaterial;
        this.selectionMaterialBase = out.selectionMaterialBase;
        //this.selectionMaterialTop = this.createMaterial(id,molRepRep,'selectionTop');
        this.material.overrides = {};
        this.material.overrides['id'] = this.idMaterial;
        this._viewer.impl.createOverlayScene(this.overlayName, this.selectionMaterialBase, null);
        mesh = new THREE.Mesh( geometry, out.material );
        mesh.matrixAutoUpdate = false;
        this._meshes[id] = mesh;
        mesh.nanoID = id; //needed with selection
        this.scene.add(mesh);
    }else{
        if(mesh.geometry !==geometry){
            mesh.geometry = geometry;
            mesh.needsUpdate = true;
        }
        if(!mesh.parent){ //not in scene
            this.scene.add(mesh);
        }
    }

    return this._meshes;
};

Autodesk.Nano.MolViewer.CPKView.prototype.createFrom = function createFrom(view, molRepRep) {
    var atomsOn = this.instance.molModel.entities[this.instance.entityIDs[0]].atomIDs;

    var options = {atomsOn:atomsOn, molRepRep: molRepRep };
    this.create(this.instance.entityIDs[0],options);

};



Autodesk.Nano.MolViewer.CPKView.prototype.bFactorAnimation = function bFactorAnimation(id, atomsOn,atoms,bFactorMin,bFactorMax) {

    var helper = new Autodesk.Nano.MolHelper();
    var mesh = this._meshes[id];
    var translate = mesh.geometry.attributes.translate;
    translate.needsUpdate = true;
    helper.bFactorAnimation(atoms,atomsOn, translate.array,bFactorMin,bFactorMax);

    //geometry.attributes.translate.array,
    //geomety.attribues.translate.needsUpdate = true;
};
;
/**
 Created by Michael Zyracki Jan 2017
 */

Autodesk.Nano.MolViewer.CPKMeshView = function(scene,instance,viewer,options) {

    Autodesk.Nano.MolViewer.BaseView.call(this,scene,instance,viewer);
    //CPK and stick have their own selection scenes since the override shaders are unique.
    this.overlayName = "selection" + ":" + this.id; //base
};

Autodesk.Nano.MolViewer.CPKMeshView.prototype = Object.create(Autodesk.Nano.MolViewer.BaseView.prototype);
Autodesk.Nano.MolViewer.CPKMeshView.prototype.constructor = Autodesk.Nano.MolViewer.BaseView;

Autodesk.Nano.MolViewer.CPKMeshView.prototype.dtor = function(){

    this.deleteMeshes();
    this._viewer.impl.removeOverlayScene(this.overlayName);

};

Autodesk.Nano.MolViewer.CPKMeshView.prototype.create = function create(id,options){
    var atomsOn  = options.atomsOn;
    var molRepRep = options.molRepRep;
    var getUVColor = molRepRep.getUVColor;
    var geometry = this.createSphereGeometry(id, this.instance, atomsOn,molRepRep,getUVColor);
    var mesh = this._meshes[id];
    if(!mesh){
        var out = this.createMaterials(id,this.instance,molRepRep);
        this.material = out.material;
        this.idMaterial = out.idMaterial;
        this.selectionMaterialBase = out.selectionMaterialBase;
        //this.selectionMaterialTop = this.createMaterial(id,molRepRep,'selectionTop');
        this.material.overrides = {};
        this.material.overrides['id'] = this.idMaterial;
        this._viewer.impl.createOverlayScene(this.overlayName, this.selectionMaterialBase, null);
        mesh = new THREE.Mesh( geometry, out.material );
        mesh.matrixAutoUpdate = false;
        this._meshes[id] = mesh;
        mesh.nanoID = id; //needed with selection
        this.scene.add(mesh);
    }else{
        if(mesh.geometry !==geometry){
            mesh.geometry = geometry;
            mesh.needsUpdate = true;
        }
        if(!mesh.parent){ //not in scene
            this.scene.add(mesh);
        }
    }

    return this._meshes;
};

Autodesk.Nano.MolViewer.CPKMeshView.prototype.createFrom = function createFrom(view, molRepRep) {
    var atomsOn = this.instance.molModel.entities[this.instance.entityIDs[0]].atomIDs;

    var options = {atomsOn:atomsOn, molRepRep: molRepRep };
    this.create(this.instance.entityIDs[0],options);

};




Autodesk.Nano.MolViewer.CPKMeshView.prototype.createMaterials = function createMaterials(id, instance, molRepRep) {

    function createMaterial(instance,id,molRepRep,type){
        var map = molRepRep.colorTextureAtom;

        var shader, material;
        var matName;
        if(!type || type === 'id' || type === 'selectionBase' || type === 'selectionTop'){
            shader = THREE.ShaderLib['nano_sphere_mesh'];
            var viewer = instance.viewer;
            var matman = viewer.impl.matman();
            matName =  instance.id + '.Sphere.Mesh' + '.' + type;

            material = new THREE.ShaderMaterial( {
                uniforms: shader.uniforms,
                attributes: shader.attributes,
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            } );

            material.type = 'nano_sphere_mesh'; //we use this to get the shader
            material.depthTest= true;
            material.depthWrite = true;
            //material.ambient = new THREE.Color(0x161616);
            material.ambient = new THREE.Color(0x010101);

            material.color = new THREE.Color(0x777777);

            material.emissive = new THREE.Color( 0x000000 );
            material.specular = new THREE.Color( 0x111111 );

            material.shininess = 10;
            material.opacity = 1.0;

            if(type ==='id'){
                material.idAtom = 1;
                matName += '.ID';
                material.blending = THREE.NoBlending;
                material.tonemapOutput = false;
                material.map = instance.molModel.idTextureAtom;
                material.map.needsUpdate = true;

            }else if (type ==='selectionBase'){
                matName += '.SELECTIONBASE';
                material.depthTest = true;
                material.depthWrite = true;
                material.color = new THREE.Color( 0x000000 );
                material.specular = new THREE.Color( 0x000000 );
                material.emissive =  new THREE.Color( 0x2F51FF );
                material.alphaTest = 0.5;
                material.ambient =  new THREE.Color( 0x000000 );
                material.opacity = 1.0;
                material.alphaMap = instance.selectionAlphaTextureAtom;
                material.transparent = false;
            }
            else if (type ==='selectionTop'){
                matName += '.SELECTIONTOP';
                material.depthTest = true;
                material.depthWrite = true;
                material.color = new THREE.Color( 0x000000 );
                material.specular = new THREE.Color( 0x000000 );
                material.emissive =  new THREE.Color( 0x2F51FF );
                material.alphaTest = 0.15;
                material.ambient =  new THREE.Color( 0x000000 );
                material.opacity = 0.15;
                material.alphaMap = instance.selectionAlphaTextureAtom;
                material.transparent = true;
            }
            else{
                material.map = map;
                material.map.needsUpdate = true;

                //material.emissive =  0x0f0f0f;
                material.transparent = false;

            }
            material.packedNormals = false;
            material.needsUpdate = true;
            map.needsUpdate = true;
            matman.addMaterialNonHDR(matName,material);

            return material;
        }else if (type === 'depth'){

        }
    };
    var out = { material:null, idMaterial: null, selectionMaterialBase: null};
    var material = createMaterial(instance,id,molRepRep);
    out.material = material;
    var idMaterial = createMaterial(instance,id,molRepRep,'id');
    out.idMaterial = idMaterial;
    var selectionMaterialBase = createMaterial(instance,id,molRepRep,'selectionBase');
    out.selectionMaterialBase = selectionMaterialBase;

    material.overrides = {};
    material.overrides['id'] = this.idMaterial;
    return out;
};


Autodesk.Nano.MolViewer.CPKMeshView.prototype.createSphereGeometry = function createSphereGeometry(id, instance, atomsOn, molRepRep,getUVColor,optionalRadius){



    function computeBoundingSphere (positions,geometry) {

        var box = new THREE.Box3();
        var vector = new THREE.Vector3();


        if ( geometry.boundingSphere === null ) {

            geometry.boundingSphere = new THREE.Sphere();

        }


        if ( positions ) {

            box.makeEmpty();

            var center = geometry.boundingSphere.center;

            for (var i = 0, il = positions.length; i < il; i += 3) {

                vector.set(positions[i], positions[i + 1], positions[i + 2]);
                box.expandByPoint(vector);

            }

            box.center(center);

            // hoping to find a boundingSphere with a radius smaller than the
            // boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

            var maxRadiusSq = 0;

            for (var i = 0, il = positions.length; i < il; i += 3) {

                vector.set(positions[i], positions[i + 1], positions[i + 2]);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));

            }

            geometry.boundingSphere.radius = Math.sqrt(maxRadiusSq);

            if (isNaN(geometry.boundingSphere.radius)) {

                THREE.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.');

            }
        }
    };
    var molModel = instance.molModel;
    var helper = new Autodesk.Nano.MolHelper();
    var dataID = md5(atomsOn);
    var geometry = instance.molMan.view3DMan.gC.getGeometryCache(id,'cpkmesh',dataID);
    if(!geometry) {
        var info = helper.createCPKViewArrays(atomsOn, getUVColor, molModel, optionalRadius);
        geometry = new THREE.InstancedBufferGeometry();
        geometry.copy(new THREE.SphereBufferGeometry(1.0,12,12));
        geometry.addAttribute("translate", new THREE.InstancedBufferAttribute(info.translateArray, 3, 1));
        geometry.addAttribute("radius", new THREE.InstancedBufferAttribute(info.radiusArray, 1, 1));
        geometry.addAttribute("uvArray", new THREE.InstancedBufferAttribute(info.uvArray, 2, 1));
        instance.molMan.view3DMan.gC.addGeometryCache(id,'cpkmesh',geometry,dataID);
        computeBoundingSphere(info.translateArray,geometry);
    }
    return geometry;
};;

/**
 Created by Dave Parker Dec 1, 2016
 */

Autodesk.Nano.MolViewer.RibbonView = function(scene, instance, viewer,options) {

    Autodesk.Nano.MolViewer.MeshView.call(this,scene,instance,viewer);

    this._meshesByEntityID = {}; //not same as _meshes
    // Define an enum for secondary structure types.
    this.SSType = {
        COIL: "c",
        HELIX: "h",
        SHEET: "s"
      };

    // Define an enum for residue polymer type. 
    this.ResiduePolymerType = {
        PROTEIN: "a",
        NUCLEIC_ACID: "n"
    };

    this.ProteinBackboneAtom = "CA";
    this.NucleicAcidBackboneAtom = "C3";

    // Arrays storing cos and sin values for cylinders
    // and hemisphere caps for nucleic acid bases.
    this.baseCylinderParameters = null;
    this.baseCapParameters = null;
};


Autodesk.Nano.MolViewer.RibbonView.prototype = Object.create(Autodesk.Nano.MolViewer.MeshView.prototype);
Autodesk.Nano.MolViewer.RibbonView.prototype.constructor = Autodesk.Nano.MolViewer.MeshView;

// Create the geometry for a ribbon representation for the residues in a chain.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.create = function create(id, options)
{
    var atoms = options.atoms;
    var allAtoms = options.allAtoms;
    var atomsOn = options.atomsOn;
    var indices;
    var bitSet = options.atomRepState.bitSets['ribbon'];
    var mesh = this._meshes[id];
    var entityID = id.split('.')[0];
    // If the mesh exists then set the indices for visible atoms. 
    if (atomsOn && atomsOn.length > 0) {
        if (mesh) { 
            if (!mesh.parent) {
                this.scene.add(mesh);
            }
            this.setNewGeometry(mesh,id,allAtoms,atomsOn,bitSet,'ribbon');

        // Create the mesh. 
        } else {
            mesh = this.createRibbon_scaled(id, options);
            if(!this._meshesByEntityID[entityID]){
                var dude = [];
                dude.push(mesh);
                this._meshesByEntityID[entityID] = dude;
            }else{
                this._meshesByEntityID[entityID].push(mesh);
            }
        }

    // If no atoms are visible then remove the mesh from the scene.
    } else if (this._meshes[id]) {
        var mesh = this._meshes[id];
        if (mesh.parent) { //quick check to see if in scene.
            this.scene.remove(mesh);
        }
    }

};


// Create ribbon geometry using scaled cross sections.
//
// A circular cross section is created at each point on the interpolated curve of backbone atoms. 
// For sheet ribbon geometry the axes of the circular cross section is differentially scaled to 
// create an ellipical cross section.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.createRibbon_scaled = function createRibbon_scaled(id, options) 
{
    //console.log("============================== RibbonView createRibbon_scaled ==============================");
    var startTime = new Date();

    // Get information from the 'options' object.
    var chainID = options.chainID;
    var molRepRep = options.molRepRep;
    var getUVColor = molRepRep.getUVColor;
    var allAtoms = options.allAtoms;
    var atomsOn = options.atomsOn;
    var bitSet = options.atomRepState.bitSets['ribbon'];

    // Get the list of continuous residues.
    //console.log("---------- residue lists ----------");
    var residues;
    var contResidueLists = this.getChainContResidues(chainID)
    //console.log(">>> Number of residue lists " + contResidueLists.length);

    // Create the cos and sin values for a circular cross section.
    var circle_r = 1.0;
    //var numRadialSegments = 15;
    var numRadialSegments = 12;
    var dt = 2.0*Math.PI / numRadialSegments;
    var theta = 0.0;
    var rs, rc;
    var xsectParameters = []
    for (var j = 0; j < numRadialSegments; j++) {
        rs = circle_r * Math.sin(theta);
        rc = circle_r * Math.cos(theta);
        xsectParameters.push([rs, rc]);
        theta += dt;
    }

    // Create the object to store ribbon geometry.
    var xsectGeometry = {
        vertices: [],
        normals: [],
        faces: [],
        atomIDs: [],
        atom: null,
        ssType: null,
        lastSSType: null
    };

    // Create the object to store ribbon boundary type.
    var boundaryType = {
        start: false,
        end: false
    };

    // Iterate over lists of continuous residues.
    var backboneAtoms, backboneVertices, backboneNormals;
    var curveVertices, normalVertices;
    var numDiv;

    for (var ir = 0; ir < contResidueLists.length; ir++) {
        residues = contResidueLists[ir];

        // Get the backbone vertices and normal positions.
        backboneAtoms = this.getBackboneAtoms(residues);
        if (backboneAtoms.lenght === 0) { 
            continue;
        }
        backboneVertices = this.getBackboneVertices(residues);
        backboneNormals = this.getBackboneNormals(residues);

        // Compute the vertices sampled from curves fitted to the backbone vertices and normal positions.
        //numDiv = 6;
        numDiv = 8;
        //numDiv = 4;
        var backboneFitVertices = this.getFitVertices(numDiv, backboneVertices, backboneNormals, backboneAtoms);
        curveVertices = backboneFitVertices.curveVertices; 
        normalVertices = backboneFitVertices.normalVertices; 
        var curveAtoms = backboneFitVertices.curveAtoms;

        // Show some geometry for debugging.
        //this.showSpheres(backboneVertices, 0x007777, 0.60, true);
        //this.showSpheres(backboneNormals, 0x007700, 0.20);
        //this.showSpheres(curveVertices, 0x770000, 0.35, false);
        //this.showPath(curveVertices, 0x770000);
        //this.showSpheres(normalVertices, 0x777700, 0.05);
        //this.showPath(normalVertices, 0x777700);
 
        /* color vertices by ss type.
        var sheetAtomList = []; 
        var coilAtomList = []; 
        var helixAtomList = []; 
        if (0) { 
            for (var k = 0, n = backboneAtoms.length; k < n; k++) {
                var atom = backboneAtoms[k];
                if (atom.ssType === "s") { 
                    sheetAtomList.push(new THREE.Vector3(atom.x, atom.y, atom.z));
                } else if (atom.ssType === "c") { 
                    coilAtomList.push(new THREE.Vector3(atom.x, atom.y, atom.z));
                } else if (atom.ssType === "h") { 
                    helixAtomList.push(new THREE.Vector3(atom.x, atom.y, atom.z));
                }
            }
        } else {
            for (var k = 0, n = curveAtoms.length; k < n; k++) {
                if (curveAtoms[k].ssType === "s") { 
                    sheetAtomList.push(new THREE.Vector3(curveVertices[k].x, curveVertices[k].y, curveVertices[k].z));
                } else if (curveAtoms[k].ssType === "c") { 
                    coilAtomList.push(new THREE.Vector3(curveVertices[k].x, curveVertices[k].y, curveVertices[k].z));
                } else if (curveAtoms[k].ssType === "h") { 
                    helixAtomList.push(new THREE.Vector3(curveVertices[k].x, curveVertices[k].y, curveVertices[k].z));
                }
            }
        }
        this.showSpheres(sheetAtomList, 0x770000, 0.35, false);
        this.showSpheres(coilAtomList, 0x007700, 0.35, false);
        this.showSpheres(helixAtomList, 0x000077, 0.35, false);
        */

        var axisTang = new THREE.Vector3();
        var axisNormal1 = new THREE.Vector3();
        var axisNormal2 = new THREE.Vector3();
        var npt = new THREE.Vector3();
        var lastAtomSsType = backboneAtoms[0].ssType;
        var pt1, pt2, npt1, lastPt1; 
        var atom, atomIndex, lastAtom = null;

        // Generate cross sections along the vertices sampled from curves fitted to 
        // the backbone vertices and normal positions.

        for (var i = 0, numCurveVerts = curveVertices.length; i < numCurveVerts; i++) {
        //for (var i = 0, numCurveVerts = 6; i < numCurveVerts; i++) {
            //console.log("------------------- i " + i + " --------------------");
            pt1 = curveVertices[i];
            npt1 = normalVertices[i];
            if (i === numCurveVerts-1) {
                pt2 = curveVertices[i-1];
                axisTang.subVectors(pt1, pt2);
            } else {
                pt2 = curveVertices[i+1];
                axisTang.subVectors(pt2, pt1);
            }

            // Calculate the vectors defining the plane (axisNormal1, axisNormal2) 
            // the cross section lies in. 
            axisTang.normalize();
            axisNormal1.subVectors(pt1, npt1);
            axisNormal1.normalize();
            axisNormal2.crossVectors(axisTang, axisNormal1);

            // Get the atom associated with this curve point.
            //atomIndex = Math.ceil(i / numDiv) - 1;
            atomIndex = Math.ceil((i+1) / numDiv) - 1;
            if (atomIndex < 0) { 
                atomIndex = 0; 
            }
            atom = backboneAtoms[atomIndex];
            xsectGeometry.atom = atom;
            xsectGeometry.ssType = curveAtoms[i].ssType;
            xsectGeometry.lastSSType = null;
            /*
            console.log(">>> i " + i + "  atom ID " + atom.id + "  res " + atom.residue + "  res ID " + atom.resNumber);
            console.log(">>> atom index " + atomIndex);
            console.log(">>> atom ID " + atom.id);
            console.log(">>> " + i + "  atom ID " + atom.id);
            console.log(">>> atom res ID " + atom.resNumber);
            console.log(">>> atom ssType " + atom.ssType);
            console.log(">>> i " + i + "  atom ID " + atom.id + "  res " + atom.residue + "  res ID " + atom.resNumber);
            console.log("    ssType " + atom.ssType);
            */

            // Set the boundary type that is used to cap ribbon geometry.
            if (i == 0) {
                boundaryType.start = true;
                boundaryType.end = false;
            } else if (i === numCurveVerts-1) { 
                boundaryType.start = false;
                boundaryType.end = true;
            } else {
                boundaryType.start = false;
                boundaryType.end = false;
            }
        
            // Add cross section geometry.
            this.addXsectGeometry(xsectGeometry, pt1, xsectParameters, axisNormal1, axisNormal2, 
                numRadialSegments, boundaryType);
            lastAtomSsType = atom.ssType; 
            lastAtom = atom; 
            xsectGeometry.lastSSType = curveAtoms[i].ssType;
        }

        // Create nucleic acid base geometry.
        this.createBaseGeometry(xsectGeometry, backboneVertices, backboneNormals, backboneAtoms, residues);
    }

    var endTime = new Date();
    var elapsedTime = (endTime - startTime) / 1000.0;
    console.log("Time to create ribbon geometry for chain " + chainID + " " + backboneAtoms.length, " residues: " + 
        elapsedTime + " sec");
    startTime = endTime; 

    // For debugging.
    //this.showGeometry(xsectGeometry);

    // Create buffer geometry.
    var bufferGeometry = this.createBufferGeometry(id,xsectGeometry, getUVColor,atomsOn);

    // Get the mesh material.
    var material = molRepRep.colorMaterialAtom;
    material.packedNormals = false;
    material.wireframe = true;
 
    // Create the mesh.
    var mesh = new THREE.Mesh(bufferGeometry, material);
    mesh.matrixAutoUpdate = false;
    mesh.nanoID = id; //needed for selection
    mesh.atomsOn = atomsOn; //will be used eventually for transparency
    this._meshes[id] = mesh;
    var indices;
    this.scene.add(mesh);
    if(allAtoms && allAtoms.length != atomsOn.length){
        this.setNewGeometry(mesh,id,allAtoms,atomsOn,bitSet,'ribbon'); //this will remove mesh
    }


    var endTime = new Date();
    var elapsedTime = (endTime - startTime) / 1000.0;
    console.log("Time to create ribbon buffer geometry for chain " + chainID + " " + backboneAtoms.length, " residues: " + 
        elapsedTime + " sec");
    if (backboneAtoms[0].detailType === this.ProteinBackboneAtom) {
        console.log("Chain is protein.");
    } else {
        console.log("Chain is nucleic acid.");
    }

    return mesh;
};

// Create a THREE.js BufferGeometry from the ribbon geometry. 

Autodesk.Nano.MolViewer.RibbonView.prototype.createBufferGeometry = function createBufferGeometry(id,geometry, getUVColor,atomsOn)
{
    // Duplicate vertices. 
    var faceToAtom = this.dupeVertsAndSetAtomIndex(geometry);

    // Create an array of vertices, normals and uvs. 
    var numVerts = geometry.vertices.length;
    var vertices = new Float32Array(3*numVerts);
    var normals = new Float32Array(3*numVerts);
    var uvs = new Float32Array(2*numVerts);
    var uv = {u: 0, v: 0};
    var n = 0, m = 0;
    var atomID;
    for (var i = 0; i < numVerts; i++) {
        vertices[n] = geometry.vertices[i].x;
        vertices[n+1] = geometry.vertices[i].y;
        vertices[n+2] = geometry.vertices[i].z;
        //
        normals[n] = geometry.normals[i].x;
        normals[n+1] = geometry.normals[i].y;
        normals[n+2] = geometry.normals[i].z;
        //
        atomID = geometry.atomIDs[i];
        getUVColor.getUV2(atomID, uv);
        uvs[m++] = uv.u;
        uvs[m++] = uv.v;
        n += 3;
    }

    // Create an array of face indices into the vertices array. 
    var numFaces = geometry.faces.length;
    var indices = new Uint32Array(3*numFaces);
    n = 0;
    for (var i = 0; i < numFaces; i++) {
        indices[n] = geometry.faces[i].a; 
        indices[n+1] = geometry.faces[i].b; 
        indices[n+2] = geometry.faces[i].c; 
        n += 3;
    }

    var bufferGeometry = new THREE.BufferGeometry();
    bufferGeometry.addAttribute("position", new THREE.BufferAttribute(vertices, 3));
    bufferGeometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
    bufferGeometry.addAttribute('index', new THREE.BufferAttribute(indices, 1));
    bufferGeometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    bufferGeometry.computeBoundingSphere();
    bufferGeometry.origIndex = new Uint32Array(indices);
    bufferGeometry.faceToAtom = faceToAtom;
    var dataID = md5(atomsOn);

    this.instance.molMan.view3DMan.gC.addGeometryCache(id,'ribbon',bufferGeometry,dataID);

    return bufferGeometry;
};

// Show the ribbon geometry using a THREE.js Mesh object.
//
// This is used only for debugging.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.showGeometry = function showGeometry(geometry)
{
    var material = new THREE.MeshPhongMaterial({
        ambient: 0x030303,
        color: 0x770000,
        side: THREE.DoubleSide,
        opacity: 1.0,
        specular: 0x111111,
        shininess: 1,
        wireframe: true,
        shading: THREE.SmoothShading,
        //shading: THREE.FlatShading,
        reflectivity: 0,
        depthTest: true,
        depthWrite: true
    });

    var faceToAtom = this.dupeVertsAndSetAtomIndex(geometry);

    var geometry = new THREE.Geometry();
    geometry.vertices = xsectGeometry.vertices; 
    geometry.faces = xsectGeometry.faces; 

    // Compute vertex normals.
    var face, i1, i2, i3;
    for (var i = 0; i < geometry.faces.length; i++) {
        face = geometry.faces[i];
        i1 = face.a;
        i2 = face.b;
        i3 = face.c;
        face.vertexNormals[0] = xsectGeometry.normals[i1].clone();
        face.vertexNormals[1] = xsectGeometry.normals[i2].clone();
        face.vertexNormals[2] = xsectGeometry.normals[i3].clone();
    }

    geometry.normalsNeedUpdate = true;
    var mesh = new THREE.Mesh(geometry, material);
    this.scene.add(mesh);
};

// Add cross section geometry.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.addXsectGeometry = function addXsectGeometry(geometry, center, 
    xsectParameters, axisNormal1, axisNormal2, numRadialSegments, boundaryType)
{
    var atom = geometry.atom;
    var s1, s2;
    var vindex;
    var ssType = geometry.ssType;
    //var ssType = atom.ssType;

    // Scale the cross section depending on secondary structure type.
    // If the atom is from a nucleic acid then set the scales for a thin ellipse. 
    if (atom.detailType !== this.ProteinBackboneAtom) {
        s1 = 0.5;
        s2 = 2.0;
    //} else if (atom.ssType === this.SSType.COIL) {
    } else if (ssType === this.SSType.COIL) {
        s1 = 0.3;
        s2 = 0.3;
    } else {
        s1 = 1.2;
        s2 = 0.3;
    }

    /*
    s1 = 0.3;
    s2 = 0.3;
    */

    if (boundaryType.start) {
        vindex = this.addXsectCapVertex(geometry, center, axisNormal1, axisNormal2);
        this.addXsectVertices(geometry, center, xsectParameters, s1, s2, axisNormal1, axisNormal2);
        this.addXsectCapFaces(geometry, vindex, numRadialSegments, boundaryType);
        return;
    }

    this.addXsectVertices(geometry, center, xsectParameters, s1, s2, axisNormal1, axisNormal2);
    this.addXsectFaces(geometry, numRadialSegments);

    if (boundaryType.end) {
        vindex = this.addXsectCapVertex(geometry, center, axisNormal1, axisNormal2);
        this.addXsectCapFaces(geometry, vindex, numRadialSegments, boundaryType);
    }

};

// Create an array mapping a face indices to atom IDs.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.dupeVertsAndSetAtomIndex = function dupeVertsAndSetAtomIndex(geometry)
{
    //console.log("---------------------- dupeVertsAndSetAtomIndex -----------------");
    var vertices = geometry.vertices;
    var numVerts = vertices.length;
    var normals = geometry.normals;
    var faces = geometry.faces;
    var numFaces = faces.length;
    var atomIDs = geometry.atomIDs;

    var i1, i2, i3;
    var id1, id2, id3;
    var v1,v2,v3;
    var n1, n2, n3;
    var faceToAtom = new Int32Array(faces.length);

    for (var i = 0; i < numFaces; i++) {
        i1 = faces[i].a;
        i2 = faces[i].b;
        i3 = faces[i].c;
        v1 = vertices[i1]; 
        v2 = vertices[i2]; 
        v3 = vertices[i3]; 
        id1 = atomIDs[i1]; 
        id2 = atomIDs[i2]; 
        id3 = atomIDs[i3]; 

        if (id1 !== id2) { // a and not b
            vertices.push(v2);
            atomIDs.push(id1); 
            normals.push(normals[i2]);
            faces[i].b = numVerts;
            numVerts += 1;

            if (id1 !== id3) {  //a and not b nor c
                vertices.push(v3);
                atomIDs.push(id1); 
                normals.push(normals[i3]);
                faces[i].c = numVerts;
                numVerts += 1;
            }
        } else if (id1 !== id3) { //a and b and not c
            vertices.push(v3);
            atomIDs.push(id1); 
            normals.push(normals[i3]);
            faces[i].c = numVerts;
            numVerts += 1;
        }
        faceToAtom[i] = id1;
    }
    return faceToAtom;
};


// Create an array mapping face indices to atom IDs.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.createFaceToAtomIndex = function createFaceToAtomIndex(geometry) 
{
    var i1,i2,i3;
    var faces = geometry.faces;
    var numFaces = faces.length;
    var atomIDs = geometry.atomIDs;
    var faceToAtom = new Int32Array(numFaces);
    for (var i = 0; i < numFaces; i++) {
        i1 = faces[i].a;
        i2 = faces[i].b;
        i3 = faces[i].c;
        faceToAtom[i] = atomIDs[i1];
    }
    return faceToAtom;
};


// Create nucleic acid base geometry.
//
// A capped cylinder is created for each backbone position.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.createBaseGeometry = function createBaseGeometry(geometry, backboneVertices,
    backboneNormals, backboneAtoms, residues) 
{
    var pt1, pt2, npt1 = new THREE.Vector3();
    var axis = new THREE.Vector3();
    var axisNormal = new THREE.Vector3();
    var v = new THREE.Vector3();
    var atom;
    var baseRadius = 0.5;
    var baseLength;
    var numCylSides = 8;
    var baseDirAtoms, cAtom, nAtom;
    var residue, baseDirAtoms, cAtom, nAtom;

    for (var i = 0, numBackboneVerts = backboneVertices.length; i < numBackboneVerts; i++) {
        if (backboneAtoms[i].detailType === this.ProteinBackboneAtom) {
                continue;
        }
        //console.log("===================== addCappedCylinder " + i + " ======================");
        residue = residues[i];
        baseDirAtoms = this.getNucleicAcidBaseDirAtoms(residue);
        cAtom = baseDirAtoms["C"];
        nAtom = baseDirAtoms["N"];
        pt1 = backboneVertices[i];
        npt1.set(nAtom.x, nAtom.y, nAtom.z);
        // npt1 = backboneNormals[i];
        if (i === numBackboneVerts-1) {
           pt2 = backboneVertices[i-1];
        } else {
           pt2 = backboneVertices[i+1];
        }
        axis.subVectors(npt1, pt1);
        baseLength = axis.length();
        axis.normalize();
        v.subVectors(pt2, pt1);
        var dp = axis.dot(v);
        axisNormal.x = v.x - dp*axis.x;
        axisNormal.y = v.y - dp*axis.y;
        axisNormal.z = v.z - dp*axis.z;
        axisNormal.normalize();
        geometry.atom = backboneAtoms[i];
        this.addCappedCylinder(geometry, pt1, axis, axisNormal, baseLength, baseRadius, numCylSides);
    }
};

// Add a capped cylinder to a geometry.

Autodesk.Nano.MolViewer.RibbonView.prototype.addCappedCylinder = function addCappedCylinder(geometry, origin, axis, 
    axisNormal, length, radius, numSides)
{
    /*
    console.log("===================== addCappedCylinder ======================");
    console.log(">>> axis " + "  " + axis.x + "  " + axis.y + "  " + axis.z);
    console.log(">>> axisNormal " + "  " + axisNormal.x + "  " + axisNormal.y + "  " + axisNormal.z);
    */
    var rs, rc;
    var x, y, z;
    var nx, ny, nz;
    var v1 = new THREE.Vector3(axisNormal.x, axisNormal.y, axisNormal.z);
    var v2 = new THREE.Vector3();
    v2.crossVectors(axis, v1);
    var atomID = geometry.atom.id;

    if (!this.baseCylinderParameters) { 
         this.baseCylinderParameters = [];
         var dt = 2.0*Math.PI / numSides;
         var theta = 0.0;
         for (var j = 0; j < numSides; j++) {
             rs = Math.sin(theta);
             rc = Math.cos(theta);
             this.baseCylinderParameters.push([rs,rc]);
             theta += dt;
         }
    }

    // Add vertices.
    var numVerts = geometry.vertices.length;
    for (var j = 0; j < numSides; j++) {
        rs = this.baseCylinderParameters[j][0];
        rc = this.baseCylinderParameters[j][1];
        nx = rc*v1.x + rs*v2.x;
        ny = rc*v1.y + rs*v2.y;
        nz = rc*v1.z + rs*v2.z;
        x = origin.x + radius*nx; 
        y = origin.y + radius*ny; 
        z = origin.z + radius*nz; 
        geometry.vertices.push(new THREE.Vector3(x, y, z));
        geometry.normals.push(new THREE.Vector3(nx, ny, nz));
        geometry.atomIDs.push(atomID);
        x += length*axis.x; 
        y += length*axis.y; 
        z += length*axis.z; 
        geometry.vertices.push(new THREE.Vector3(x, y, z));
        geometry.normals.push(new THREE.Vector3(nx, ny, nz));
        geometry.atomIDs.push(atomID);
    }

    // Add connectivity.
    var i1, i2, i3, i4;
    var n = numVerts;
    for (var i = 0; i < numSides; i++) {
        i1 = 2*i;
        i2 = 2*i+1;
        if (i === numSides-1) {
            i3 = 0;
            i4 = 1;
        }
        else {
            i3 = i1 + 2;
            i4 = i2 + 2;
        }
        geometry.faces.push(new THREE.Face3(i1+n, i3+n, i2+n));
        geometry.faces.push(new THREE.Face3(i2+n, i3+n, i4+n));
    }

    // Add a hemisphere cap.
    var sphereSub = 6;
    x = origin.x + length*axis.x; 
    y = origin.y + length*axis.y; 
    z = origin.z + length*axis.z; 
    var hemiSphereOrigin = new THREE.Vector3(x, y, z);
    this.addHemiSphere(geometry, hemiSphereOrigin, axis, v1, v2, radius, numSides, sphereSub);
};

// Create an oriented hemisphere geometry.
//
// The hemisphere is half of a UV sphere. A geodesic would be better but its vertices need
// to match up with a cylinder when used for capping. This would restrict the cylicer resolution.
//
// The hemisphere is oriented along the 'axis' vector. The vectors 'v' and 'w'
// define the hemisphere coordinate frame. The vertices of the first slice of 
// the hemisphere are in the plane given by 'origin', 'v' and 'w'.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.addHemiSphere = function addHemiSphere(geometry, origin, axis, v, w,
    radius, cylSub, sphereSub)
{
    /*
    console.log("===================== addHemiSphere ======================");
    console.log(">>> origin " + "  " + origin.x + "  " + origin.y + "  " + origin.z);
    console.log(">>> axis " + "  " + axis.x + "  " + axis.y + "  " + axis.z);
    */
    var u = new THREE.Vector3(axis.x, axis.y, axis.z);
    u.normalize();
    u.negate();
    var atomID = geometry.atom.id;


    // Generate the geometry.
    var numVerts = geometry.vertices.length; 
    var N = cylSub;
    var M = sphereSub;
    var mf = Math.PI/M;
    var nf = 2.0*Math.PI/N;
    var r = radius;
    var f;
    var x, y, z; 
    var nx, ny, nz; 
    var sinf, cosf, snf, cnf;
    var numNewVerts = 0;
    var sliceNum = 1;

    if (!this.baseCapParameters) {
        this.baseCapParameters = [];
        for (var m = M/2; m < M; m++) {
            f = mf*m;
            sinf = r * Math.sin(f);
            cosf = r * Math.cos(f);
            for (var n = 0; n < N; n++) {
                snf = Math.sin(nf*n);
                cnf = Math.cos(nf*n);
                this.baseCapParameters.push([sinf*cnf, sinf*snf, cosf]);
            }
        }
    }

    var parmIndex = 0;
    for (var m = M/2; m < M; m++) {
        //f = mf*m;
        //sinf = r * Math.sin(f);
        //cosf = r * Math.cos(f);
        for (var n = 0; n < N; n++) {
            //snf = Math.sin(nf*n);
            //cnf = Math.cos(nf*n);
            sinf_cnf = this.baseCapParameters[parmIndex][0];
            sinf_snf = this.baseCapParameters[parmIndex][1];
            cosf = this.baseCapParameters[parmIndex][2];
            nx = sinf_cnf*v.x + sinf_snf*w.x + cosf*u.x;
            ny = sinf_cnf*v.y + sinf_snf*w.y + cosf*u.y;
            nz = sinf_cnf*v.z + sinf_snf*w.z + cosf*u.z;
            x = origin.x + nx;
            y = origin.y + ny; 
            z = origin.z + nz; 
            geometry.vertices.push(new THREE.Vector3(x, y, z));
            geometry.normals.push(new THREE.Vector3(nx, ny, nz));
            geometry.atomIDs.push(atomID);
            numNewVerts += 1;
            parmIndex += 1;
        }
    }

    // Add the last point at the top.
    nx = -r*u.x;
    ny = -r*u.y;
    nz = -r*u.z;
    x = origin.x + nx;
    y = origin.y + ny;
    z = origin.z + nz;
    geometry.vertices.push(new THREE.Vector3(x, y, z));
    geometry.normals.push(new THREE.Vector3(nx, ny, nz));
    geometry.atomIDs.push(atomID);
    numNewVerts += 1;

    // Add connectivity for triangles.
    var i1, i2, j1, j2, j3, j4;
    var n = numVerts;
    for (var i = 0; i < M/2-1; i++) {
        i1 = N*i;
        i2 = i1 + N;
        for (var j = 0; j < N; j++) {
            j1 = i1 + j;
            j4 = i2 + j;
            if (j == N-1) {
                j2 = i1;
                j3 = i2;
            }
            else {
                j2 = i1 + j + 1;
                j3 = i2 + j + 1;
            }
            geometry.faces.push(new THREE.Face3(j1+n, j2+n, j3+n));
            geometry.faces.push(new THREE.Face3(j1+n, j3+n, j4+n));
        }

        // Hemisphere top.
        i1 = numNewVerts-N-1;
        i2 = numNewVerts-1;
        for (var j = 0; j < N; j++) {
            j1 = i1 + j;
            if (j == N-1) {
                j2 = i1;
            }
            else {
                j2 = i1 + j + 1;
            }
            geometry.faces.push(new THREE.Face3(j1+n, j2+n, i2+n));
        }
    }
};

// Get the vertices and normals sampled from a spline fit to the input vertices and normals.
//
// An array is also created that associates an atom with each point on the curve. The sampled points 
// between two atom vertices are equally assigned atoms from each end. This provides a better
// transition between different secondary structure types.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.getFitVertices = function getFitVertices(numDiv, backboneVertices, 
    backboneNormals, backboneAtoms)
{
    var useThreeSpline = false;
    //var useThreeSpline = true;
    var curveVertices, normalVertices;
    var curveAtoms = [];
    var lastSStype = null;

    if (useThreeSpline) { 
        var numSegements = numDiv*backboneVertices.length; 
        var curve = new THREE.SplineCurve3(backboneVertices);
        curveVertices = curve.getPoints(numSegements);
        var normalCurve = new THREE.SplineCurve3(backboneNormals);
        normalVertices = normalCurve.getPoints(numSegements);
    } else {
        var scale = 1.0;
        var connected = false;
        var atom, nextAtom;
        curveVertices = this.getSplinePoints(backboneVertices, numDiv, scale, connected);
        normalVertices = this.getSplinePoints(backboneNormals, numDiv, scale, connected);
        // Set the atom associated with each point on the curve.
        for (var i = 0, numAtoms = backboneAtoms.length; i < numAtoms-1; i++) {
            atom = backboneAtoms[i];
            nextAtom = backboneAtoms[i+1];
            for (var j = 0; j < numDiv/2; j++) {
                curveAtoms.push(atom);       
            }
            for (var j = 0; j < numDiv/2; j++) {
                curveAtoms.push(nextAtom);       
            }
        }
        curveAtoms.push(nextAtom);       

        /*
        for (var i = 0, n = curveVertices.length; i < n; i++) {
            var v = curveVertices[i];
            console.log(">>> " + i + " " + v.x + "  " + v.y + "  " + v.z);
            for (var j = 0, m = backboneVertices.length; j < m; j++) {
                var u = backboneVertices[j];
                var d = u.distanceTo(v);
                if (d < 0.001) {
                console.log("    " + j + " " + u.x + "  " + u.y + "  " + u.z);
                }
            }
        }
        */
    }

    return { curveVertices: curveVertices, normalVertices: normalVertices, curveAtoms: curveAtoms}; 
};

// Add cross section vertices to the given geometry.
//
// The cross section is scaled along its axis 'axis1' and 'axis2' by 's1' and 's2'.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.addXsectVertices = function addXsectVertices(geometry, center, xsectParameters, 
    s1, s2, axis1, axis2) 
{
    var rs, rc, x, y, z, nx, ny, nz, mag;
    var atomID = geometry.atom.id;
    //console.log("[addXsectVertices] atomID " + atomID + "  res " + geometry.atom.resNumber);
    var verts = [];

    for (var i = 0, n = xsectParameters.length; i < n; i++) {
        rs = xsectParameters[i][0];
        rc = xsectParameters[i][1];
        nx = (rc/s1)*axis1.x + (rs/s2)*axis2.x;
        ny = (rc/s1)*axis1.y + (rs/s2)*axis2.y;
        nz = (rc/s1)*axis1.z + (rs/s2)*axis2.z;
        mag = Math.sqrt(nx*nx + ny*ny + nz*nz);
        geometry.normals.push(new THREE.Vector3(nx/mag, ny/mag, nz/mag));
        x = center.x + s1*rc*axis1.x + s2*rs*axis2.x;
        y = center.y + s1*rc*axis1.y + s2*rs*axis2.y;
        z = center.z + s1*rc*axis1.z + s2*rs*axis2.z;
        geometry.vertices.push(new THREE.Vector3(x, y, z));
        geometry.atomIDs.push(atomID);
    }
};

// Add a vertex to cap the end of a ribbon.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.addXsectCapVertex = function addXsectCapVertex(geometry, center, v1, v2) 
{
    geometry.vertices.push(new THREE.Vector3(center.x, center.y, center.z));
    var normal = new THREE.Vector3();
    normal.crossVectors(v1, v2);
    normal.negate();
    geometry.normals.push(normal);
    geometry.atomIDs.push(geometry.atom.id);
    return geometry.vertices.length - 1;
};

// Add square cross section vertices to the given geometry.
//
// The cross section is scaled along its axis 'axis1' and 'axis2' by 's1' and 's2'.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.addSquareXsectVertices = function addSquareXsectVertices(geometry, sideGeometry,
    center, xsectParameters, s1, s2, axis1, axis2)
{
    var rs, rc, x, y, z;

    for (var i = 0, n = xsectParameters.length; i < n; i++) {
        rs = xsectParameters[i][0];
        rc = xsectParameters[i][1];
        x = center.x + s1*rc*axis1.x + s2*rs*axis2.x;
        y = center.y + s1*rc*axis1.y + s2*rs*axis2.y;
        z = center.z + s1*rc*axis1.z + s2*rs*axis2.z;
        var pt = new THREE.Vector3(x, y, z);
        geometry.vertices.push(pt);
        sideGeometry.vertices.push(pt);
    }
};

// Add cross section faces to a geometry.

Autodesk.Nano.MolViewer.RibbonView.prototype.addXsectFaces = function addXsectFaces(geometry, numRadialSegments)
{ 
    var istart = geometry.vertices.length-2*numRadialSegments;
    var i1, i2, i3, j1, j2, j3;

    for (var i = istart; i < istart+numRadialSegments; i++) {
        i1 = i;
        i2 = i + 1;
        i3 = i + numRadialSegments;
        if (i2 === istart+numRadialSegments) {
            i2 = istart;
        }
        geometry.faces.push(new THREE.Face3(i1, i2, i3));
        j1 = i2;
        j2 = i2 + numRadialSegments;
        j3 = i3;
        geometry.faces.push(new THREE.Face3(j1, j2, j3));
    }
};

// Add cross section cap faces to a geometry.
//
// The faces connected to a vertex in the center of a cross section.
// 
Autodesk.Nano.MolViewer.RibbonView.prototype.addXsectCapFaces = function addXsectCapFaces(geometry, vindex, 
    numRadialSegments, boundaryType)
{
    var offset;
    if (boundaryType.start) {
        offset = 0;
    } else {
        offset = 1;
    }
    var istart = geometry.vertices.length - numRadialSegments - offset;
    var i1, i2, i3; 

    for (var i = istart; i < istart+numRadialSegments; i++) {
        i1 = i;
        i2 = i+1;
        if (i2 === istart+numRadialSegments) {
            i2 = istart;
        }
        if (boundaryType.start) {
            geometry.faces.push(new THREE.Face3(i1, vindex, i2));
        } else {
            geometry.faces.push(new THREE.Face3(i1, i2, vindex));
        }
    }
};

// Add square cross section faces to a geometry.

Autodesk.Nano.MolViewer.RibbonView.prototype.addSquareXsectFaces = function addSquareXsectFaces(geometry, sideGeometry,
    numVerts, numRadialSegments)
{
    var i1,i2,i3;
    var j1,j2,j3;
    for (var i = numVerts; i < numVerts+4; i += 2) {
        i1 = i;
        i2 = i+1;
        i3 = i+numRadialSegments;
        if (i2 === numVerts+numRadialSegments) {
            i2 = numVerts;
        }
        //geometry.faces.push(new THREE.Face3(i1, i3, i2));
        geometry.faces.push(new THREE.Face3(i1, i2, i3));
        j1 = i2;
        j2 = i2+numRadialSegments;
        j3 = i3;
        //geometry.faces.push(new THREE.Face3(j1, j3, j2));
        geometry.faces.push(new THREE.Face3(j1, j2, j3));
    }

    for (var i = numVerts+1; i < numVerts+4; i += 2) {
        i1 = i;
        i2 = i+1;
        i3 = i+numRadialSegments;
        if (i2 === numVerts+numRadialSegments) {
            i2 = numVerts;
        }
        sideGeometry.faces.push(new THREE.Face3(i1, i2, i3));
        j1 = i2;
        j2 = i2+numRadialSegments;
        j3 = i3;
        sideGeometry.faces.push(new THREE.Face3(j1, j2, j3));
    }

    return numVerts + numRadialSegments;
};

// Show an array of vertices as a continuous line.
//
// Used for debugging.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.showPath = function showPath(vertices, color) 
{
    var geometry = new THREE.Geometry();
    geometry.vertices = vertices;
    var material = new THREE.LineBasicMaterial({ color: color });
    var mesh = new THREE.Line(geometry, material);
    this.scene.add(mesh);
};

// Show a sphere at each vertex in the given array of vertices.
//
// Used for debugging.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.showSpheres = function showSpheres(vertices, color, radius, useLines) 
{
    var wireframe = false;
    if (useLines !== undefined) {
        wireframe = useLines;
    }

    var material = new THREE.MeshPhongMaterial
    ({
        ambient: 0x030303,
        color: color,
        specular: 0x111111,
        shininess: 10,
        shading: THREE.SmoothShading,
        wireframe: wireframe,
        reflectivity: 0,
        transparent: false
    });

    var material1 = new THREE.MeshPhongMaterial
    ({
        ambient: 0x030303,
        color: 0x770077,
        specular: 0x111111,
        wireframe: wireframe,
        shininess: 10,
        shading: THREE.SmoothShading,
        reflectivity: 0,
        transparent: false
    });

    var x, y, z;
    var geometry, mesh;

    for (var i = 0, n = vertices.length; i < n; i++) {
        x = vertices[i].x;
        y = vertices[i].y;
        z = vertices[i].z;
        geometry = new THREE.SphereGeometry(radius, 12, 12);
        if (i === -1) {
            mesh = new THREE.Mesh(geometry, material1);
        } else {
            mesh = new THREE.Mesh(geometry, material);
        }
        mesh.translateX(x);
        mesh.translateY(y);
        mesh.translateZ(z);
        mesh.updateMatrix();
        this.scene.add(mesh);
    }
};


// Get the vertices of the backbone atoms for a chain.

Autodesk.Nano.MolViewer.RibbonView.prototype.getBackboneVertices = function getBackboneVertices(residues) 
{
    var backboneAtom;
    var backboneVertices = [];
    var backboneAtoms = this.getBackboneAtoms(residues);
    for (var i = 0, numAtoms = backboneAtoms.length; i < numAtoms; i++) {
        var pt = new THREE.Vector3();
        pt.x = backboneAtoms[i].x;
        pt.y = backboneAtoms[i].y;
        pt.z = backboneAtoms[i].z;
        backboneVertices.push(pt);
    }
    return backboneVertices;
};

// Get the backbone normal positions.

Autodesk.Nano.MolViewer.RibbonView.prototype.getBackboneNormals = function getBackboneNormals(residues) 
{
    var cAtom, oAtom, caAtom, nAtom;
    var lastNormal, normalPos;
    var zeroNormal = new THREE.Vector3(0.0, 0.0, 0.0);
    var normal = new THREE.Vector3(0.0, 0.0, 0.0);
    var backboneNormals = [];
    var resAtoms;
    var name, nAtomName;
    var mag;
    var residue, lastResidue = null;
    var atomList;
    var baseDirAtoms;
    lastNormal = zeroNormal;

    for (var resID in residues) {
        residue = residues[resID];
        resAtoms = residues[resID].atoms;

        // Calculate the normal for an amino acid.
        if (residue.type === this.ResiduePolymerType.PROTEIN) {
            atomList = {numAtoms:3, C:null, CA:null, O:null}; 
            this.getResidueAtoms(residue, atomList);
            cAtom = atomList["C"]; 
            caAtom = atomList["CA"]; 
            oAtom = atomList["O"];
            if ((cAtom !== null) && (oAtom !== null) && (caAtom != null)) { 
                normalPos = new THREE.Vector3();
                normal.x = oAtom.x - cAtom.x;
                normal.y = oAtom.y - cAtom.y;
                normal.z = oAtom.z - cAtom.z;
                normal.normalize();
                if (normal.dot(lastNormal) < 0.0) {
                        normal.negate();
                }
                normalPos.x = normal.x + lastNormal.x + caAtom.x;
                normalPos.y = normal.y + lastNormal.y + caAtom.y;
                normalPos.z = normal.z + lastNormal.z + caAtom.z;
                backboneNormals.push(normalPos);
                lastNormal.x = normal.x;
                lastNormal.y = normal.y;
                lastNormal.z = normal.z;
            }

        // Calculate the normal for a nucleic acid.
        } else if (residues[resID].type === this.ResiduePolymerType.NUCLEIC_ACID) {
            baseDirAtoms = this.getNucleicAcidBaseDirAtoms(residue);
            cAtom = baseDirAtoms["C"];
            nAtom = baseDirAtoms["N"];

            if ((cAtom !== null) && (nAtom !== null)) { 
                normalPos = new THREE.Vector3();
                normal.x = nAtom.x - cAtom.x;
                normal.y = nAtom.y - cAtom.y;
                normal.z = nAtom.z - cAtom.z;
                mag = normal.length();
                normal.normalize();
                if (normal.dot(lastNormal) < 0.0) {
                    normal.negate();
                }
                normalPos.x = mag*normal.x + cAtom.x;
                normalPos.y = mag*normal.y + cAtom.y;
                normalPos.z = mag*normal.z + cAtom.z;
                backboneNormals.push(normalPos);
                lastNormal.x = normal.x;
                lastNormal.y = normal.y;
                lastNormal.z = normal.z;
            }
        }
        lastResidue = residue;
    }
    return backboneNormals;
};

// Get lists of continous residues for the given chain.

Autodesk.Nano.MolViewer.RibbonView.prototype.getChainContResidues = function getChainContResidues(chainID)
{
    var chain = this.instance.molModel.chains[chainID];
    var residues = chain.residues;
    var contResidueLists = [];
    var residueList = [];
    var residue, lastResidue = null;
    for (var resID in residues) {
        residue = residues[resID];
        if (lastResidue && this.backboneHasBreak(residue, lastResidue)) {
            //console.log(">>> Break in chain at residue " + residue.id);
            contResidueLists.push(residueList);
            residueList = [];
            lastResidue = null;
        }
        residueList.push(residue);
        lastResidue = residue;
    }
    contResidueLists.push(residueList);
    return contResidueLists;
};

// Get the backbone atoms for the given chain.

Autodesk.Nano.MolViewer.RibbonView.prototype.getBackboneAtoms = function getBackboneAtoms(residues)
{
    var backboneAtom;
    var backboneAtoms = [];
    var backboneAtomsList = [];
    var residue, lastResidue = null;

    for (var resID in residues) {
        residue = residues[resID];
        if (residue.type === this.ResiduePolymerType.PROTEIN) {
            backboneAtom = this.ProteinBackboneAtom;
        } else {
            backboneAtom = this.NucleicAcidBackboneAtom;
        }
        var resAtoms = residue.atoms;
        for (var i = 0, numAtoms = resAtoms.length; i < numAtoms; i++) {
            if (resAtoms[i].detailType.substring(0, 2) === backboneAtom) {
                backboneAtoms.push(resAtoms[i]);
            }
        }
        lastResidue = residue;
    }
    return backboneAtoms;
};

Autodesk.Nano.MolViewer.RibbonView.prototype.backboneHasBreak = function backboneHasBreak(currentResidue, lastResidue)
{
    var cnBreakCutoff = 1.47*1.47;     // Protein C-N atom distance cutoff (bond length)^2.
    var opBreakCutoff = 1.60*1.60;     // Nucleic acid O-P atom distance cutoff (bond length)^2.
    var tol = 0.1*0.1;
    var isBroken = false;
    var resAtoms, cAtom, nAtom, oAtom, pAtom;
    var dx, dy, dz, dist, resnDiff;

    // Check protein C-N atom distance.

    if (currentResidue.type === this.ResiduePolymerType.PROTEIN) {
        cAtom = lastResidue.atoms.filter(function(atom){return atom.detailType === "C";})[0];
        nAtom = currentResidue.atoms.filter(function(atom){return atom.detailType === "N";})[0];
        if (cAtom && nAtom) {
            dx = cAtom.x - nAtom.x;
            dy = cAtom.y - nAtom.y;
            dz = cAtom.z - nAtom.z;
            dist = dx*dx + dy*dy + dz*dz;
            if (dist > cnBreakCutoff-tol) { 
                isBroken = true;
            }
        }

    // Check nucleic acid O-P atom distance. If the residue IDs differ by 1
    // then don't break the chain. This is for DNA origami structures where
    // the non-physical crossovers are still wanted.

    } else if (currentResidue.type === this.ResiduePolymerType.NUCLEIC_ACID) {
        oAtom = lastResidue.atoms.filter(function(atom){return atom.detailType === "O3'";})[0];
        pAtom = currentResidue.atoms.filter(function(atom){return atom.detailType === "P";})[0];
        if (oAtom && pAtom) {
            dx = oAtom.x - pAtom.x;
            dy = oAtom.y - pAtom.y;
            dz = oAtom.z - pAtom.z;
            dist = dx*dx + dy*dy + dz*dz;
            resnDiff = parseInt(oAtom.resNumber) - parseInt(pAtom.resNumber);
            if ((dist > opBreakCutoff-tol) && (Math.abs(resnDiff) != 1)) { 
                isBroken = true;
            }
        }
    }

    return isBroken;
};



// Get the points on a spline fit between N points.
//
// A piecewise cubic spline is fit beteen the given control 'points[]' and sampled at 
// 'subdiv-2' number of locations between points.

Autodesk.Nano.MolViewer.RibbonView.prototype.getSplinePoints = function createSpline(points, subdiv, scale, connected) 
{
    var i, j;
    var inTan = new THREE.Vector3(0,0,0);
    var outTan = new THREE.Vector3(0,0,0);
    var p, p1, p2, p3;
    var out;
    var delta = 1.0 / subdiv;

    var numPoints = points.length;
    p1 = points[0];
    p2 = points[1];

    if (connected) {
        p = points[numPoints-1];
        inTan.subVectors(p2, p);
        inTan.multiplyScalar(scale);
    } else {
        p = p1;
        inTan.set(0.0, 0.0, 0.0);
    }

    var outPoints = [];

    for (i = 1; i < numPoints-1; i++) {
        p3 = points[i+1];
        outTan.subVectors(p3, p1);
        outTan.multiplyScalar(scale);
        for (j = 0; j < subdiv; j++) {
            out = this.cubicHermiteInterpolate(p1, inTan, p2, outTan, j*delta);
            outPoints.push(out);
        }

        p = p1;
        p1 = p2;
        p2 = p3;
        inTan.x = outTan.x;
        inTan.y = outTan.y;
        inTan.z = outTan.z;
    }

    if (connected) {
        p3 = points[0];
        outTan.subVectors(p3, p1);
        outTan.multiplyScalar(scale);
    } else {
        outTan.set(0,0,0);
    }

    for (j = 0; j < subdiv; j++) {
        out = this.cubicHermiteInterpolate(p1, inTan, p2, outTan, j*delta);
        outPoints.push(out);
    }

    if (!connected) {
        p = points[numPoints -1];
        out = new THREE.Vector3(p.x, p.y, p.z);
        outPoints.push(out);
        return outPoints;
    }

    p = p1;
    p1 = p2;
    p2 = p3;
    inTan.x = outTan.x;
    inTan.y = outTan.y;
    inTan.z = outTan.z;
    p3 = points[1];
    outTan.subVectors(p3, p1);
    outTan.multiplyScalar(scale);
    for (j = 0; j < subdiv; j++) {
        out = this.cubicHermiteInterpolate(p1, inTan, p2, outTan, j*delta);
        outPoints.push(out);
    }

    return outPoints;
};

// Interpolate a 3D point using Hermite interpolation. 
//
// Interpolate a point using two points and their first derivatives (inTan and outTan) as a 
// polynomial function parameterized by t in [0,1].
//
Autodesk.Nano.MolViewer.RibbonView.prototype.cubicHermiteInterpolate = function cubicHermiteInterpolate(p1, inTan, p2, 
    outTan, t)
{
    var tt = t*t;
    var v1 = (3.0 - 2.0*t) * tt;
    var v2 = 1.0 - v1;
    var v3 = tt * (t - 2.0) + t;
    var v4 = tt * (t - 1.0);
    var outVec = new THREE.Vector3(v2*p1.x, v2*p1.y, v2*p1.z);
    outVec.x = outVec.x + v3*inTan.x + v1*p2.x + v4*outTan.x;
    outVec.y = outVec.y + v3*inTan.y + v1*p2.y + v4*outTan.y;
    outVec.z = outVec.z + v3*inTan.z + v1*p2.z + v4*outTan.z;
    return outVec;
};

// Get the atoms of the given residue.
//
// The atom names to get from the residue are given in the atomList object.
// If the atom name is in the residue then the atom object is set for that name.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.getResidueAtoms = function getResidueAtoms(residue, atomList) 
{
    var resAtoms = residue.atoms;
    var numSearchAtoms = atomList.numAtoms;
    var numAtomsFound = 0; 
    for (var i = 0, numAtoms = resAtoms.length; i < numAtoms; i++) {
        name = resAtoms[i].detailType;
        if (atomList.hasOwnProperty(name)) {
            atomList[name] = resAtoms[i];
            numAtomsFound += 1; 
            if (numAtomsFound === numSearchAtoms) { 
                break;
            }
        }
    }
    return atomList;
};

// Get the C3 and N atoms defining the direction of a base in a nucleic acid.
//
Autodesk.Nano.MolViewer.RibbonView.prototype.getNucleicAcidBaseDirAtoms = function getNucleicAcidBaseDirAtoms(residue) 
{
    var cAtom = null;
    var nAtom = null;
    var nAtomName;
    var atomList;

    // Set the nitrogen atom name to search for. For purines use N1.
    if (["A", "DA", "G", "DG"].indexOf(residue.name) !== -1) {
        nAtomName = "N1";
    } else {
        nAtomName = "N3";
    }
    atomList = {numAtoms:3, "C3'":null, C3:null, N1:null, N3:null};
    this.getResidueAtoms(residue, atomList);
    nAtom = atomList[nAtomName];
    if (atomList["C3"]) {
        cAtom = atomList["C3"];
    } else {
        cAtom = atomList["C3'"];
    }
    return { C:cAtom, N:nAtom };
};


;//from https://raw.githubusercontent.com/dkoes/surfacemaker/master/surface.js
/* The files is assembled from the surface generating code of 3Dmol.js
 * This code was descended from GLmol, which implemented EDTSurf.
 * Acknowledgements follow.
 *
 *
 * ProteinSurface.js by biochem_fan

 Ported and modified for Javascript based on EDTSurf,
 whose license is as follows.

 Permission to use, copy, modify, and distribute this program for any
 purpose, with or without fee, is hereby granted, provided that this
 copyright notice and the reference information appear in all copies or
 substantial portions of the Software. It is provided "as is" without
 express or implied warranty.

 Reference:
 http://zhanglab.ccmb.med.umich.edu/EDTSurf/
 D. Xu, Y. Zhang (2009) Generating Triangulated Macromolecular Surfaces
 by Euclidean Distance Transform. PLoS ONE 4(12): e8140.

 =======
 */

/*
 * These tables are based off those by Paul Bourke and Geoffrey Heller:
 * http://paulbourke.net/geometry/polygonise/
 * http://paulbourke.net/geometry/polygonise/table2.txt
 *
 * However, they have been substantially modified to reflect a more
 * sensible corner numbering scheme and the discrete nature of our voxel data
 * (resulting in fewer faces).
 */
var MarchingCube = MarchingCube || {};


//Encapsulate marching cube algorithm for isosurface generation
//(currently used by protein surface rendering and generic volumetric data reading)
MarchingCube = (function() {

    //Marching cube algorithm - assume data has been pre-treated so isovalue is 0
    // (i.e. select points greater than 0)
    //origin -  vector of origin of volumetric data (default is (0,0,0))
    // nX, nY, nZ - specifies number of voxels in each dimension
    // scale - cube diagonal unit vector scale (3Dmol vector) (specifying distance between data points); diagonal of cube
    // - default is 1 - assumes unit cube (1,1,1) diag)
    // fulltable - if true, use full marching cubes and tritables - else use trimmed table (e.g. surf render)
    // voxel - if true, draws with a blocky voxel style (default false)
    // verts, faces - vertex and face arrays to fill up

    //to match with protein surface...
    var ISDONE = 2;
    var my = {};

    my.march = function(data, verts, faces, spec) {

        var fulltable = !!(spec.fulltable);
        var origin = (spec.hasOwnProperty('origin') && spec.origin.hasOwnProperty('x')) ? spec.origin : {x:0, y:0, z:0};
        var voxel = !!(spec.voxel);

        var nX = spec.nX || 0;
        var nY = spec.nY || 0;
        var nZ = spec.nZ || 0;

        var scale = spec.scale || 1.0;

        var unitCube = new THREE.Vector3(1,1,1).multiplyScalar(scale);

        //keep track of calculated vertices to avoid repeats
        var vertnums = new Int32Array(nX*nY*nZ);

        var i, il;

        for (i = 0, il = vertnums.length; i < il; ++i)
            vertnums[i] = -1;

        // create (or retrieve) a vertex at the appropriate point for
        // the edge (p1,p2)

        var getVertex = function(i, j, k, code, p1, p2) {
            var pt = new THREE.Vector3();
            pt.copy(origin);
            var val1 = !!(code & (1 << p1));
            var val2 = !!(code & (1 << p2));

            // p1 if they are the same or if !val1
            var p = p1;
            if (!val1 && val2)
                p = p2;

            // adjust i,j,k by p
            if (p & 1)
                k++;
            if (p & 2)
                j++;
            if (p & 4)
                i++;

            pt.x += unitCube.x*i;
            pt.y += unitCube.y*j;
            pt.z += unitCube.z*k;

            var index = ((nY * i) + j) * nZ + k;

            //Have to add option to do voxels
            if (!voxel) {

                if (vertnums[index] < 0) // not created yet
                {
                    vertnums[index] = verts.length;
                    verts.push( pt );
                }
                return vertnums[index];

            }

            else {
                verts.push(pt);
                return verts.length - 1;
            }

        };

        var intersects = new Int32Array(12);

        var etable = (fulltable) ? edgeTable2 : edgeTable;
        var tritable = (fulltable) ? triTable2 : triTable;

        //Run marching cubes algorithm
        for (i = 0; i < nX-1; ++i) {

            for (var j = 0; j < nY-1; ++j){

                for (var k = 0; k < nZ-1; ++k){

                    var code = 0;

                    for (var p = 0; p < 8; ++p) {
                        var index = ((nY * (i + ((p & 4) >> 2))) + j + ((p & 2) >> 1)) *
                            nZ + k + (p & 1);

                        //TODO: Need to fix vpBits in protein surface for this to work
                        var val = !!(data[index] & ISDONE);
                        //var val = !!(data[index] > 0);

                        code |= val << p;
                    }

                    if (code === 0 || code === 255)
                        continue;

                    var ecode = etable[code];

                    if (ecode === 0)
                        continue;

                    var ttable = tritable[code];

                    if (ecode & 1)
                        intersects[0] = getVertex(i, j, k, code, 0, 1);
                    if (ecode & 2)
                        intersects[1] = getVertex(i, j, k, code, 1, 3);
                    if (ecode & 4)
                        intersects[2] = getVertex(i, j, k, code, 3, 2);
                    if (ecode & 8)
                        intersects[3] = getVertex(i, j, k, code, 2, 0);
                    if (ecode & 16)
                        intersects[4] = getVertex(i, j, k, code, 4, 5);
                    if (ecode & 32)
                        intersects[5] = getVertex(i, j, k, code, 5, 7);
                    if (ecode & 64)
                        intersects[6] = getVertex(i, j, k, code, 7, 6);
                    if (ecode & 128)
                        intersects[7] = getVertex(i, j, k, code, 6, 4);
                    if (ecode & 256)
                        intersects[8] = getVertex(i, j, k, code, 0, 4);
                    if (ecode & 512)
                        intersects[9] = getVertex(i, j, k, code, 1, 5);
                    if (ecode & 1024)
                        intersects[10] = getVertex(i, j, k, code, 3, 7);
                    if (ecode & 2048)
                        intersects[11] = getVertex(i, j, k, code, 2, 6);

                    for (var t = 0; t < ttable.length; t += 3) {

                        var a = intersects[ttable[t]],
                            b = intersects[ttable[t+1]],
                            c = intersects[ttable[t+2]];

                        if (voxel && t >= 3) {
                            verts.push(verts[a]); a = verts.length - 1;
                            verts.push(verts[b]); b = verts.length - 1;
                            verts.push(verts[c]); c = verts.length - 1;
                        }


                        faces.push(a); faces.push(b); faces.push(c);
                    }

                }

            }

        }


    };

    my.laplacianSmooth = function(numiter, verts, faces) {

        var nv = verts.length;
        var nf = faces.length / 3;
        var norms;
        var tps = new Float32Array( nv * 3 );

        var i;
        var ndeg = 20;
        var vertdeg = new Array( ndeg );

        for( i = 0; i < ndeg; ++i ){
            vertdeg[ i ] = new Uint32Array( nv );
        }

        for( i = 0; i < nv; ++i ){
            vertdeg[ 0 ][ i ] = 0;
        }

        var j, jl;
        var flagvert;

        // for each face

        for( i = 0; i < nf; ++i ){
            var ao = i * 3;
            var bo = i * 3 + 1;
            var co = i * 3 + 2;

            // vertex a

            flagvert = true;
            for( j = 0, jl = vertdeg[ 0 ][ faces[ao] ]; j < jl; ++j ){
                if( faces[ bo ] == vertdeg[ j + 1 ][ faces[ ao ]] ){
                    flagvert = false;
                    break;
                }
            }
            if( flagvert ){
                vertdeg[ 0 ][ faces[ ao ] ]++;
                vertdeg[ vertdeg[ 0 ][ faces[ ao ] ] ][ faces[ ao ] ] = faces[ bo ];
            }

            flagvert = true;
            for( j = 0, jl = vertdeg[ 0 ][ faces[ ao ] ]; j < jl; ++j ){
                if( faces[ co] == vertdeg[ j + 1 ][ faces[ ao ] ] ){
                    flagvert = false;
                    break;
                }
            }
            if( flagvert ){
                vertdeg[ 0 ][ faces[ ao ] ]++;
                vertdeg[ vertdeg[ 0 ][ faces[ ao ] ] ][ faces[ ao ] ] = faces[ co ];
            }

            // vertex b

            flagvert = true;
            for( j = 0, jl = vertdeg[ 0 ][ faces[ bo ] ]; j < jl; ++j ){
                if( faces[ ao ] == vertdeg[ j + 1 ][ faces[ bo ] ] ){
                    flagvert = false;
                    break;
                }
            }
            if( flagvert ){
                vertdeg[ 0 ][ faces[ bo ] ]++;
                vertdeg[ vertdeg[ 0 ][ faces[ bo ] ] ][ faces[ bo ] ] = faces[ ao ];
            }

            flagvert = true;
            for( j = 0, jl = vertdeg[ 0 ][ faces[ bo ] ]; j < jl; ++j ){
                if( faces[ co ] == vertdeg[ j + 1 ][ faces[ bo ] ] ){
                    flagvert = false;
                    break;
                }
            }
            if( flagvert ){
                vertdeg[ 0 ][ faces[ bo ] ]++;
                vertdeg[ vertdeg[ 0 ][ faces[ bo ] ] ][ faces[ bo ] ] = faces[ co ];
            }

            // vertex c

            flagvert = true;
            for( j = 0; j < vertdeg[ 0 ][ faces[ co ] ]; ++j ){
                if( faces[ ao ] == vertdeg[ j + 1 ][ faces[ co ] ] ){
                    flagvert = false;
                    break;
                }
            }
            if( flagvert ){
                vertdeg[ 0 ][ faces[ co ] ]++;
                vertdeg[ vertdeg[ 0 ][ faces[ co ] ] ][ faces[ co ] ] = faces[ ao ];
            }

            flagvert = true;
            for( j = 0, jl = vertdeg[ 0 ][ faces[ co ] ]; j < jl; ++j ){
                if( faces[ bo ] == vertdeg[ j + 1 ][ faces[ co ] ] ){
                    flagvert = false;
                    break;
                }
            }
            if( flagvert ){
                vertdeg[ 0 ][ faces[ co ] ]++;
                vertdeg[ vertdeg[ 0 ][ faces[ co ] ] ][ faces[ co ] ] = faces[ bo ];
            }
    
        }

        var wt = 1.0;
        var wt2 = 0.5;
        var i3, vi3, vdi, wt_vi, wt2_vi;
        var ssign = -1;
        var scaleFactor = 1;
        var outwt = 0.75 / ( scaleFactor + 3.5 );  // area-preserving

        // smoothing iterations

        for( var k = 0; k < numiter; ++k ){

            // for each vertex

            for( i = 0; i < nv; ++i ){

                i3 = i * 3;
                vdi = vertdeg[ 0 ][ i ];

                if( vdi < 3 ){

                    tps[ i3     ] = verts[ i ].x;
                    tps[ i3 + 1 ] = verts[ i ].y;
                    tps[ i3 + 2 ] = verts[ i ].z;

                }else if( vdi === 3 || vdi === 4 ){

                    tps[ i3     ] = 0;
                    tps[ i3 + 1 ] = 0;
                    tps[ i3 + 2 ] = 0;

                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {
                        tps[i3] += verts[vertdeg[j + 1][i]].x;
                        tps[i3+1] += verts[vertdeg[j + 1][i]].y;
                        tps[i3+2] += verts[vertdeg[j + 1][i]].z;
                    }

                    tps[ i3     ] += wt2 * verts[ i ].x;
                    tps[ i3 + 1 ] += wt2 * verts[ i ].y;
                    tps[ i3 + 2 ] += wt2 * verts[ i ].z;

                    wt2_vi = wt2 + vdi;
                    tps[ i3     ] /= wt2_vi;
                    tps[ i3 + 1 ] /= wt2_vi;
                    tps[ i3 + 2 ] /= wt2_vi;

                }else{

                    tps[ i3     ] = 0;
                    tps[ i3 + 1 ] = 0;
                    tps[ i3 + 2 ] = 0;
                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {
                        tps[i3] += verts[vertdeg[j + 1][i]].x;
                        tps[i3+1] += verts[vertdeg[j + 1][i]].y;
                        tps[i3+2] += verts[vertdeg[j + 1][i]].z;
                    }

                    tps[ i3     ] += wt * verts[ i ].x;
                    tps[ i3 + 1 ] += wt * verts[ i ].y;
                    tps[ i3 + 2 ] += wt * verts[ i ].z;

                    wt_vi = wt + vdi;
                    tps[ i3     ] /= wt_vi;
                    tps[ i3 + 1 ] /= wt_vi;
                    tps[ i3 + 2 ] /= wt_vi;

                }

            }

            for (i = 0, il = verts.length; i < il; i++) {
                verts[i].x = tps[3*i];
                verts[i].y = tps[3*i+1];
                verts[i].z = tps[3*i+2];
            }

        }
    };



    /*
     * These tables are based off those by Paul Bourke and Geoffrey Heller:
     * http://paulbourke.net/geometry/polygonise/
     * http://paulbourke.net/geometry/polygonise/table2.txt
     *
     * However, they have been substantially modified to reflect a more
     * sensible corner numbering scheme and the discrete nature of our voxel data
     * (resulting in fewer faces).
     */
    my.edgeTable = [ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0xb00, 0x0, 0x0, 0x0, 0x700, 0x0, 0xd00, 0xe00, 0xf00, 0x0, 0x0, 0x0,
        0x8a, 0x0, 0x15, 0x0, 0x86, 0x0, 0x0, 0x0, 0x28c, 0x0, 0x813, 0xf19,
        0xe10, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x126, 0x0, 0x0, 0x15, 0x1c,
        0x0, 0xf23, 0x419, 0xd20, 0x0, 0xa8, 0xa2, 0xaa, 0x0, 0x285, 0x9ab,
        0x8a2, 0x0, 0x2af, 0x125, 0xac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x45, 0x0, 0x384, 0x0, 0x0, 0x0, 0x700, 0x8a, 0x83,
        0x648, 0x780, 0x0, 0x51, 0x0, 0x81a, 0x54, 0x55, 0x54, 0x56, 0x0, 0x51,
        0x0, 0xe5c, 0x14a, 0x451, 0x759, 0x650, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x45,
        0x0, 0x1f6, 0x0, 0x0, 0x15, 0xdfc, 0x8a, 0x7f3, 0x4f9, 0x5f0, 0xb00,
        0x68, 0x921, 0x6a, 0x348, 0x245, 0x16f, 0x66, 0xb00, 0xe6f, 0xd65,
        0xc6c, 0x76a, 0x663, 0x569, 0x460, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0xf46, 0x0, 0x0, 0x45, 0x24c, 0x2a, 0x823, 0x29, 0xb40, 0x0, 0x0, 0x0,
        0x6ba, 0x0, 0x8f5, 0xfff, 0xef6, 0x0, 0xff, 0x2f5, 0x2fc, 0x9ea, 0x8f3,
        0xbf9, 0xaf0, 0x0, 0x0, 0x51, 0x152, 0x0, 0xf55, 0x45f, 0xd56, 0x54,
        0x357, 0x55, 0x154, 0x852, 0xb53, 0x59, 0x950, 0x700, 0x2c8, 0xc2,
        0x48a, 0xfc4, 0xec5, 0xdcf, 0xcc6, 0x2c4, 0x2cf, 0xc5, 0xcc, 0xbca,
        0xac3, 0x9c9, 0x8c0, 0x0, 0x0, 0x0, 0x0, 0xa8, 0x1a4, 0xa8, 0x7a6,
        0xa2, 0xa2, 0x2a4, 0xbac, 0xaa, 0xa3, 0x2a8, 0x3a0, 0xd00, 0xc18,
        0xd00, 0xe3a, 0x34, 0x35, 0x73f, 0x636, 0x924, 0x83f, 0xb35, 0xa3c,
        0x12a, 0x33, 0x339, 0x230, 0xe00, 0xe00, 0xc12, 0xd9a, 0x684, 0x795,
        0x49f, 0x596, 0x92, 0xb9f, 0x815, 0x99c, 0x9a, 0x393, 0x99, 0x190,
        0xf00, 0xe08, 0xd01, 0xc0a, 0x704, 0x605, 0x50f, 0x406, 0xb02, 0xa0f,
        0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0 ];

    var edgeTable = new Uint32Array(my.edgeTable);

    var triTable = my.triTable = [ [], [], [], [], [], [], [], [ 11, 9, 8 ], [], [], [],
        [ 8, 10, 9 ], [], [ 10, 8, 11 ], [ 9, 11, 10 ],
        [ 8, 10, 9, 8, 11, 10 ], [], [], [], [ 1, 7, 3 ], [], [ 4, 2, 0 ], [],
        [ 2, 1, 7 ], [], [], [], [ 2, 7, 3, 2, 9, 7 ], [],
        [ 1, 4, 11, 1, 0, 4 ], [ 3, 8, 0, 11, 9, 4, 11, 10, 9 ],
        [ 4, 11, 9, 11, 10, 9 ], [], [], [], [ 5, 3, 1 ], [], [], [],
        [ 2, 5, 8, 2, 1, 5 ], [], [], [ 2, 4, 0 ], [ 3, 2, 4 ], [],
        [ 0, 9, 1, 8, 10, 5, 8, 11, 10 ], [ 3, 4, 0, 3, 10, 4 ],
        [ 5, 8, 10, 8, 11, 10 ], [], [ 3, 5, 7 ], [ 7, 1, 5 ],
        [ 1, 7, 3, 1, 5, 7 ], [], [ 9, 2, 0, 9, 7, 2 ],
        [ 0, 3, 8, 1, 7, 11, 1, 5, 7 ], [ 11, 1, 7, 1, 5, 7 ], [],
        [ 9, 1, 0, 5, 3, 2, 5, 7, 3 ], [ 8, 2, 5, 8, 0, 2 ],
        [ 2, 5, 3, 5, 7, 3 ], [ 3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5 ],
        [ 9, 1, 0, 10, 7, 11, 10, 5, 7 ], [ 3, 8, 0, 7, 10, 5, 7, 11, 10 ],
        [ 11, 5, 7, 11, 10, 5 ], [], [], [], [], [], [ 0, 6, 2 ], [],
        [ 7, 2, 9, 7, 9, 8 ], [], [], [], [ 8, 10, 9 ], [ 7, 1, 3 ],
        [ 7, 1, 0 ], [ 6, 9, 3, 6, 10, 9 ], [ 7, 10, 8, 10, 9, 8 ], [],
        [ 6, 0, 4 ], [], [ 11, 1, 4, 11, 3, 1 ], [ 2, 4, 6 ],
        [ 2, 0, 4, 2, 4, 6 ], [ 2, 4, 6 ], [ 1, 4, 2, 4, 6, 2 ], [],
        [ 6, 0, 4 ], [], [ 2, 11, 3, 6, 9, 4, 6, 10, 9 ], [ 8, 6, 1, 8, 1, 3 ],
        [ 10, 0, 6, 0, 4, 6 ], [ 8, 0, 3, 9, 6, 10, 9, 4, 6 ],
        [ 10, 4, 6, 10, 9, 4 ], [], [], [], [ 5, 3, 1 ], [], [ 0, 6, 2 ], [],
        [ 7, 4, 8, 5, 2, 1, 5, 6, 2 ], [], [], [ 2, 4, 0 ],
        [ 7, 4, 8, 2, 11, 3, 10, 5, 6 ], [ 7, 1, 3 ],
        [ 5, 6, 10, 0, 9, 1, 8, 7, 4 ], [ 5, 6, 10, 7, 0, 3, 7, 4, 0 ],
        [ 10, 5, 6, 4, 8, 7 ], [ 9, 11, 8 ], [ 3, 5, 6 ],
        [ 0, 5, 11, 0, 11, 8 ], [ 6, 3, 5, 3, 1, 5 ], [ 3, 9, 6, 3, 8, 9 ],
        [ 9, 6, 0, 6, 2, 0 ], [ 0, 3, 8, 2, 5, 6, 2, 1, 5 ],
        [ 1, 6, 2, 1, 5, 6 ], [ 9, 11, 8 ], [ 1, 0, 9, 6, 10, 5, 11, 3, 2 ],
        [ 6, 10, 5, 2, 8, 0, 2, 11, 8 ], [ 3, 2, 11, 10, 5, 6 ],
        [ 10, 5, 6, 9, 3, 8, 9, 1, 3 ], [ 0, 9, 1, 5, 6, 10 ],
        [ 8, 0, 3, 10, 5, 6 ], [ 10, 5, 6 ], [], [], [], [], [], [], [],
        [ 1, 10, 2, 9, 11, 6, 9, 8, 11 ], [], [], [ 6, 0, 2 ],
        [ 3, 6, 9, 3, 2, 6 ], [ 3, 5, 1 ], [ 0, 5, 1, 0, 11, 5 ], [ 0, 3, 5 ],
        [ 6, 9, 11, 9, 8, 11 ], [], [], [], [ 4, 5, 9, 7, 1, 10, 7, 3, 1 ], [],
        [ 11, 6, 7, 2, 4, 5, 2, 0, 4 ],
        [ 11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5 ],
        [ 6, 7, 11, 1, 10, 2, 9, 4, 5 ], [],
        [ 4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2 ], [ 9, 4, 5, 0, 6, 7, 0, 2, 6 ],
        [ 4, 5, 9, 6, 3, 2, 6, 7, 3 ], [ 6, 7, 11, 5, 3, 8, 5, 1, 3 ],
        [ 6, 7, 11, 4, 1, 0, 4, 5, 1 ], [ 4, 5, 9, 3, 8, 0, 11, 6, 7 ],
        [ 9, 4, 5, 7, 11, 6 ], [], [], [ 0, 6, 4 ], [ 8, 6, 4, 8, 1, 6 ], [],
        [ 0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6 ],
        [ 10, 2, 1, 6, 0, 3, 6, 4, 0 ], [ 10, 2, 1, 11, 4, 8, 11, 6, 4 ],
        [ 4, 2, 6 ], [ 1, 0, 9, 2, 4, 8, 2, 6, 4 ], [ 2, 4, 0, 2, 6, 4 ],
        [ 8, 2, 4, 2, 6, 4 ], [ 11, 4, 1, 11, 6, 4 ],
        [ 0, 9, 1, 4, 11, 6, 4, 8, 11 ], [ 3, 6, 0, 6, 4, 0 ],
        [ 8, 6, 4, 8, 11, 6 ], [ 10, 8, 9 ], [ 6, 3, 9, 6, 7, 3 ], [ 6, 7, 1 ],
        [ 10, 7, 1, 7, 3, 1 ], [ 7, 11, 6, 8, 10, 2, 8, 9, 10 ],
        [ 11, 6, 7, 10, 0, 9, 10, 2, 0 ], [ 2, 1, 10, 7, 11, 6, 8, 0, 3 ],
        [ 1, 10, 2, 6, 7, 11 ], [ 7, 2, 6, 7, 9, 2 ],
        [ 1, 0, 9, 3, 6, 7, 3, 2, 6 ], [ 7, 0, 6, 0, 2, 6 ],
        [ 2, 7, 3, 2, 6, 7 ], [ 7, 11, 6, 3, 9, 1, 3, 8, 9 ],
        [ 9, 1, 0, 11, 6, 7 ], [ 0, 3, 8, 11, 6, 7 ], [ 11, 6, 7 ], [], [], [],
        [], [ 5, 3, 7 ], [ 8, 5, 2, 8, 7, 5 ], [ 5, 3, 7 ],
        [ 1, 10, 2, 5, 8, 7, 5, 9, 8 ], [ 1, 7, 5 ], [ 1, 7, 5 ],
        [ 9, 2, 7, 9, 7, 5 ], [ 11, 3, 2, 8, 5, 9, 8, 7, 5 ],
        [ 1, 3, 7, 1, 7, 5 ], [ 0, 7, 1, 7, 5, 1 ], [ 9, 3, 5, 3, 7, 5 ],
        [ 9, 7, 5, 9, 8, 7 ], [ 8, 10, 11 ], [ 3, 4, 10, 3, 10, 11 ],
        [ 8, 10, 11 ], [ 5, 9, 4, 1, 11, 3, 1, 10, 11 ], [ 2, 4, 5 ],
        [ 5, 2, 4, 2, 0, 4 ], [ 0, 3, 8, 5, 9, 4, 10, 2, 1 ],
        [ 2, 1, 10, 9, 4, 5 ], [ 2, 8, 5, 2, 11, 8 ],
        [ 3, 2, 11, 1, 4, 5, 1, 0, 4 ], [ 9, 4, 5, 8, 2, 11, 8, 0, 2 ],
        [ 11, 3, 2, 9, 4, 5 ], [ 8, 5, 3, 5, 1, 3 ], [ 5, 0, 4, 5, 1, 0 ],
        [ 3, 8, 0, 4, 5, 9 ], [ 9, 4, 5 ], [ 11, 9, 10 ], [ 11, 9, 10 ],
        [ 1, 11, 4, 1, 10, 11 ], [ 8, 7, 4, 11, 1, 10, 11, 3, 1 ],
        [ 2, 7, 9, 2, 9, 10 ], [ 4, 8, 7, 0, 10, 2, 0, 9, 10 ],
        [ 2, 1, 10, 0, 7, 4, 0, 3, 7 ], [ 10, 2, 1, 8, 7, 4 ], [ 1, 7, 4 ],
        [ 3, 2, 11, 4, 8, 7, 9, 1, 0 ], [ 11, 4, 2, 4, 0, 2 ],
        [ 2, 11, 3, 7, 4, 8 ], [ 4, 1, 7, 1, 3, 7 ], [ 1, 0, 9, 8, 7, 4 ],
        [ 3, 4, 0, 3, 7, 4 ], [ 8, 7, 4 ], [ 8, 9, 10, 8, 10, 11 ],
        [ 3, 9, 11, 9, 10, 11 ], [ 0, 10, 8, 10, 11, 8 ],
        [ 10, 3, 1, 10, 11, 3 ], [ 2, 8, 10, 8, 9, 10 ], [ 9, 2, 0, 9, 10, 2 ],
        [ 8, 0, 3, 1, 10, 2 ], [ 10, 2, 1 ], [ 1, 11, 9, 11, 8, 9 ],
        [ 11, 3, 2, 0, 9, 1 ], [ 11, 0, 2, 11, 8, 0 ], [ 11, 3, 2 ],
        [ 8, 1, 3, 8, 9, 1 ], [ 9, 1, 0 ], [ 8, 0, 3 ], [] ];

    var edgeTable2 = [ 0x0, 0x109, 0x203, 0x30a, 0x80c, 0x905, 0xa0f,
        0xb06, 0x406, 0x50f, 0x605, 0x70c, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190,
        0x99, 0x393, 0x29a, 0x99c, 0x895, 0xb9f, 0xa96, 0x596, 0x49f, 0x795,
        0x69c, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0xa3c,
        0xb35, 0x83f, 0x936, 0x636, 0x73f, 0x435, 0x53c, 0xe3a, 0xf33, 0xc39,
        0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0xbac, 0xaa5, 0x9af, 0x8a6, 0x7a6,
        0x6af, 0x5a5, 0x4ac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x8c0, 0x9c9, 0xac3,
        0xbca, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x4ca,
        0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0x15c, 0x55, 0x35f,
        0x256, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x55a, 0x453, 0x759, 0x650, 0xaf0,
        0xbf9, 0x8f3, 0x9fa, 0x2fc, 0x3f5, 0xff, 0x1f6, 0xef6, 0xfff, 0xcf5,
        0xdfc, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0x36c,
        0x265, 0x16f, 0x66, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x76a, 0x663, 0x569,
        0x460, 0x460, 0x569, 0x663, 0x76a, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x66,
        0x16f, 0x265, 0x36c, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3,
        0x6fa, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x1f6, 0xff, 0x3f5, 0x2fc, 0x9fa,
        0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0xe5c, 0xf55, 0xc5f,
        0xd56, 0x256, 0x35f, 0x55, 0x15c, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0,
        0x6c9, 0x5c3, 0x4ca, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0x3c6, 0x2cf, 0x1c5,
        0xcc, 0xbca, 0xac3, 0x9c9, 0x8c0, 0xca0, 0xda9, 0xea3, 0xfaa, 0x4ac,
        0x5a5, 0x6af, 0x7a6, 0x8a6, 0x9af, 0xaa5, 0xbac, 0xaa, 0x1a3, 0x2a9,
        0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x53c, 0x435, 0x73f, 0x636, 0x936,
        0x83f, 0xb35, 0xa3c, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93,
        0xd9a, 0x69c, 0x795, 0x49f, 0x596, 0xa96, 0xb9f, 0x895, 0x99c, 0x29a,
        0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0x70c, 0x605, 0x50f,
        0x406, 0xb06, 0xa0f, 0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0 ];

    var triTable2 = [ [], [ 8, 3, 0 ], [ 9, 0, 1 ], [ 8, 3, 1, 8, 1, 9 ],
        [ 11, 2, 3 ], [ 11, 2, 0, 11, 0, 8 ], [ 11, 2, 3, 0, 1, 9 ],
        [ 2, 1, 11, 1, 9, 11, 11, 9, 8 ], [ 10, 1, 2 ], [ 8, 3, 0, 1, 2, 10 ],
        [ 9, 0, 2, 9, 2, 10 ], [ 3, 2, 8, 2, 10, 8, 8, 10, 9 ],
        [ 10, 1, 3, 10, 3, 11 ], [ 1, 0, 10, 0, 8, 10, 10, 8, 11 ],
        [ 0, 3, 9, 3, 11, 9, 9, 11, 10 ], [ 8, 10, 9, 8, 11, 10 ], [ 8, 4, 7 ],
        [ 3, 0, 4, 3, 4, 7 ], [ 1, 9, 0, 8, 4, 7 ],
        [ 9, 4, 1, 4, 7, 1, 1, 7, 3 ], [ 2, 3, 11, 7, 8, 4 ],
        [ 7, 11, 4, 11, 2, 4, 4, 2, 0 ], [ 3, 11, 2, 4, 7, 8, 9, 0, 1 ],
        [ 2, 7, 11, 2, 1, 7, 1, 4, 7, 1, 9, 4 ], [ 10, 1, 2, 8, 4, 7 ],
        [ 2, 10, 1, 0, 4, 7, 0, 7, 3 ], [ 4, 7, 8, 0, 2, 10, 0, 10, 9 ],
        [ 2, 7, 3, 2, 9, 7, 7, 9, 4, 2, 10, 9 ],
        [ 8, 4, 7, 11, 10, 1, 11, 1, 3 ],
        [ 11, 4, 7, 1, 4, 11, 1, 11, 10, 1, 0, 4 ],
        [ 3, 8, 0, 7, 11, 4, 11, 9, 4, 11, 10, 9 ],
        [ 7, 11, 4, 4, 11, 9, 11, 10, 9 ], [ 9, 5, 4 ], [ 3, 0, 8, 4, 9, 5 ],
        [ 5, 4, 0, 5, 0, 1 ], [ 4, 8, 5, 8, 3, 5, 5, 3, 1 ],
        [ 11, 2, 3, 9, 5, 4 ], [ 9, 5, 4, 8, 11, 2, 8, 2, 0 ],
        [ 3, 11, 2, 1, 5, 4, 1, 4, 0 ],
        [ 8, 5, 4, 2, 5, 8, 2, 8, 11, 2, 1, 5 ], [ 2, 10, 1, 9, 5, 4 ],
        [ 0, 8, 3, 5, 4, 9, 10, 1, 2 ], [ 10, 5, 2, 5, 4, 2, 2, 4, 0 ],
        [ 3, 4, 8, 3, 2, 4, 2, 5, 4, 2, 10, 5 ],
        [ 5, 4, 9, 1, 3, 11, 1, 11, 10 ],
        [ 0, 9, 1, 4, 8, 5, 8, 10, 5, 8, 11, 10 ],
        [ 3, 4, 0, 3, 10, 4, 4, 10, 5, 3, 11, 10 ],
        [ 4, 8, 5, 5, 8, 10, 8, 11, 10 ], [ 9, 5, 7, 9, 7, 8 ],
        [ 0, 9, 3, 9, 5, 3, 3, 5, 7 ], [ 8, 0, 7, 0, 1, 7, 7, 1, 5 ],
        [ 1, 7, 3, 1, 5, 7 ], [ 11, 2, 3, 8, 9, 5, 8, 5, 7 ],
        [ 9, 2, 0, 9, 7, 2, 2, 7, 11, 9, 5, 7 ],
        [ 0, 3, 8, 2, 1, 11, 1, 7, 11, 1, 5, 7 ],
        [ 2, 1, 11, 11, 1, 7, 1, 5, 7 ], [ 1, 2, 10, 5, 7, 8, 5, 8, 9 ],
        [ 9, 1, 0, 10, 5, 2, 5, 3, 2, 5, 7, 3 ],
        [ 5, 2, 10, 8, 2, 5, 8, 5, 7, 8, 0, 2 ],
        [ 10, 5, 2, 2, 5, 3, 5, 7, 3 ],
        [ 3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5 ],
        [ 9, 1, 0, 10, 7, 11, 10, 5, 7 ], [ 3, 8, 0, 7, 10, 5, 7, 11, 10 ],
        [ 11, 5, 7, 11, 10, 5 ], [ 11, 7, 6 ], [ 0, 8, 3, 11, 7, 6 ],
        [ 9, 0, 1, 11, 7, 6 ], [ 7, 6, 11, 3, 1, 9, 3, 9, 8 ],
        [ 2, 3, 7, 2, 7, 6 ], [ 8, 7, 0, 7, 6, 0, 0, 6, 2 ],
        [ 1, 9, 0, 3, 7, 6, 3, 6, 2 ], [ 7, 6, 2, 7, 2, 9, 2, 1, 9, 7, 9, 8 ],
        [ 1, 2, 10, 6, 11, 7 ], [ 2, 10, 1, 7, 6, 11, 8, 3, 0 ],
        [ 11, 7, 6, 10, 9, 0, 10, 0, 2 ],
        [ 7, 6, 11, 3, 2, 8, 8, 2, 10, 8, 10, 9 ],
        [ 6, 10, 7, 10, 1, 7, 7, 1, 3 ],
        [ 6, 10, 1, 6, 1, 7, 7, 1, 0, 7, 0, 8 ],
        [ 9, 0, 3, 6, 9, 3, 6, 10, 9, 6, 3, 7 ],
        [ 6, 10, 7, 7, 10, 8, 10, 9, 8 ], [ 8, 4, 6, 8, 6, 11 ],
        [ 11, 3, 6, 3, 0, 6, 6, 0, 4 ], [ 0, 1, 9, 4, 6, 11, 4, 11, 8 ],
        [ 1, 9, 4, 11, 1, 4, 11, 3, 1, 11, 4, 6 ],
        [ 3, 8, 2, 8, 4, 2, 2, 4, 6 ], [ 2, 0, 4, 2, 4, 6 ],
        [ 1, 9, 0, 3, 8, 2, 2, 8, 4, 2, 4, 6 ], [ 9, 4, 1, 1, 4, 2, 4, 6, 2 ],
        [ 10, 1, 2, 11, 8, 4, 11, 4, 6 ],
        [ 10, 1, 2, 11, 3, 6, 6, 3, 0, 6, 0, 4 ],
        [ 0, 2, 10, 0, 10, 9, 4, 11, 8, 4, 6, 11 ],
        [ 2, 11, 3, 6, 9, 4, 6, 10, 9 ],
        [ 8, 4, 6, 8, 6, 1, 6, 10, 1, 8, 1, 3 ],
        [ 1, 0, 10, 10, 0, 6, 0, 4, 6 ], [ 8, 0, 3, 9, 6, 10, 9, 4, 6 ],
        [ 10, 4, 6, 10, 9, 4 ], [ 9, 5, 4, 7, 6, 11 ],
        [ 4, 9, 5, 3, 0, 8, 11, 7, 6 ], [ 6, 11, 7, 4, 0, 1, 4, 1, 5 ],
        [ 6, 11, 7, 4, 8, 5, 5, 8, 3, 5, 3, 1 ], [ 4, 9, 5, 6, 2, 3, 6, 3, 7 ],
        [ 9, 5, 4, 8, 7, 0, 0, 7, 6, 0, 6, 2 ],
        [ 4, 0, 1, 4, 1, 5, 6, 3, 7, 6, 2, 3 ], [ 7, 4, 8, 5, 2, 1, 5, 6, 2 ],
        [ 6, 11, 7, 1, 2, 10, 9, 5, 4 ],
        [ 11, 7, 6, 8, 3, 0, 1, 2, 10, 9, 5, 4 ],
        [ 11, 7, 6, 10, 5, 2, 2, 5, 4, 2, 4, 0 ],
        [ 7, 4, 8, 2, 11, 3, 10, 5, 6 ],
        [ 4, 9, 5, 6, 10, 7, 7, 10, 1, 7, 1, 3 ],
        [ 5, 6, 10, 0, 9, 1, 8, 7, 4 ], [ 5, 6, 10, 7, 0, 3, 7, 4, 0 ],
        [ 10, 5, 6, 4, 8, 7 ], [ 5, 6, 9, 6, 11, 9, 9, 11, 8 ],
        [ 0, 9, 5, 0, 5, 3, 3, 5, 6, 3, 6, 11 ],
        [ 0, 1, 5, 0, 5, 11, 5, 6, 11, 0, 11, 8 ],
        [ 11, 3, 6, 6, 3, 5, 3, 1, 5 ], [ 9, 5, 6, 3, 9, 6, 3, 8, 9, 3, 6, 2 ],
        [ 5, 6, 9, 9, 6, 0, 6, 2, 0 ], [ 0, 3, 8, 2, 5, 6, 2, 1, 5 ],
        [ 1, 6, 2, 1, 5, 6 ], [ 1, 2, 10, 5, 6, 9, 9, 6, 11, 9, 11, 8 ],
        [ 1, 0, 9, 6, 10, 5, 11, 3, 2 ], [ 6, 10, 5, 2, 8, 0, 2, 11, 8 ],
        [ 3, 2, 11, 10, 5, 6 ], [ 10, 5, 6, 9, 3, 8, 9, 1, 3 ],
        [ 0, 9, 1, 5, 6, 10 ], [ 8, 0, 3, 10, 5, 6 ], [ 10, 5, 6 ],
        [ 10, 6, 5 ], [ 8, 3, 0, 10, 6, 5 ], [ 0, 1, 9, 5, 10, 6 ],
        [ 10, 6, 5, 9, 8, 3, 9, 3, 1 ], [ 3, 11, 2, 10, 6, 5 ],
        [ 6, 5, 10, 2, 0, 8, 2, 8, 11 ], [ 1, 9, 0, 6, 5, 10, 11, 2, 3 ],
        [ 1, 10, 2, 5, 9, 6, 9, 11, 6, 9, 8, 11 ], [ 1, 2, 6, 1, 6, 5 ],
        [ 0, 8, 3, 2, 6, 5, 2, 5, 1 ], [ 5, 9, 6, 9, 0, 6, 6, 0, 2 ],
        [ 9, 6, 5, 3, 6, 9, 3, 9, 8, 3, 2, 6 ], [ 11, 6, 3, 6, 5, 3, 3, 5, 1 ],
        [ 0, 5, 1, 0, 11, 5, 5, 11, 6, 0, 8, 11 ],
        [ 0, 5, 9, 0, 3, 5, 3, 6, 5, 3, 11, 6 ],
        [ 5, 9, 6, 6, 9, 11, 9, 8, 11 ], [ 10, 6, 5, 4, 7, 8 ],
        [ 5, 10, 6, 7, 3, 0, 7, 0, 4 ], [ 5, 10, 6, 0, 1, 9, 8, 4, 7 ],
        [ 4, 5, 9, 6, 7, 10, 7, 1, 10, 7, 3, 1 ],
        [ 7, 8, 4, 2, 3, 11, 10, 6, 5 ],
        [ 11, 6, 7, 10, 2, 5, 2, 4, 5, 2, 0, 4 ],
        [ 11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5 ],
        [ 6, 7, 11, 1, 10, 2, 9, 4, 5 ], [ 7, 8, 4, 5, 1, 2, 5, 2, 6 ],
        [ 4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2 ],
        [ 9, 4, 5, 8, 0, 7, 0, 6, 7, 0, 2, 6 ], [ 4, 5, 9, 6, 3, 2, 6, 7, 3 ],
        [ 6, 7, 11, 4, 5, 8, 5, 3, 8, 5, 1, 3 ],
        [ 6, 7, 11, 4, 1, 0, 4, 5, 1 ], [ 4, 5, 9, 3, 8, 0, 11, 6, 7 ],
        [ 9, 4, 5, 7, 11, 6 ], [ 10, 6, 4, 10, 4, 9 ],
        [ 8, 3, 0, 9, 10, 6, 9, 6, 4 ], [ 1, 10, 0, 10, 6, 0, 0, 6, 4 ],
        [ 8, 6, 4, 8, 1, 6, 6, 1, 10, 8, 3, 1 ],
        [ 2, 3, 11, 6, 4, 9, 6, 9, 10 ],
        [ 0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6 ],
        [ 10, 2, 1, 11, 6, 3, 6, 0, 3, 6, 4, 0 ],
        [ 10, 2, 1, 11, 4, 8, 11, 6, 4 ], [ 9, 1, 4, 1, 2, 4, 4, 2, 6 ],
        [ 1, 0, 9, 3, 2, 8, 2, 4, 8, 2, 6, 4 ], [ 2, 4, 0, 2, 6, 4 ],
        [ 3, 2, 8, 8, 2, 4, 2, 6, 4 ],
        [ 1, 4, 9, 11, 4, 1, 11, 1, 3, 11, 6, 4 ],
        [ 0, 9, 1, 4, 11, 6, 4, 8, 11 ], [ 11, 6, 3, 3, 6, 0, 6, 4, 0 ],
        [ 8, 6, 4, 8, 11, 6 ], [ 6, 7, 10, 7, 8, 10, 10, 8, 9 ],
        [ 9, 3, 0, 6, 3, 9, 6, 9, 10, 6, 7, 3 ],
        [ 6, 1, 10, 6, 7, 1, 7, 0, 1, 7, 8, 0 ],
        [ 6, 7, 10, 10, 7, 1, 7, 3, 1 ],
        [ 7, 11, 6, 3, 8, 2, 8, 10, 2, 8, 9, 10 ],
        [ 11, 6, 7, 10, 0, 9, 10, 2, 0 ], [ 2, 1, 10, 7, 11, 6, 8, 0, 3 ],
        [ 1, 10, 2, 6, 7, 11 ], [ 7, 2, 6, 7, 9, 2, 2, 9, 1, 7, 8, 9 ],
        [ 1, 0, 9, 3, 6, 7, 3, 2, 6 ], [ 8, 0, 7, 7, 0, 6, 0, 2, 6 ],
        [ 2, 7, 3, 2, 6, 7 ], [ 7, 11, 6, 3, 9, 1, 3, 8, 9 ],
        [ 9, 1, 0, 11, 6, 7 ], [ 0, 3, 8, 11, 6, 7 ], [ 11, 6, 7 ],
        [ 11, 7, 5, 11, 5, 10 ], [ 3, 0, 8, 7, 5, 10, 7, 10, 11 ],
        [ 9, 0, 1, 10, 11, 7, 10, 7, 5 ],
        [ 3, 1, 9, 3, 9, 8, 7, 10, 11, 7, 5, 10 ],
        [ 10, 2, 5, 2, 3, 5, 5, 3, 7 ],
        [ 5, 10, 2, 8, 5, 2, 8, 7, 5, 8, 2, 0 ],
        [ 9, 0, 1, 10, 2, 5, 5, 2, 3, 5, 3, 7 ],
        [ 1, 10, 2, 5, 8, 7, 5, 9, 8 ], [ 2, 11, 1, 11, 7, 1, 1, 7, 5 ],
        [ 0, 8, 3, 2, 11, 1, 1, 11, 7, 1, 7, 5 ],
        [ 9, 0, 2, 9, 2, 7, 2, 11, 7, 9, 7, 5 ],
        [ 11, 3, 2, 8, 5, 9, 8, 7, 5 ], [ 1, 3, 7, 1, 7, 5 ],
        [ 8, 7, 0, 0, 7, 1, 7, 5, 1 ], [ 0, 3, 9, 9, 3, 5, 3, 7, 5 ],
        [ 9, 7, 5, 9, 8, 7 ], [ 4, 5, 8, 5, 10, 8, 8, 10, 11 ],
        [ 3, 0, 4, 3, 4, 10, 4, 5, 10, 3, 10, 11 ],
        [ 0, 1, 9, 4, 5, 8, 8, 5, 10, 8, 10, 11 ],
        [ 5, 9, 4, 1, 11, 3, 1, 10, 11 ],
        [ 3, 8, 4, 3, 4, 2, 2, 4, 5, 2, 5, 10 ],
        [ 10, 2, 5, 5, 2, 4, 2, 0, 4 ], [ 0, 3, 8, 5, 9, 4, 10, 2, 1 ],
        [ 2, 1, 10, 9, 4, 5 ], [ 8, 4, 5, 2, 8, 5, 2, 11, 8, 2, 5, 1 ],
        [ 3, 2, 11, 1, 4, 5, 1, 0, 4 ], [ 9, 4, 5, 8, 2, 11, 8, 0, 2 ],
        [ 11, 3, 2, 9, 4, 5 ], [ 4, 5, 8, 8, 5, 3, 5, 1, 3 ],
        [ 5, 0, 4, 5, 1, 0 ], [ 3, 8, 0, 4, 5, 9 ], [ 9, 4, 5 ],
        [ 7, 4, 11, 4, 9, 11, 11, 9, 10 ],
        [ 3, 0, 8, 7, 4, 11, 11, 4, 9, 11, 9, 10 ],
        [ 11, 7, 4, 1, 11, 4, 1, 10, 11, 1, 4, 0 ],
        [ 8, 7, 4, 11, 1, 10, 11, 3, 1 ],
        [ 2, 3, 7, 2, 7, 9, 7, 4, 9, 2, 9, 10 ],
        [ 4, 8, 7, 0, 10, 2, 0, 9, 10 ], [ 2, 1, 10, 0, 7, 4, 0, 3, 7 ],
        [ 10, 2, 1, 8, 7, 4 ], [ 2, 11, 7, 2, 7, 1, 1, 7, 4, 1, 4, 9 ],
        [ 3, 2, 11, 4, 8, 7, 9, 1, 0 ], [ 7, 4, 11, 11, 4, 2, 4, 0, 2 ],
        [ 2, 11, 3, 7, 4, 8 ], [ 9, 1, 4, 4, 1, 7, 1, 3, 7 ],
        [ 1, 0, 9, 8, 7, 4 ], [ 3, 4, 0, 3, 7, 4 ], [ 8, 7, 4 ],
        [ 8, 9, 10, 8, 10, 11 ], [ 0, 9, 3, 3, 9, 11, 9, 10, 11 ],
        [ 1, 10, 0, 0, 10, 8, 10, 11, 8 ], [ 10, 3, 1, 10, 11, 3 ],
        [ 3, 8, 2, 2, 8, 10, 8, 9, 10 ], [ 9, 2, 0, 9, 10, 2 ],
        [ 8, 0, 3, 1, 10, 2 ], [ 10, 2, 1 ], [ 2, 11, 1, 1, 11, 9, 11, 8, 9 ],
        [ 11, 3, 2, 0, 9, 1 ], [ 11, 0, 2, 11, 8, 0 ], [ 11, 3, 2 ],
        [ 8, 1, 3, 8, 9, 1 ], [ 9, 1, 0 ], [ 8, 0, 3 ], [] ];

    return my;
})();



//pass in the SF a SF of .5 is good for assembly entities
// a SF of 1.0 or .75 is good for smaller objects
var ProteinSurface = function(sF) {

    // constants for vpbits bitmasks
    /** @const */
    var INOUT = 1;
    /** @const */
    var ISDONE = 2;
    /** @const */
    var ISBOUND = 4;

    var ptranx = 0, ptrany = 0, ptranz = 0;
    var probeRadius = 1.4;
    var defaultScaleFactor = sF;
    var scaleFactor = defaultScaleFactor; // 2 is .5A grid; if this is made user configurable,
    // also have to adjust offset used to find non-shown
    // atoms
    var pHeight = 0, pWidth = 0, pLength = 0;
    var cutRadius = 0;
    var vpBits = null; // uint8 array of bitmasks
    var vpDistance = null; // floatarray of _squared_ distances
    var vpAtomID = null; // intarray
    var vertnumber = 0, facenumber = 0;
    var pminx = 0, pminy = 0, pminz = 0, pmaxx = 0, pmaxy = 0, pmaxz = 0;

    var vdwRadii = {
        "H" : 1.2,
        "LI" : 1.82,
        "NA" : 2.27,
        "K" : 2.75,
        "C" : 1.7,
        "N" : 1.55,
        "O" : 1.52,
        "F" : 1.47,
        "P" : 1.80,
        "S" : 1.80,
        "CL" : 1.75,
        "BR" : 1.85,
        "SE" : 1.90,
        "ZN" : 1.39,
        "CU" : 1.4,
        "NI" : 1.63,
        "X" : 2
    };

    /** @param {AtomSpec} atom */
    var getVDWIndex = function(atom) {
        if(!atom.elementUpper || typeof(vdwRadii[atom.elementUpper]) == "undefined") {
            return "X";
        }
        return atom.elementUpper;
    };

    var depty = {}, widxz = {};
    var faces, verts;
    var nb = [ new Int32Array([ 1, 0, 0 ]), new Int32Array([ -1, 0, 0 ]),
        new Int32Array([ 0, 1, 0 ]), new Int32Array([ 0, -1, 0 ]),
        new Int32Array([ 0, 0, 1 ]),
        new Int32Array([ 0, 0, -1 ]),
        new Int32Array([ 1, 1, 0 ]),
        new Int32Array([ 1, -1, 0 ]),
        new Int32Array([ -1, 1, 0 ]),
        new Int32Array([ -1, -1, 0 ]),
        new Int32Array([ 1, 0, 1 ]),
        new Int32Array([ 1, 0, -1 ]),
        new Int32Array([ -1, 0, 1 ]),
        new Int32Array([ -1, 0, -1 ]),
        new Int32Array([ 0, 1, 1 ]),
        new Int32Array([ 0, 1, -1 ]),
        new Int32Array([ 0, -1, 1 ]),
        new Int32Array([ 0, -1, -1 ]),
        new Int32Array([ 1, 1, 1 ]),
        new Int32Array([ 1, 1, -1 ]),
        new Int32Array([ 1, -1, 1 ]),
        new Int32Array([ -1, 1, 1 ]),
        new Int32Array([ 1, -1, -1 ]),
        new Int32Array([ -1, -1, 1 ]),
        new Int32Array([ -1, 1, -1 ]),
        new Int32Array([ -1, -1, -1 ]) ];

    var origextent;

    var inOrigExtent = function(x, y, z) {
        if (x < origextent.min.x || x > origextent.max.x)
            return false;
        if (y < origextent.min.y || y > origextent.max.y)
            return false;
        if (z < origextent.min.z || z > origextent.max.z)
            return false;
        return true;
    };

    this.getFacesAndVertices = function(atomsOn) {
        var atomsToShow = {};
        var i, il;
        for (i = 0, il = atomsOn.length; i < il; i++)
            atomsToShow[atomsOn[i]] = true;
        var vertices = verts;
        for (i = 0, il = vertices.length; i < il; i++) {
            vertices[i].x = vertices[i].x / scaleFactor - ptranx;
            vertices[i].y = vertices[i].y / scaleFactor - ptrany;
            vertices[i].z = vertices[i].z / scaleFactor - ptranz;
        }

        var finalfaces = [];
        for (i = 0, il = faces.length; i < il; i += 3) {
            //var f = faces[i];
            var fa = faces[i], fb = faces[i+1], fc = faces[i+2];
            var a = vertices[fa]['atomid'], b = vertices[fb]['atomid'], c = vertices[fc]['atomid'];

            // must be a unique face for each atom
            var which = a;
            if (b < which)
                which = b;
            if (c < which)
                which = c;
            if (!atomsToShow[which]) {
                continue;
            }
            var av = vertices[faces[i]];
            var bv = vertices[faces[i+1]];
            var cv = vertices[faces[i+2]];

            if (fa !== fb && fb !== fc && fa !== fc){
                finalfaces.push(fa);
                finalfaces.push(fb);
                finalfaces.push(fc);
            }

        }

        //try to help the garbage collector
        vpBits = null; // uint8 array of bitmasks
        vpDistance = null; // floatarray
        vpAtomID = null; // intarray

        return {
            'vertices' : vertices,
            'faces' : finalfaces
        };
    };


    this.initparm = function(extent, btype, volume) {
        var margin = (1 / scaleFactor) * 3.0; // need margin to avoid

        // boundary/round off effects
        origextent = extent;
        pminx = extent.min.x; pmaxx = extent.max.x;
        pminy = extent.min.y; pmaxy = extent.max.y;
        pminz = extent.min.z; pmaxz = extent.max.z;

        if (!btype) {
            pminx -= margin;
            pminy -= margin;
            pminz -= margin;
            pmaxx += margin;
            pmaxy += margin;
            pmaxz += margin;
        } else {
            pminx -= probeRadius + margin;
            pminy -= probeRadius + margin;
            pminz -= probeRadius + margin;
            pmaxx += probeRadius + margin;
            pmaxy += probeRadius + margin;
            pmaxz += probeRadius + margin;
        }

        pminx = Math.floor(pminx * scaleFactor) / scaleFactor;
        pminy = Math.floor(pminy * scaleFactor) / scaleFactor;
        pminz = Math.floor(pminz * scaleFactor) / scaleFactor;
        pmaxx = Math.ceil(pmaxx * scaleFactor) / scaleFactor;
        pmaxy = Math.ceil(pmaxy * scaleFactor) / scaleFactor;
        pmaxz = Math.ceil(pmaxz * scaleFactor) / scaleFactor;

        ptranx = -pminx;
        ptrany = -pminy;
        ptranz = -pminz;

        pLength = Math.ceil(scaleFactor * (pmaxx - pminx)) + 1;
        pWidth = Math.ceil(scaleFactor * (pmaxy - pminy)) + 1;
        pHeight = Math.ceil(scaleFactor * (pmaxz - pminz)) + 1;

        this.boundingatom(btype);
        cutRadius = probeRadius * scaleFactor;

        vpBits = new Uint8Array(pLength * pWidth * pHeight);
        vpDistance = new Float32Array(pLength * pWidth * pHeight); 
        vpAtomID = new Int32Array(pLength * pWidth * pHeight);
        console.log("Box size: ", pLength, pWidth, pHeight, vpBits.length);
    };

    this.boundingatom = function(btype) {
        var tradius = [];
        var txz, tdept, sradius, idx;
        var flagradius = btype;

        for ( var i in vdwRadii) {
            if(!vdwRadii.hasOwnProperty(i))
                continue;
            var r = vdwRadii[i];
            if (!btype)
                tradius[i] = r * scaleFactor + 0.5;
            else
                tradius[i] = (r + probeRadius) * scaleFactor + 0.5;

            sradius = tradius[i] * tradius[i];
            widxz[i] = Math.floor(tradius[i]) + 1;
            depty[i] = new Int32Array(widxz[i] * widxz[i]);
            var indx = 0;
            var j,k;
            for (j = 0; j < widxz[i]; j++) {
                for (k = 0; k < widxz[i]; k++) {
                    txz = j * j + k * k;
                    if (txz > sradius)
                        depty[i][indx] = -1; // outside
                    else {
                        tdept = Math.sqrt(sradius - txz);
                        depty[i][indx] = Math.floor(tdept);
                    }
                    indx++;
                }
            }
        }
    };

    this.fillvoxels = function(atoms, atomsOn) { // (int seqinit,int
        // seqterm,bool
        // atomtype,atom*
        // proseq,bool bcolor)
        var i, il;
   
        for (i = 0, il = vpBits.length; i < il; i++) {
            vpBits[i] = 0;
            vpDistance[i] = -1.0;
            vpAtomID[i] = -1;
        }

        for (i in atomsOn) {
            var atom = atoms[atomsOn[i]];
            if (atom === undefined) {
                continue;
            }
            this.fillAtom(atom, atoms);
        }

        for (i = 0, il = vpBits.length; i < il; i++) {
            if (vpBits[i] & INOUT) {
                vpBits[i] |= ISDONE;
            }    
        }

    };


    this.fillAtom = function(atom, atoms) {
        var cx, cy, cz, ox, oy, oz, mi, mj, mk, i, j, k, si, sj, sk;
        var ii, jj, kk, n, m;
        cx = Math.floor(0.5 + scaleFactor * (atom.x + ptranx));
        cy = Math.floor(0.5 + scaleFactor * (atom.y + ptrany));
        cz = Math.floor(0.5 + scaleFactor * (atom.z + ptranz));

        var at = getVDWIndex(atom);
        var nind = 0;
        var cnt = 0;
        var pWH = pWidth*pHeight;

        for (i = 0, n = widxz[at]; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (depty[at][nind] != -1) {
                    for (ii = -1; ii < 2; ii+=2) {
                        for (jj = -1; jj < 2; jj+=2) {
                            for (kk = -1; kk < 2; kk+=2) {
                                mi = ii * i;
                                mk = kk * j;
                                si = cx + mi;
                                sk = cz + mk;
                                if (si < 0 || sk < 0 || si >= pLength || sk >= pHeight) {
                                    continue;
                                }
                                for (k = 0, m = depty[at][nind]; k<= m; k++) {
                                    mj = k * jj;
                                    sj = cy + mj;
                                    if (sj < 0 || sj >= pWidth) {
                                        continue;
                                    }
                                    var index = si*pWH + sj*pHeight + sk;

                                    if (!(vpBits[index] & INOUT)) {
                                        vpBits[index] |= INOUT;
                                        vpAtomID[index] = atom.id;
                                    } else if (atom.id != vpAtomID[index]) {
                                        var atom2 = atoms[vpAtomID[index]];
                                        ox = Math.floor(0.5 + scaleFactor * (atom2.x + ptranx));
                                        oy = Math.floor(0.5 + scaleFactor * (atom2.y + ptrany));
                                        oz = Math.floor(0.5 + scaleFactor * (atom2.z + ptranz));
                                        if (mi*mi + mj*mj + mk*mk < (ox*ox + oy*oy + oz*oz)) {
                                            vpAtomID[index] = atom.id;
                                        }
                                    }
                                }// k
                            }// kk
                        }// jj
                    }// ii
                }// if
                nind++;
            }// j
        }// i
    };

    this.fillvoxelswaals = function(atoms, atomsOn) {
        var i, il;
        for (i = 0, il = vpBits.length; i < il; i++)
            vpBits[i] &= ~ISDONE; // not isdone

        for (i in atomsOn) {
            var atom = atoms[atomsOn[i]];
            if (atom === undefined) {
                continue;
            }
            this.fillAtomWaals(atom, atoms);
        }
    };

    this.fillAtomWaals = function(atom, atoms) {
        var cx, cy, cz, ox, oy, oz, nind = 0;
        var mi, mj, mk, si, sj, sk, i, j, k, ii, jj, kk, n;
        cx = Math.floor(0.5 + scaleFactor * (atom.x + ptranx));
        cy = Math.floor(0.5 + scaleFactor * (atom.y + ptrany));
        cz = Math.floor(0.5 + scaleFactor * (atom.z + ptranz));

        var at = getVDWIndex(atom);
        var pWH = pWidth*pHeight;
        for (i = 0, n = widxz[at]; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (depty[at][nind] != -1) {
                    for (ii = -1; ii < 2; ii++) {
                        for (jj = -1; jj < 2; jj++) {
                            for (kk = -1; kk < 2; kk++) {
                                if (ii !== 0 && jj !== 0 && kk !== 0) {
                                    mi = ii * i;
                                    mk = kk * j;
                                    for (k = 0; k <= depty[at][nind]; k++) {
                                        mj = k * jj;
                                        si = cx + mi;
                                        sj = cy + mj;
                                        sk = cz + mk;
                                        if (si < 0 || sj < 0 ||
                                            sk < 0 ||
                                            si >= pLength ||
                                            sj >= pWidth ||
                                            sk >= pHeight)
                                            continue;
                                        var index = si * pWH + sj * pHeight + sk;
                                        if (!(vpBits[index] & ISDONE)) {
                                            vpBits[index] |= ISDONE;
                                            vpAtomID[index] = atom.id;
                                        } else {
                                            var atom2 = atoms[vpAtomID[index]];
                                            ox = Math.floor(0.5 + scaleFactor * (atom2.x + ptranx));
                                            oy = Math.floor(0.5 + scaleFactor * (atom2.y + ptrany));
                                            oz = Math.floor(0.5 + scaleFactor * (atom2.z + ptranz));
                                            if (mi * mi + mj * mj + mk * mk < ox *
                                                ox + oy * oy + oz * oz)
                                                vpAtomID[index] = atom.id;
                                        }

                                    }// k
                                }// if
                            }// kk
                        }// jj
                    }// ii
                }// if
                nind++;
            }// j
        }// i
    };

    this.buildboundary = function() {
        var i, j, k;
        var pWH = pWidth*pHeight;
        for (i = 0; i < pLength; i++) {
            for (j = 0; j < pHeight; j++) {
                for (k = 0; k < pWidth; k++) {
                    var index = i * pWH + k * pHeight + j;
                    if (vpBits[index] & INOUT) {
                        var flagbound = false;
                        var ii = 0;
                        while (ii < 26) {
                            var ti = i + nb[ii][0], tj = j + nb[ii][2], tk = k +
                                nb[ii][1];
                            if (ti > -1 &&
                                ti < pLength &&
                                tk > -1 &&
                                tk < pWidth &&
                                tj > -1 &&
                                tj < pHeight &&
                                !(vpBits[ti * pWH + tk * pHeight + tj] & INOUT)) {
                                vpBits[index] |= ISBOUND;
                                break;
                            } else
                                ii++;
                        }
                    }
                }
            }
        }
    };

    // a little class for 3d array, should really generalize this and
    // use throughout...
    var PointGrid = function(length, width, height) {
        // the standard says this is zero initialized
        var data = new Int32Array(length * width * height * 3);

        // set position x,y,z to pt, which has ix,iy,and iz
        this.set = function(x, y, z, pt) {
            var index = ((((x * width) + y) * height) + z) * 3;
            data[index] = pt.ix;
            data[index + 1] = pt.iy;
            data[index + 2] = pt.iz;
        };

        // return point at x,y,z
        this.get = function(x, y, z) {
            var index = ((((x * width) + y) * height) + z) * 3;
            return {
                ix : data[index],
                iy : data[index + 1],
                iz : data[index + 2]
            };
        };
    };

    this.fastdistancemap = function() {
        var eliminate = 0;
        var certificate;
        var i, j, k, n;

        var boundPoint = new PointGrid(pLength, pWidth, pHeight);
        var pWH = pWidth*pHeight;
        var cutRSq = cutRadius*cutRadius;

        var inarray = [];
        var outarray = [];
        var index;

        for (i = 0; i < pLength; i++) {
            for (j = 0; j < pWidth; j++) {
                for (k = 0; k < pHeight; k++) {
                    index = i * pWH + j * pHeight + k;
                    vpBits[index] &= ~ISDONE; // isdone = false
                    if (vpBits[index] & INOUT) {
                        if (vpBits[index] & ISBOUND) {
                            var triple = {
                                ix : i,
                                iy : j,
                                iz : k
                            };
                            boundPoint.set(i, j, k, triple);
                            inarray.push(triple);
                            vpDistance[index] = 0;
                            vpBits[index] |= ISDONE;
                            vpBits[index] &= ~ISBOUND;
                        }
                    }
                }
            }
        }

        do {
            outarray = this.fastoneshell(inarray, boundPoint);
            inarray = [];
            for (i = 0, n = outarray.length; i < n; i++) {
                index = pWH * outarray[i].ix + pHeight *
                outarray[i].iy + outarray[i].iz;
                vpBits[index] &= ~ISBOUND;
                if (vpDistance[index] <= 1.0404 * cutRSq) {
                    inarray.push({
                        ix : outarray[i].ix,
                        iy : outarray[i].iy,
                        iz : outarray[i].iz
                    });
                }
            }
        } while (inarray.length !== 0);

        inarray = [];
        outarray = [];
        boundPoint = null;

        var cutsf = scaleFactor - 0.5;
        if (cutsf < 0)
            cutsf = 0;
        var cutoff = cutRSq - 0.50 / (0.1 + cutsf);
        for (i = 0; i < pLength; i++) {
            for (j = 0; j < pWidth; j++) {
                for (k = 0; k < pHeight; k++) {
                    index = i * pWH + j * pHeight + k;
                    vpBits[index] &= ~ISBOUND;
                    // ses solid
                    if (vpBits[index] & INOUT) {
                        if (!(vpBits[index] & ISDONE) ||
                            ((vpBits[index] & ISDONE) && vpDistance[index] >= cutoff)) {
                            vpBits[index] |= ISBOUND;
                        }
                    }
                }
            }
        }

    };

    this.fastoneshell = function(inarray, boundPoint) { // (int* innum,int
        // *allocout,voxel2
        // ***boundPoint, int*
        // outnum, int *elimi)
        var tx, ty, tz;
        var dx, dy, dz;
        var i, j, n;
        var square;
        var bp, index;
        var outarray = [];
        if (inarray.length === 0)
            return outarray;

        var tnv = {
            ix : -1,
            iy : -1,
            iz : -1
        };
        var pWH = pWidth*pHeight;
        for ( i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for (j = 0; j < 6; j++) {
                tnv.ix = tx + nb[j][0];
                tnv.iy = ty + nb[j][1];
                tnv.iz = tz + nb[j][2];

                if (tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
                    tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;

                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {

                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        vpDistance[index] = square;
                        vpBits[index] |= ISDONE;
                        vpBits[index] |= ISBOUND;

                        outarray.push({
                            ix : tnv.ix,
                            iy : tnv.iy,
                            iz : tnv.iz
                        });
                    } else if ((vpBits[index] & INOUT) && (vpBits[index] & ISDONE)) {

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if (square < vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);

                            vpDistance[index] = square;
                            if (!(vpBits[index] & ISBOUND)) {
                                vpBits[index] |= ISBOUND;
                                outarray.push({
                                    ix : tnv.ix,
                                    iy : tnv.iy,
                                    iz : tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        // console.log("part1", positout);

        for (i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for (j = 6; j < 18; j++) {
                tnv.ix = tx + nb[j][0];
                tnv.iy = ty + nb[j][1];
                tnv.iz = tz + nb[j][2];

                if(tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
                    tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;

                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {
                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        vpDistance[index] = square;
                        vpBits[index] |= ISDONE;
                        vpBits[index] |= ISBOUND;

                        outarray.push({
                            ix : tnv.ix,
                            iy : tnv.iy,
                            iz : tnv.iz
                        });
                    } else if ((vpBits[index] & INOUT) && (vpBits[index] & ISDONE)) {
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if (square < vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);
                            vpDistance[index] = square;
                            if (!(vpBits[index] & ISBOUND)) {
                                vpBits[index] |= ISBOUND;
                                outarray.push({
                                    ix : tnv.ix,
                                    iy : tnv.iy,
                                    iz : tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        // console.log("part2", positout);

        for (i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for (j = 18; j < 26; j++) {
                tnv.ix = tx + nb[j][0];
                tnv.iy = ty + nb[j][1];
                tnv.iz = tz + nb[j][2];

                if (tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
                    tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;

                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {
                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        vpDistance[index] = square;
                        vpBits[index] |= ISDONE;
                        vpBits[index] |= ISBOUND;

                        outarray.push({
                            ix : tnv.ix,
                            iy : tnv.iy,
                            iz : tnv.iz
                        });
                    } else if ((vpBits[index] & INOUT)  && (vpBits[index] & ISDONE)) {
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if (square < vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);

                            vpDistance[index] = square;
                            if (!(vpBits[index] & ISBOUND)) {
                                vpBits[index] |= ISBOUND;
                                outarray.push({
                                    ix : tnv.ix,
                                    iy : tnv.iy,
                                    iz : tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        // console.log("part3", positout);
        return outarray;
    };
    this.marchingcubeinit = function(stype) {

        if ((stype == 1) || (stype == 3)) { // vdw or sas
            for ( var i = 0, lim = vpBits.length; i < lim; i++) {
                vpBits[i] &= ~ISBOUND;
            }

        } else if (stype == 4) { // ses
            for ( var i = 0, lim = vpBits.length; i < lim; i++) {
                vpBits[i] &= ~ISDONE;
                if (vpBits[i] & ISBOUND)
                    vpBits[i] |= ISDONE;
                vpBits[i] &= ~ISBOUND;
            }

        } else if (stype == 2) {//MS
            for ( var i = 0, lim = vpBits.length; i < lim; i++) {
                if ((vpBits[i] & ISBOUND) && (vpBits[i] & ISDONE))
                    vpBits[i] &= ~ISBOUND;
                else if ((vpBits[i] & ISBOUND) && !(vpBits[i] & ISDONE))
                    vpBits[i] |= ISDONE;
            }
        }
    };

    // this code allows me to empirically prune the marching cubes code tables
    // to more efficiently handle discrete data
    var counter = function() {
        var data = Array(256);
        for ( var i = 0; i < 256; i++)
            data[i] = [];

        this.incrementUsed = function(i, j) {
            if (typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used : 0,
                    unused : 0
                };
            data[i][j].used++;
        };

        this.incrementUnused = function(i, j) {
            if (typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used : 0,
                    unused : 0
                };
            data[i][j].unused++;

        };

        var redoTable = function(triTable) {
            var str = "[";
            for ( var i = 0; i < triTable.length; i++) {
                var code = 0;
                var table = triTable[i];
                for ( var j = 0; j < table.length; j++) {
                    code |= (1 << (table[j]));
                }
                str += "0x" + code.toString(16) + ", ";
            }
            str += "]";
            console.log(str);
        };

        this.print = function() {

            var table = MarchingCube.triTable;
            var str;
            var newtable = [];
            for ( var i = 0; i < table.length; i++) {
                var newarr = [];
                for ( var j = 0; j < table[i].length; j += 3) {
                    var k = j / 3;
                    if (typeof data[i][k] === 'undefined' || !data[i][k].unused) {
                        newarr.push(table[i][j]);
                        newarr.push(table[i][j + 1]);
                        newarr.push(table[i][j + 2]);
                    }
                    if (typeof data[i][k] === 'undefined')
                        console.log("undef " + i + "," + k);
                }
                newtable.push(newarr);
            }
            console.log(JSON.stringify(newtable));
            redoTable(newtable);
        };
    };

    this.marchingcube = function(stype) {
        this.marchingcubeinit(stype);
        verts = []; faces = [];
        MarchingCube.march(vpBits, verts, faces, {
            smooth : 1,
            nX : pLength,
            nY : pWidth,
            nZ : pHeight
        });

        var pWH = pWidth*pHeight;
        for (var i = 0, vlen = verts.length; i < vlen; i++) {
            verts[i]['atomid'] = vpAtomID[verts[i].x * pWH + pHeight *
            verts[i].y + verts[i].z];
        }

        MarchingCube.laplacianSmooth(1, verts, faces);

    };

};


/**
 Created by Michael Zyracki Oct 21, 2016
 */

Autodesk.Nano.MolViewer.SurfaceView = function(scene,instance,viewer,options) {

    Autodesk.Nano.MolViewer.MeshView.call(this,scene,instance,viewer);
};

// Define surface types.
//
//     VDW - The van der Waals surface is the topological boundary of overlapping spheres defined using atom
//           van der Waals radius.
//
//     MS - The molecular surface is a continuous sheet consisting of two parts: the contact surface and the 
//          reentrant surface. The contact surface is part of the van der Waals surface that is accessible to 
//          a probe sphere. The reentrant surface is the inward-facing surface of the probe when it touches two 
//          or more atoms.
//
//     SAS - The solvent-accessible surface defined as the area traced out by the center of a probe sphere as it
//           is rolled over the van der Waals surface.
//
//     SES - The solvent-excluded surface is the boundary of the union of all possible probes which do not overlap
//           with the molecule. This is also called the Molecular surface and Connolly surface.
//
Autodesk.Nano.MolViewer.SurfaceView.VDW = 1;
Autodesk.Nano.MolViewer.SurfaceView.MS  = 2;
Autodesk.Nano.MolViewer.SurfaceView.SAS = 3;
Autodesk.Nano.MolViewer.SurfaceView.SES = 4;

Autodesk.Nano.MolViewer.SurfaceView.prototype = Object.create(Autodesk.Nano.MolViewer.MeshView.prototype);
Autodesk.Nano.MolViewer.SurfaceView.prototype.constructor = Autodesk.Nano.MolViewer.MeshView;


//generate a mesh from atoms
/**
 *
 * @param atoms
 * @param atomsOn [] of indices
 * @param extent THREE.BBOX of extents
 * @param wtype 1= vdw, 2 aftervdw, 3, sas, 4 ses.
 * @returns {a.Raycaster.params.Mesh}
 */
Autodesk.Nano.MolViewer.SurfaceView.prototype.generateMesh = function generateMesh(scaleFactor,atoms,atomsOn,extent,wtype) //need to make sure bbox is local bbox of selected atoms MZ
{
    var btype = (wtype != Autodesk.Nano.MolViewer.SurfaceView.VDW); 
    var w = extent.max.x - extent.min.x;
    var h = extent.max.y - extent.min.y;
    var d = extent.max.z - extent.min.z;
    var vol =  w * h * d;

    var ps = new ProteinSurface(scaleFactor);

    ps.initparm(extent, btype, vol);
    ps.fillvoxels(atoms, atomsOn);
    ps.buildboundary();

    if ( (wtype === Autodesk.Nano.MolViewer.SurfaceView.MS ) || 
         (wtype === Autodesk.Nano.MolViewer.SurfaceView.SES)) {
        ps.fastdistancemap();
    }

    if (wtype === Autodesk.Nano.MolViewer.SurfaceView.SES) {
        ps.boundingatom(false);
        ps.fillvoxelswaals(atoms, atomsOn);
    }

    ps.marchingcube(wtype);

    var VandF = ps.getFacesAndVertices(atomsOn);
    return VandF; //vertices (xyz and atomid, faces(indices)
}


/*
    due to legacy code vertices are face objects, but for normals we are just using a byte array off the bat
 this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );
 var normals = attributes.normal.array;
 attributes.normal.needsUpdate = true;
 */
Autodesk.Nano.MolViewer.SurfaceView.prototype.calcNormals = function calcNormals(vertices,faces) {

    var normals = new Array(vertices.length *3);
    var vA,vB,vC;
    var pA,pB,pC;
    var i,il;
    var x, y, z, n;
    var cb = new THREE.Vector3();
    var ab = new THREE.Vector3();
    for(var j =0;j < normals.length;++j){
        normals[j] = 0.0;
    }
    for ( i = 0; i < faces.length; i +=3 ) {
        vA = faces[i];
        vB = faces[i+1];
        vC = faces[i+2];

        pA = vertices[vA];
        pB = vertices[vB];
        pC = vertices[vC];
        cb.subVectors( pC, pB );
        ab.subVectors( pA, pB );
        cb.cross( ab );
        vA *= 3;
        vB *= 3;
        vC *= 3;
        normals[ vA     ] += cb.x;
        normals[ vA + 1 ] += cb.y;
        normals[ vA + 2 ] += cb.z;

        normals[ vB     ] += cb.x;
        normals[ vB + 1 ] += cb.y;
        normals[ vB + 2 ] += cb.z;

        normals[ vC     ] += cb.x;
        normals[ vC + 1 ] += cb.y;
        normals[ vC + 2 ] += cb.z;
    }

    for (i = 0, il = normals.length; i < il; i += 3 ) {
        x = normals[ i ];
        y = normals[ i + 1 ];
        z = normals[ i + 2 ];

        n = 1.0 / Math.sqrt( x * x + y * y + z * z );

        normals[ i     ] *= n;
        normals[ i + 1 ] *= n;
        normals[ i + 2 ] *= n;
    }

    return normals;
};

/*
MZ this would be better if done on the byte array perhaps, at least faster

 */
Autodesk.Nano.MolViewer.SurfaceView.prototype.dupVertsAndSetAtomIndex = function dupVertsAndSetAtomIndex(vertices,faces,normals) {
    var i1,i2,i3;
    var v1,v2,v3;
    var nx,ny,nz;
    var vertnumber = vertices.length;
    var newVert;
    var count =0;
    var faceToAtom = new Int32Array(faces.length/3);
    for(var i =0 ;i< faces.length;i+=3){
        v1 = vertices[faces[i]];
        v2 = vertices[faces[i+1]];
        v3 = vertices[faces[i+2]];
        i1 = v1.atomid;
        i2 = v2.atomid;
        i3 = v3.atomid;
        if(i1 !== i2) { // a and not b
            newVert = new THREE.Vector3(v2.x, v2.y, v2.z);
            newVert.atomid = i1;
            nx = normals[faces[i+1] *3];
            ny = normals[faces[i+1] *3 +1];
            nz = normals[faces[i+1] *3 +2];
            normals.push(nx); normals.push(ny); normals.push(nz);
            faces[i + 1] = vertnumber;
            vertices.push(newVert);
            ++vertnumber;
            if (i1 !== i3) {  //a and not b nor c
                newVert = new THREE.Vector3(v3.x, v3.y, v3.z);
                newVert.atomid = i1;
                nx = normals[faces[i+2] *3];
                ny = normals[faces[i+2] *3 +1];
                nz = normals[faces[i+2] *3 +2];
                normals.push(nx); normals.push(ny); normals.push(nz);
                faces[i + 2] = vertnumber;
                vertices.push(newVert);
                ++vertnumber;
            }
        }else if(i1 !== i3){ //a and b and not c
            newVert = new THREE.Vector3(v3.x,v3.y,v3.z);
            newVert.atomid = i1;
            nx = normals[faces[i+2] *3];
            ny = normals[faces[i+2] *3 +1];
            nz = normals[faces[i+2] *3 +2];
            normals.push(nx); normals.push(ny); normals.push(nz);
            faces[i + 2] = vertnumber;
            vertices.push(newVert);
            ++vertnumber;
        }
        faceToAtom[count++] = i1;
    }
    return faceToAtom;
}

Autodesk.Nano.MolViewer.SurfaceView.prototype.create = function create(id,options){
    var atoms = options.atoms;
    var allAtoms = options.allAtoms;
    var atomsOn = options.atomsOn;
    var bbox = options.bbox;
    var molRepRep = options.molRepRep;
    var getUVColor = molRepRep.getUVColor;
    var bitSet = options.atomRepState.bitSets['surface'];
    var scaleFactor = options.scaleFactor ? options.scaleFactor : 0.75;
    var mesh;
    var indices;
    if(atomsOn && atomsOn.length > 0) {
        if (this._meshes[id]) { //we assme the id is unique and so if it's set the mesh is valid
            var mesh = this._meshes[id];
            if (!mesh.parent) {
                this.scene.add(mesh);
            }
            this.setNewGeometry(mesh,id,allAtoms,atomsOn,bitSet,'surface');

        } else { //no mesh so we need to create it.
            var time = new Date();
            var surfaceType = Autodesk.Nano.MolViewer.SurfaceView.MS;
            var data = this.generateMesh(scaleFactor, atoms, allAtoms, bbox, surfaceType);
            var normals = this.calcNormals(data.vertices, data.faces);
            var faceToAtom = this.dupVertsAndSetAtomIndex(data.vertices, data.faces, normals);
            var verts = data.vertices;
            var vertices = new Float32Array(verts.length * 3);
            var uvs = new Float32Array(verts.length * 2);
            var newNormals = new Float32Array(normals);
            //var indices = new ( ( data.indices.length ) > 65535 ? Uint32Array : Uint16Array )( data.i );
            var indices = new Uint32Array(data.faces);
            var geometry = new THREE.BufferGeometry();
            //MZ
            geometry.origIndex = new Uint32Array(indices); //NEED TO MAKE COPY, MZ may not be needed anymore!
            geometry.faceToAtom = faceToAtom;
            var ii = 0, i2 = 0;
            var uv = {u: 0, v: 0};
            var atomID;
            for (var i = 0; i < verts.length; ++i) {
                vertices[ii++] = verts[i].x;
                vertices[ii++] = verts[i].y;
                vertices[ii++] = verts[i].z;
                atomID = verts[i].atomid;
                getUVColor.getUV2(atomID, uv);
                uvs[i2++] = uv.u;
                uvs[i2++] = uv.v;

            }
            geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.addAttribute('normal', new THREE.BufferAttribute(newNormals, 3));
            geometry.addAttribute('index', new THREE.BufferAttribute(indices, 1));
            geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
            geometry.computeBoundingSphere();
            var dataID = md5(atomsOn);
            this.instance.molMan.view3DMan.gC.addGeometryCache(id,'surface',geometry,dataID);

            var material = molRepRep.colorMaterialAtom;
            material.packedNormals = false;
            mesh = new THREE.Mesh(geometry, material);
            mesh.matrixAutoUpdate = false;

            this._meshes[id] = mesh;
            mesh.nanoID = id; //needed for selection
            mesh.atomsOn  = atomsOn; //used for alpha or not
            var time2 = new Date();
            var t = time2 - time;
            console.log("Surface mesh generation: " + t + " ms");
            console.log(" ");
            this.scene.add(mesh);

            if(allAtoms.length != atomsOn.length){
                this.setNewGeometry(mesh,id,allAtoms,atomsOn,bitSet,'surface');
            }

        }
    }else if (this._meshes[id]) { //nothing on...
        mesh = this._meshes[id];
        if (mesh.parent) { //quick check to see if in scene.
            this.scene.remove(mesh);
        }
    }

    return;
};


Autodesk.Nano.MolViewer.SurfaceView.prototype.setMaterialsBasedUponOpacity = function setMaterialsBasedUponOpacity(){
    var molReps, opacity, mesh,atomsOn, id,i;
    molReps = this.instance.molReps;
    var rep = 'surface';
    var uvAlpha = molReps.reps[rep].getUVAlpha;
    var atomID;
    var atLeastOneTransparent;
    for(id in this._meshes) {
        mesh = this._meshes[id];
        atomsOn = mesh.atomsOn;
        atLeastOneTransparent = false;
        for(i=0;i< atomsOn.length;++i){
            atomID = atomsOn[i];
            var alpha = uvAlpha.getAlpha(atomID);
            if(alpha !== 0xff){
                atLeastOneTransparent = true;
                break;
            }
        }
        if(atLeastOneTransparent){
            mesh.material = molReps.reps[rep].alphaMaterialAtom;
        }else{
            mesh.material = molReps.reps[rep].colorMaterialAtom
        }
        mesh.needsUpdate = true;
        mesh.material.needsUpdate = true;

    }


};
;

/**
 Created by Michael Zyracki Oct 21, 2016
 */



Autodesk.Nano.MolViewer.StickView = function(scene,instance,viewer,options) {

    Autodesk.Nano.MolViewer.BaseView.call(this,scene,instance,viewer);

    this.overlayName = [];
    this.overlayName.push(this.id + '.cylinder');
    this.overlayName.push(this.id + '.sphere');
};

Autodesk.Nano.MolViewer.StickView.prototype = Object.create(Autodesk.Nano.MolViewer.BaseView.prototype);
Autodesk.Nano.MolViewer.StickView.prototype.constructor = Autodesk.Nano.MolViewer.BaseView.prototype;



Autodesk.Nano.MolViewer.StickView.prototype.dtor = function(){

    this.deleteMeshes();
    var name;
    for(var i =0 ;i< this.overlayName.length;++i){
        name = this.overlayName[i];
        this._viewer.impl.removeOverlayScene(name);
    }

};


Autodesk.Nano.MolViewer.StickView.prototype.createAtomSpheres = function createAtomSpheres(id,options){
    //don't do anymore
    var atomsOn  = options.atomsOn;
    var molRepRep = options.molRepRep;
    var getUVColor = molRepRep.getUVColor;
    var newID = id;
    var radius = 0.2;
    var geometry = Autodesk.Nano.MolViewer.createSphereGeometry(newID, this.instance, atomsOn,molRepRep,getUVColor,radius);
    var mesh = this._meshes[newID];
    if(!mesh){
        var out = Autodesk.Nano.MolViewer.createSphereMaterials(newID,this.instance,molRepRep);
        var material = out.material;
        var idMaterial = out.idMaterial;
        var selectionMaterialBase = out.selectionMaterialBase;
        //this.selectionMaterialTop = this.createMaterial(id,molRepRep,'selectionTop');
        material.overrides = {};
        material.overrides['id'] = idMaterial;
        //this._viewer.impl.createOverlayScene(this.overlayName[1], selectionMaterialBase, null);
        mesh = new THREE.Mesh( geometry,material );
        mesh.matrixAutoUpdate = false;
        this._meshes[id] = mesh;
        this.scene.add(mesh);
    }else{
        if(mesh.geometry !==geometry){
            mesh.geometry = geometry;
            mesh.needsUpdate = true;
        }
        if(!mesh.parent){ //not in scene
            this.scene.add(mesh);
        }
    }


};

Autodesk.Nano.MolViewer.StickView.prototype.create = function create(id,options){


    var instance = this.instance;
    var atomsOn = options.atomsOn;
    var molRepRep = options.molRepRep;
    var getUVColor = molRepRep.getUVColor;
    var dataID = md5(atomsOn);
    var newID = id;
    var geometry = instance.molMan.view3DMan.gC.getGeometryCache(newID,'stick',dataID);
    if(!geometry) {
        var geometry = new THREE.InstancedBufferGeometry();
        geometry.copy( new THREE.PlaneBufferGeometry(2.0,2.0)); //make it al ittle bigger
        var helper = new Autodesk.Nano.MolHelper();

        var info = helper.createStickViewArrays(atomsOn, getUVColor, this.instance.molModel.atomMetadata);

        geometry.addAttribute( "positions1", new THREE.InstancedBufferAttribute( info.positions1, 3, 1 ) );
        geometry.addAttribute( "positions2", new THREE.InstancedBufferAttribute( info.positions2, 3, 1 ) );
        geometry.addAttribute( "uvArray", new THREE.InstancedBufferAttribute( info.uvArray, 2, 1 ) );
        //if #ID_BUFFER this.geometry.addAttribute( "IDColor", new THREE.InstancedBufferAttribute( info.idArray, 3, 1 ) );
        this.computeBoundingSphere(info.positions1, info.positions2,geometry);
        instance.molMan.view3DMan.gC.addGeometryCache(newID,'stick',geometry,dataID);
    }
    var mesh = this._meshes[id];
    if(!mesh) {
        this.material = this.createMaterial(id, molRepRep);
        this.idMaterial = this.createMaterial(id, molRepRep, 'id');
        this.selectionMaterialBase = this.createMaterial(id, molRepRep, 'selectionBase');
        //this.selectionMaterialTop = this.createMaterial(id,molRepRep,'selectionTop');
        this._viewer.impl.createOverlayScene(this.overlayName[0], this.selectionMaterialBase, null);

        this.material.overrides = {};
        this.material.overrides['id'] = this.idMaterial;
        /* No directly used
         this.material.overrides['selectionBase'] = this.selectionMaterialBase;
         this.material.overrides['selectionTop'] = this.selectionMaterialTop;
         */
        var mesh = new THREE.Mesh(geometry, this.material);
        mesh.matrixAutoUpdate = false;
        this._meshes[id] = mesh;
        mesh.selectionOverlay = this.overlayName[0]; //needed with selection

        this.scene.add(mesh);
    }
    else{
        if(mesh.geometry !==geometry){
            mesh.geometry = geometry;
            mesh.needsUpdate = true;
        }
        if(!mesh.parent){ //not in scene
            this.scene.add(mesh);
        }
    }
    //we will remove this soon this.createAtomSpheres(newID,options);
    return this._meshes;

};


Autodesk.Nano.MolViewer.StickView.prototype.createMaterial= function createMaterial(id,molRepRep,type){
    var map = molRepRep.colorTextureAtom;

    var viewer = this._viewer;
    var shader, material, matman = viewer.impl.matman();
    var matName;
    if(!type || type === 'id' || type === 'selectionBase' || type === 'selectionTop'){
        shader = THREE.ShaderLib['nano_cylinder'];

        matName = id + '.' + 'StickView';

        material = new THREE.RawShaderMaterial( {
            uniforms: shader.uniforms,
            attributes: shader.attributes,
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
        } );

        material.depthTest= true;
        material.depthWrite = true;
        material.ambient = new THREE.Color(0x161616);
        //material.ambient = new THREE.Color(0x010101);

        //material.color = new THREE.Color(0x777777);
        material.color = new THREE.Color(0xffffff);

        material.emissive = new THREE.Color( 0x000000 );
        material.specular = new THREE.Color( 0x111111 );

        material.shininess = 10;
        material.opcaity = 1.0;

        material.isImposter = true;
        if(type ==='id'){
            material.idAtom = 1;
            matName += '.ID';
            material.map = this.instance.molModel.idTextureAtom;
            material.map.needsUpdate = true;

        }else if (type ==='selectionBase'){
            matName += '.SELECTIONBASE';
            material.depthTest = true;
            material.depthWrite = true;
            material.color = new THREE.Color( 0x000000 );
            material.specular = new THREE.Color( 0x000000 );
            material.emissive =  new THREE.Color( 0x2F51FF );
            material.alphaTest = 0.5;
            material.ambient =  new THREE.Color( 0x000000 );
            material.opacity = 1.0;
            material.alphaMap = this.instance.selectionAlphaTextureAtom;
            material.transparent = false;
        }
        else if (type ==='selectionTop'){
            matName += '.SELECTIONTOP';
            material.depthTest = true;
            material.depthWrite = true;
            material.color = new THREE.Color( 0x000000 );
            material.specular = new THREE.Color( 0x000000 );
            material.emissive =  new THREE.Color( 0x2F51FF );
            material.alphaTest = 0.15;
            material.ambient =  new THREE.Color( 0x000000 );
            material.opacity = 0.15;
            material.alphaMap = this.instance.selectionAlphaTextureAtom;
            material.transparent = true;
        }
        else{
            material.map = map;
            material.map.needsUpdate = true;
            //material.emissive =  0x0f0f0f;
            material.transparent = false;

        }
        matman.addMaterialNonHDR(matName,material);
        material.needsUpdate = true;

        return material;
    }else if (type === 'depth'){

    }
};


Autodesk.Nano.MolViewer.StickView.prototype.createFrom = function createFrom(view, molRepRep) {
    var atomsOn = this.instance.molModel.entities[this.instance.entityIDs[0]].atomIDs;
    var options = {atomsOn:atomsOn, molRepRep: molRepRep };
    this.create(this.instance.entityIDs[0],options);

};

Autodesk.Nano.MolViewer.StickView.prototype.computeBoundingSphere = function computeBoundingSphere (positions1,positions2,geometry) {

    var box = new THREE.Box3();
    var vector = new THREE.Vector3();


    if ( geometry.boundingSphere === null ) {

        geometry.boundingSphere = new THREE.Sphere();

    }


    if ( positions1 && positions2 ) {

        box.makeEmpty();

        var center = geometry.boundingSphere.center;
        var i;
        for (i = 0, il = positions1.length; i < il; i += 3) {

            vector.set(positions1[i], positions1[i + 1], positions1[i + 2]);
            box.expandByPoint(vector);

        }

        for (i = 0, il = positions2.length; i < il; i += 3) {

            vector.set(positions2[i], positions2[i + 1], positions2[i + 2]);
            box.expandByPoint(vector);

        }

        box.center(center);

        // hoping to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

        var maxRadiusSq = 0;

        for (var i = 0, il = positions1.length; i < il; i += 3) {

            vector.set(positions1[i], positions1[i + 1], positions1[i + 2]);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));

        }

        for (var i = 0, il = positions2.length; i < il; i += 3) {

            vector.set(positions2[i], positions2[i + 1], positions2[i + 2]);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));

        }

        geometry.boundingSphere.radius = Math.sqrt(maxRadiusSq);

        if (isNaN(geometry.boundingSphere.radius)) {

            THREE.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.');

        }
    }
};




;/**
 Created by Michael Zyracki Oct 21, 2016
 */

/**
 This manager will contain could to create, hide, display and delete views for the DNA design tool

 **/
/**


 * @type {{}|*|Autodesk.Nano}
 */
Autodesk.Nano = Autodesk.Nano || {};
Autodesk.Nano.MolViewer = Autodesk.Nano.MolViewer || {};

Autodesk.Nano.MolViewer.ViewManager3D = Autodesk.Nano.MolViewer.ViewManager3D  || {};


//constructor
Autodesk.Nano.MolViewer.ViewManager3D = function ViewManager3D(viewer,molMan) {

    this.gC = new Autodesk.Nano.MolViewer.GeometryCache();
    this.resetViewer(viewer);
    this._box3 = new THREE.Box3();
    this.ray = new THREE.Ray();
    this.molMan = molMan;
    //this._showFog = true;
    //this._focusMode = false;
    //base class below
    //this.overlayScenes = null;
    //this.dummyModel = null;

};

Autodesk.Nano.MolViewer.ViewManager3D.prototype.dtor = function dtor(){
    //todo mz make sure to remove geometry
    this.gC.removeAllGeometries();
    delete this.overlayScenes;
    delete this.dummyModel;
    this.viewer.removeEventListener(Autodesk.Nano.INSTANCE_ADDED_EVENT,this._instanceAddedBind);
    this.viewer.removeEventListener(Autodesk.Nano.INSTANCE_DELETED_EVENT,this._instanceDeletedBind);
    this.viewer.removeEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT,this._modelLoadedBind);
    this.viewer.removeEventListener(Autodesk.Nano.MODEL_DELETED_EVENT,this._modelDeletedBind);
    this.viewer.removeEventListener(Autodesk.Nano.INSTANCE_SELECTION_CHANGED_EVENT,this._instanceSelectedBind);
    this.viewer.removeEventListener(Autodesk.Nano.INSTANCES_SET_SELECTION_CHANGED_EVENT,this._instancesSetSelectedBind);
    this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT,this._cameraChangedBind);
    //don't delete the viewer until we unbind the events...
    delete this.viewer;
};



Autodesk.Nano.MolViewer.ViewManager3D.prototype.resetViewer = function resetViewer(viewer){


    if(this.viewer){
        this.dtor();
    }
    this.viewer = viewer;
    this.overlayScenes = null;
    this.dummyModel = null;
    this.instances = {};
    //this._setUpDefaultFactories();

    //using bind() creates a new anonymous function that cannot be unbound using removeEventListener
    //these functions are attached to the even and handle the bind.
    this._modelLoadedBind = this._modelLoaded.bind(this);
    this._modelDeletedBind = this._modelDeleted.bind(this);
    this._instanceAddedBind = this._instanceAdded.bind(this);
    this._instanceDeletedBind = this._instanceDeleted.bind(this);
    this._instanceSelectedBind = this._instanceSelected.bind(this);
    this._instancesSetSelectedBind = this._instancesSetSelected.bind(this);
    this._cameraChangedBind = this._cameraChanged.bind(this);

    this.viewer.addEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT,this._modelLoadedBind);
    this.viewer.addEventListener(Autodesk.Nano.MODEL_DELETED_EVENT,this._modelDeletedBind);
    this.viewer.addEventListener(Autodesk.Nano.INSTANCE_ADDED_EVENT,this._instanceAddedBind);
    this.viewer.addEventListener(Autodesk.Nano.INSTANCE_DELETED_EVENT,this._instanceDeletedBind);
    this.viewer.addEventListener(Autodesk.Nano.INSTANCE_SELECTION_CHANGED_EVENT,this._instanceSelectedBind);
    this.viewer.addEventListener(Autodesk.Nano.INSTANCES_SET_SELECTION_CHANGED_EVENT,this._instancesSetSelectedBind);
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT,this._cameraChangedBind);

    this.overrideSet = false;

};


Autodesk.Nano.MolViewer.ViewManager3D.prototype.setShowFPS = function setShowFPS(on){
    var func = function showFPS(fps){
        console.log(fps);
    }

    if(on){
        this.viewer.impl.fpsCallback = func;
    }else{
        this.viewer.impl.fpsCallback = null;
    }
};

Autodesk.Nano.MolViewer.ViewManager3D.prototype.setShowFog = function setShowFog(on){
    this._showFog = on;
    if(this._showFog){
        if(!this.viewer.impl.scene.fog) {
            var fog = new THREE.Fog(0x050505, 1, 200);
            this.viewer.impl.scene.fog = fog;
            this.overlayScenes.fog = fog;
        }
        this.viewer.impl.scene.fog.color.setRGB(this.viewer.impl.clearColorTop.x,this.viewer.impl.clearColorTop.y,this.viewer.impl.clearColorTop.z);
        var event =  {camera : this.viewer.impl.camera};
        this._cameraChanged(event);
    }else {
        delete this.viewer.impl.scene.fog;
        delete this.overlayScenes.fog;
    }
    var materials = this.viewer.impl.matman().materials;
    for (var p in materials) {
        var m = materials[p];
        m.needsUpdate = true;
    }
    this.viewer.impl.sceneUpdated(true);
};

//MZ TODO most of this is shared make base class?
Autodesk.Nano.MolViewer.ViewManager3D.prototype._modelLoaded = function _modelLoaded(event) {
    //need to create a dummy model for the viewer, need to figure this out later with multiple things loaded
    //ugg needs to happen sooner this.viewer.impl.createExtraScene();

    var myData = {svf: null};
    var newModel = event.model;
    myData.bbox = this.getMolModelBounds(newModel);
    myData.overriddenUnits = 'nm';
    myData.is2d = false;
    myData.loadDone = true;
    if(!this.dummyModel){ //only create if it doesn't exist
        this.dummyModel = new Autodesk.Viewing.Model(myData);
        this.viewer.impl.addModel(this.dummyModel);
        this.viewer.model = this.dummyModel;
        if(this.viewer.createUI) { // skip this for headless mode for now, later we will want the toolbar only
            this.viewer.createUI(this.dummyModel);
        }
        var lightPos = {x: 0, y: 0, z: 1};
        this.viewer.impl.setOverrideLightDirection(lightPos);
        if (!this.overrideSet) {
            this.overrideSet = true;
            this.viewer.impl.setTempHitTestOverride({obj: this, func: this.hitTestOverride});
        }
    }else{
        this.dummyModel.setData(myData);
    }
    this.molMan.bbox = myData.bbox;
    this.molMan.bboxIsDirty = false;
    // Set the viewing direction that will display the largest area of the model.
    var dx = this.molMan.bbox.max.x - this.molMan.bbox.min.x;
    var dy = this.molMan.bbox.max.y - this.molMan.bbox.min.y;
    var dz = this.molMan.bbox.max.z - this.molMan.bbox.min.z;
    var cx = (this.molMan.bbox.max.x + this.molMan.bbox.min.x) / 2.0;
    var cy = (this.molMan.bbox.max.y + this.molMan.bbox.min.y) / 2.0;
    var cz = (this.molMan.bbox.max.z + this.molMan.bbox.min.z) / 2.0;
    var areaVals = [ dx*dy, dx*dz, dy*dz ];
    var maxAreaIndex = areaVals[0] > areaVals[1] ? 0 : 1;
    maxAreaIndex = areaVals[2] > areaVals[maxAreaIndex] ? 2 : maxAreaIndex;

    var up = new THREE.Vector3(0.0, 1.0, 0.0);
    var wup = new THREE.Vector3(0.0, 1.0, 0.0);
    var pos = new THREE.Vector3(cx, cy, cz-dz);
    var target = new THREE.Vector3(cx, cy, cz);

    if (maxAreaIndex == 1) { 
        up.set(1.0, 0.0, 0.0); 
        wup.set(1.0, 0.0, 0.0); 
        pos.set(cx, cy-dy, cz); 
    }
    else if (maxAreaIndex == 2) { 
        up.set(0.0, 0.0, -1.0); 
        wup.set(0.0, 0.0, -1.0); 
        pos.set(cx-dx, cy, cz); 
    }

    this.viewer.navigation.setPosition(pos);
    this.viewer.navigation.setTarget(target);
    this.viewer.navigation.setWorldUpVector(up, true);
    this.viewer.navigation.updateCamera();
    var camera = this.viewer.navigation.getCamera();
    this.viewer.autocam.setHomeViewFrom(camera);

    this.viewer.autocam.goHome(true);
    this.viewer.autocam.setCurrentViewAsHome(true);

};

Autodesk.Nano.MolViewer.ViewManager3D.prototype._modelDeleted = function _modelDeleted(event) {

};

Autodesk.Nano.MolViewer.ViewManager3D.prototype._instanceAdded  = function _instanceAdded(event){
    var instance,namespace,type;
    if(event && event.instance){
        if (!this.overlayScenes) {
            this.overlayScenes = this.viewer.impl.scene;
            if(this._showFog) {
                this.setShowFog(true);
            }
        }

        instance = event.instance;
        namespace = instance.getNameSpace();
        if(namespace === 'mol'){
            type = instance.getType();
            var inst = {instance: instance, views:{}};
            this.instances[instance.id] = inst;
            if(type){
                this._createViews(type,instance);
            }
        }
    }
};

Autodesk.Nano.MolViewer.ViewManager3D.prototype._instanceDeleted  = function _instanceDeleted(event){
    var id = event.instance.getID();
    var inst,viewID;

    inst = this.instances[id];
    if(inst && inst.views) {
        for (viewID in inst.views) {
            var view = inst.views[viewID];
            this._removeViewMeshes(view,inst.instance);
            view.dtor();

            var event = {
                type: Autodesk.Nano.MolViewer.VIEW_DELETED_EVENT,
                view: view,
                instance: inst.instance
            };
            this.viewer.fireEvent(event);
        }
        delete this.instances[id];
    }
};


Autodesk.Nano.MolViewer.ViewManager3D.prototype._instanceSelected  = function _instanceSelected(event){
    var instance,selection,origInstance;
    var id;
    if(event && event.instance){
        instance = event.instance;
        selection = instance.selection;
        if(instance.getType() === 'domain'){ //only have strands view domains for now
            origInstance = instance;
            instance = instance.strandParent; //
            if (this.instances[instance.getID()]) {
                var inst = this.instances[instance.getID()];
                for (id in inst.views) {
                    inst.views[id].select(origInstance, selection); //the view will handle sub selection
                }
            }
        }else {
            if (this.instances[instance.getID()]) {
                var inst = this.instances[instance.getID()];
                for (id in inst.views) {
                    if (instance.getSelected()) {
                        inst.views[id].select(instance, selection);
                    } else {
                        inst.views[id].clearSelection();
                    }
                }
            }
        }
    }
};


Autodesk.Nano.MolViewer.ViewManager3D.prototype._instancesSetSelected  = function _instancesSetSelected(event){

};



Autodesk.Nano.MolViewer.ViewManager3D.prototype.getMolModelBounds = function getMolModelBounds(molModel) {
    var bounds = new THREE.Box3();
    bounds.max.x = molModel.bbox.max.x + 5.0;
    bounds.max.y = molModel.bbox.max.y + 5.0;
    bounds.max.z = molModel.bbox.max.z + 5.0;
    bounds.min.x = molModel.bbox.min.x - 5.0;
    bounds.min.y = molModel.bbox.min.y - 5.0;
    bounds.min.z = molModel.bbox.min.z - 5.0;

    return bounds;
};


Autodesk.Nano.MolViewer.ViewManager3D.prototype.getOverlayBounds = function getOverlayBounds() {
    var bounds = new THREE.Box3();

    for (var i in this.overlayScenes) {
        this._computeObjectBounds(bounds, this.overlayScenes[i]);
    }
    return bounds;
};

Autodesk.Nano.MolViewer.ViewManager3D.prototype._deleteView = function _deleteView(inst,type){
    var view = inst.views[type];
    this._removeViewMeshes(view,inst.instance);
    view.dtor();
    delete inst.views[type];
    var event = {
        type: Autodesk.Nano.MolViewer.VIEW_DELETED_EVENT,
        view: view,
        instance: inst.instance
    };
    this.viewer.fireEvent(event);
};




Autodesk.Nano.MolViewer.ViewManager3D.prototype._cameraChanged = function _cameraChanged(event){
    /*
    if(this.molMan.bbox && this.overlayScenes && this.overlayScenes['cylinder'] && this.overlayScenes['cylinder'].fog) {
        if(!this._bboxClone) {
            this._bboxClone = this.molMan.bbox.clone();
        }
        this._bboxClone.min.x = this.molMan.bbox.min.x;
        this._bboxClone.min.y = this.molMan.bbox.min.y;
        this._bboxClone.min.z = this.molMan.bbox.min.z;
        this._bboxClone.max.x = this.molMan.bbox.max.x;
        this._bboxClone.max.y = this.molMan.bbox.max.y;
        this._bboxClone.max.z = this.molMan.bbox.max.z;

        this._bboxClone.applyMatrix4(event.camera.matrixWorldInverse);
        var far = Math.abs(this._bboxClone.min.z);
        var near = Math.abs(this._bboxClone.max.z);

        this.overlayScenes.fog.far = far;
        this.overlayScenes.fog.near = near;
    }
*/
};





Autodesk.Nano.MolViewer.ViewManager3D.prototype.hitTestOverride = function hitTestOverride(vpVec){
    var result;
    var atomID = this.viewer.impl.hitTestPixel(vpVec);
    if (atomID >= 0) {
        var ray = this.ray;
        this.viewer.impl.viewportToRay(vpVec, ray);
        var instance = this.molMan.findHitTestInstance(ray,atomID);
        result = {instance:instance, atomID: atomID};

    }
    return result;

};

Autodesk.Nano.MolViewer.ViewManager3D.prototype.markObject = function markObject(result,keepSelection){
    result.instance.markObject(result,keepSelection);

};

Autodesk.Nano.MolViewer.ViewManager3D.prototype.toggleSelection = function toggleSelection(results){
  /*  for(var i =0;i< resultArray.length;++i) {
        this.markObject(resultArray[0],true);
    }
    */
};













;Autodesk.Nano.MolViewer = Autodesk.Nano.MolViewer || {};

Autodesk.Nano.MolViewer.SelectionCmd = function(options) {

    Autodesk.Nano.BaseCmd.call(this,'molselection',options);
    this.molModel = options.molModel;
    this.instanceArray = options.instanceArray; //no instanceArray then do a clear!
    this.nofire = options.nofire;


    this.prevState = this.setStateFromMolModel();
    this.currentState = null;
};


Autodesk.Nano.MolViewer.SelectionCmd.prototype = Object.create(Autodesk.Nano.BaseCmd.prototype);
Autodesk.Nano.MolViewer.SelectionCmd.prototype.constructor = Autodesk.Nano.BaseCmd;

Autodesk.Nano.MolViewer.SelectionCmd.prototype.dtor = function dtor() {
    delete this.molModel;
};

/**
 * When overridden may also need to remove!
 */
Autodesk.Nano.MolViewer.SelectionCmd.prototype.dtor = function dtor(){
    delete this.molModel;
};

Autodesk.Nano.MolViewer.SelectionCmd.prototype.redoIt = function redoIt(){
    if(this.currentState){
        this.setMolModelSelFromState(this.currentState);
    }else{
        this.clearSelection();
    }
    this.molModel.fireSelectionChangedEvent();
};




Autodesk.Nano.MolViewer.SelectionCmd.prototype.undoIt = function undoIt(){
    if(this.prevState){
        this.setMolModelSelFromState(this.prevState);
    }else{
        this.clearSelection();
    }
    this.molModel.fireSelectionChangedEvent();

};

Autodesk.Nano.MolViewer.SelectionCmd.prototype.run = function run() {

    if(this.instanceArray){
        var i,atoms;
        for (i = 0; i < this.instanceArray.length; i++) {
            atoms = this.instanceArray[i].instance._getAtoms(this.instanceArray[i].what);
            this.instanceArray[i].instance._setSelections(this.instanceArray[i].what);
            this.instanceArray[i].instance.atomSelectionState.setAtomsSelected(atoms,1);
        }
        this.currentState = this.setStateFromMolModel();
    }else{
        this.clearSelection();
        this.currentState = null; //tells us to do clearSelection
    }
    if ( !this.nofire) {
        this.molModel.fireSelectionChangedEvent();
    }
};

Autodesk.Nano.MolViewer.SelectionCmd.prototype.setStateFromMolModel = function setStateFromMolModel(){
    var molModel = this.molModel;
    var state = [];
    var i, instance,selection;
    for (i = 0; i < molModel.activeInstances.length; ++i) {
        instance = molModel.activeInstances[i];
        selection = instance.getCopyOfSelection();
        if(selection) {
            state.push({
                selection: selection,
                instance: instance
            });
        }
    }
    if(state.length >0){
        return state;
    }else{
        return null; //nothign selected on any instance!
    }
};

Autodesk.Nano.MolViewer.SelectionCmd.prototype.setMolModelSelFromState = function setMolModelSelFromState(state){
    for(var i =0; i < state.length; ++i){
        var instance = state[i].instance;
        instance.setSelectionFromState(state[i].selection);
    }
};

Autodesk.Nano.MolViewer.SelectionCmd.prototype.clearSelection = function clearSelection(){
    var molModel = this.molModel;

    var i;
    for (i = 0; i < molModel.activeInstances.length; ++i) {
        molModel.activeInstances[i].clearSelection();
    }


};;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Annotate');

Autodesk.Viewing.Extensions.Annotate.AnnotateExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
    this.app = options.app;
    this.annotateMan = options.app.AnnotateMan;
};

Autodesk.Viewing.Extensions.Annotate.AnnotateExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Annotate.AnnotateExtension.prototype.constructor = Autodesk.Viewing.Extensions.Annotate.AnnotateExtension;

Autodesk.Viewing.Extensions.Annotate.AnnotateExtension.prototype.load  = function() {

    var self = this;
    var viewer = this.viewer;

    this.escapeHotkeyId = 'Autodesk.Annotate.Hotkeys.Escape';

    // Register the Annotate tool
    if (!viewer.toolController) {
        return false;
    }

    this.tool = {
        _names: ["annotate"],
        _active: false,
        getNames: function() {
            return this._names;
        },
        getName: function() {
            return this._names[0];
        },
        isActive: function() {
            return this._active;
        },
        activate: function() {
            this._active = true;
            self.annotateMan.activate();
        },
        deactivate: function() {
            this._active = false;
            self.annotateMan.deactivateAnnotateMode();
        },
        setAnnotationType: function(type) {
            self.annotateMan.setAnnotationType(type);
            self.annotateMan.setLabelTextFromType(type);
        },
        switchAnnotationType: function(type) {
            self.annotateMan.deactivateAnnotateMode();
            self.annotateMan.setAnnotationType(type);
            if(this._active) {
                self.annotateMan.activate();
            }
        }
    };

    viewer.toolController.registerTool(this.tool);

    function onModelLoaded() {
        if(!self.app.Loader.options.headless) {
            self.createUI();
        }

    }

    if (!self.app.Loader.options.headless && self.app.ViewManager.getTopView('InspectorView')) {
        self.createUI();
    } else {
        this.viewer.addEventListener(Autodesk.Viewing.INSPECTOR_LOADED, onModelLoaded);
    }

    return true;
};

Autodesk.Viewing.Extensions.Annotate.AnnotateExtension.prototype.setLabelTextFromType = function setLabelTextFromType(type) {
    if(type === 'annotation') {
        this.annotateToolButton.icon.innerHTML = 'Annotation';
    } else if (type === 'caption') {
        this.annotateToolButton.icon.innerHTML = 'Title';
    } else {
        this.annotateToolButton.icon.innerHTML = 'Annotate';
    }
};

Autodesk.Viewing.Extensions.Annotate.AnnotateExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // Hide edit UI for the annotations
    this.destroyUI();
    //this.disableEdit();

    //Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

/**
 * Enable/disable the annotate tool.
 * @param {boolean} enable - true to enable, false to disable.
 * @returns {boolean} true if the tool state was changed.
 */
Autodesk.Viewing.Extensions.Annotate.AnnotateExtension.prototype.enableAnnotateTool = function(enable) {
    if (this.tool) {
        var toolController = this.viewer.toolController,
            isActive = this.tool.isActive();

        if (enable && !isActive) {
            toolController.activateTool("annotate");
            return true;
        } else if (!enable && isActive) {
            toolController.deactivateTool("annotate");
            return true;
        }
    }
    return false;
};

Autodesk.Viewing.Extensions.Annotate.AnnotateExtension.prototype.createUI = function() {
    var AVU = Autodesk.Viewing.UI;
    var self = this;
    var viewer = this.viewer;

    this.annotateToolButton = null;

    // Create a combo button for the measure tool.
    this.annotateToolButton = new AVU.InspectorButton("annotateTool", {app: this.app});
    this.annotateToolButton.setToolTip('Annotate');
    this.annotateToolButton.icon.innerHTML = 'Annotate';
    this.captionToolButton = new AVU.InspectorButton("titleTool", {app: this.app});
    this.captionToolButton.setToolTip('Caption');
    this.captionToolButton.icon.innerHTML = 'Caption';

    this.createNavToggler = function createNavToggler(button, altButton, name) {
        return function() {
            var state = button.getState();
            if (state === AVU.Button.State.INACTIVE) {
                altButton.setState(AVU.Button.State.INACTIVE);
                button.setState(AVU.Button.State.ACTIVE);
                self.tool.switchAnnotationType(name);
                self.enableAnnotateTool(true);
            } else if (state === AVU.Button.State.ACTIVE) {
                altButton.setState(AVU.Button.State.INACTIVE);
                button.setState(AVU.Button.State.INACTIVE);
                self.enableAnnotateTool(false);
            }
        };
    };


    this.annotateToolButton.setState = function setActive(isActive) {
        if(isActive === 0) {
            this.container.classList.add('active');
            this._state = 0;
        } else {
            this.container.classList.remove('active');
            this._state = 1;
        }
    };

    this.captionToolButton.setState = function setActive(isActive) {
        if(isActive === 0) {
            this.container.classList.add('active');
            this._state = 0;
        } else {
            this.container.classList.remove('active');
            this._state = 1;
        }
    };

    this.annotateToolButton.onClick = self.createNavToggler(self.annotateToolButton, self.captionToolButton, 'annotation');
    this.captionToolButton.onClick = self.createNavToggler(self.captionToolButton, self.annotateToolButton, 'caption');


    this.app.ViewManager.getTopView('InspectorView').getToolSet().addControl(this.annotateToolButton, {index:2});
    this.app.ViewManager.getTopView('InspectorView').getToolSet().addControl(this.captionToolButton, {index:3});

    // Escape hotkey to exit tool
    //
    var hotkeys = [{
        keycodes: [
            Autodesk.Viewing.theHotkeyManager.KEYCODES.ESCAPE
        ],
        onRelease: function () {
            return self.enableAnnotateTool(false);
        }
    }];
    Autodesk.Viewing.theHotkeyManager.pushHotkeys(this.escapeHotkeyId, hotkeys);
};

Autodesk.Viewing.Extensions.Annotate.AnnotateExtension.prototype.createSubmenu = function(parentButton)
{
    var self = this;
    var viewer = this.viewer;
    var AVU = Autodesk.Viewing.UI;

    function createNavToggler(button, name) {
        return function() {
            var state = button.getState();
            if (state === AVU.Button.State.INACTIVE) {
                button.setState(AVU.Button.State.ACTIVE);
                if (this instanceof AVU.ComboButton === false) {
                    self.tool.switchAnnotationType(name);
                } else {
                    self.tool.attachControl(true);
                }
                self.enableAnnotateTool(true);
            } else if (state === AVU.Button.State.ACTIVE) {
                button.setState(AVU.Button.State.INACTIVE);
                self.enableAnnotateTool(false);
            }
        };
    }


    var buttonText;
    var annotationButton = this.annotationButton = new AVU.ListButton("annotation");
    buttonText = document.createTextNode('Annotation');
    annotationButton.setToolTip('Add Annotation');
    annotationButton.container.appendChild(buttonText);
    annotationButton.onClick = createNavToggler(annotationButton, 'annotation');
    parentButton.addControl(annotationButton);

    var mainCaptionButton = this.mainCaptionButton = new AVU.ListButton("main-caption");
    buttonText = document.createTextNode('Caption');
    mainCaptionButton.setToolTip('Add Caption');
    mainCaptionButton.container.appendChild(buttonText);
    mainCaptionButton.onClick = createNavToggler(mainCaptionButton, 'caption');
    parentButton.addControl(mainCaptionButton);
};

Autodesk.Viewing.Extensions.Annotate.AnnotateExtension.prototype.destroyUI = function() {
    var viewer = this.viewer;

    if (viewer.model.is2d())
        return;

    if (this.annotateToolButton) {
        this.annotateToolButton.removeEventListener(Autodesk.Viewing.UI.Button.Event.STATE_CHANGED, this.onAnnotateButtonStateChange);
        this.annotateToolButton.removeEventListener('click',this.clickEvent);
    }

    var toolset = this.app.ViewManager.getTopView('InspectorView').getToolSet();
    if (toolset) {
        if (this.annotateToolButton) {
            toolset.removeControl(this.annotateToolButton.getId());
        }
        this.annotateToolButton = null;
    }

    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.escapeHotkeyId);
};

Autodesk.Viewing.Extensions.Annotate.AnnotateExtension.prototype.disableEdit = function() {
    var viewer = this.viewer;

    if (this.annotateToolButton) {
        this.annotateToolButton.removeEventListener(Autodesk.Viewing.UI.Button.Event.STATE_CHANGED, this.onAnnotateButtonStateChange);
    }

    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.escapeHotkeyId);
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Annotate', Autodesk.Viewing.Extensions.Annotate.AnnotateExtension);
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.DefaultTools');

(function() {

var av = Autodesk.Viewing;
var avet = Autodesk.Viewing.Extensions.DefaultTools;
var AVU = Autodesk.Viewing.UI;


function createNavToggler(viewer, button, name) {
    return function() {
        var state = button.getState();
        if (state === AVU.Button.State.INACTIVE) {
            viewer.setActiveNavigationTool(name);
            button.setState(AVU.Button.State.ACTIVE);
        } else if (state === AVU.Button.State.ACTIVE) {
            viewer.setActiveNavigationTool();
            button.setState(AVU.Button.State.INACTIVE);
        }
    };
}

avet.NavToolsExtension = function(viewer, options) {
    av.Extension.call(this, viewer, options);
    if(options.app) {
        this.app = options.app;
        this.molMan = options.app.MolMan;
        this.viewManager = options.app.ViewManager;
        this.loader = options.app.Loader;
    }
};

avet.NavToolsExtension.prototype = Object.create(av.Extension.prototype);
avet.NavToolsExtension.prototype.constructor = avet.NavToolsExtension;

avet.NavToolsExtension.prototype.load = function() {
    var viewer = this.viewer;

    // Register tools
    // disable the fov tool
    //var fovtool  = new av.FovTool(viewer);
    var rolltool = new av.WorldUpTool(viewer.impl, viewer);

    //viewer.toolController.registerTool( fovtool );
    viewer.toolController.registerTool( rolltool );

    this.createUI(this.molMan,this.viewManager,this.loader);
    this.initCameraStateMachine();

    return true;
};

avet.NavToolsExtension.prototype.createUI = function(molMan,viewManager,loader) {
    // Adds the UI for the default navigation tools (orbit, pan, dolly, camera controls)
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);
    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);
    var selTools = toolbar.getControl(av.TOOLBAR.SELTOOLSID);

    if (navTools) {
        navTools.returnToDefault = function () {
        };
    }


    if (selTools) {
        this.dropDownData = {
            selection: {
                header: {
                    text: "SELECTION",
                    id: "topMenuSELECTION",
                    topMenu: false
                },
                items: {
                    instance: {
                        text: "Instances",
                        icon: "molviewer/res/images/icons/checkmark.svg",
                        id: "menuSelectByInstance",
                        hotkey: "Q",
                        check: function () {
                            if (molMan.selectionFilter === 'instance') {
                                return true;
                            } else {
                                return false;
                            }
                        },
                        action: function (event) {
                            molMan.selectionFilter = 'instance';
                            molMan.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
                            viewManager.getTopView('HeaderView').blink(event);
                        }
                    },
                    chain: {
                        text: "Chains",
                        icon: "molviewer/res/images/icons/checkmark.svg",
                        id: "menuSelectByChain",
                        hotkey: "W",
                        check: function () {
                            if (molMan.selectionFilter === 'chain') {
                                return true;
                            } else {
                                return false;
                            }
                        },
                        action: function (event) {
                            molMan.selectionFilter = 'chain';
                            molMan.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
                            viewManager.getTopView('HeaderView').blink(event);
                        }
                    },
                    residue: {
                        text: "Residues",
                        icon: "molviewer/res/images/icons/checkmark.svg",
                        id: "menuSelectByResidue",
                        hotkey: "E",
                        check: function () {
                            if (molMan.selectionFilter === 'residueID') {
                                return true;
                            } else {
                                return false;
                            }
                        },
                        action: function (event) {
                            molMan.selectionFilter = 'residueID';
                            molMan.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
                            viewManager.getTopView('HeaderView').blink(event);
                        }
                    },
                    residueType: {
                        text: "Residue Type",
                        icon: "molviewer/res/images/icons/checkmark.svg",
                        id: "menuSelectByResidueType",
                        check: function () {
                            if (molMan.selectionFilter === 'residue') {
                                return true;
                            } else {
                                return false;
                            }
                        },
                        action: function (event) {
                            molMan.selectionFilter = 'residue';
                            molMan.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
                            viewManager.getTopView('HeaderView').blink(event);
                        }
                    },

                    atom: {
                        text: "Atoms",
                        icon: "molviewer/res/images/icons/checkmark.svg",
                        id: "menuSelectByAtom",
                        hotkey: "R",
                        check: function () {
                            if (molMan.selectionFilter === 'atomID') {
                                return true;
                            } else {
                                return false;
                            }
                        },
                        action: function (event) {
                            molMan.selectionFilter = 'atomID';
                            molMan.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
                            viewManager.getTopView('HeaderView').blink(event);
                        }
                    },
                    atomType: {
                        text: "Atom Type",
                        icon: "molviewer/res/images/icons/checkmark.svg",
                        id: "menuSelectByAtomType",
                        check: function () {
                            if (molMan.selectionFilter === 'atom') {
                                return true;
                            } else {
                                return false;
                            }
                        },
                        action: function (event) {
                            molMan.selectionFilter = 'atom';
                            molMan.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
                            viewManager.getTopView('HeaderView').blink(event);
                        }
                    }
                }
            }
        };

        var selectButton = new AVU.Button('toolbar-selectTool', {app: this.app});
        selectButton.setToolTip('Select');
        selectButton.setIcon('toolbar-selectTool');
        selectButton.addLabel('Residues ');
        selectButton.addDropdown();
        selectButton.populateDropdown(this.dropDownData.selection);
        selectButton.onClick = createNavToggler(viewer, selectButton, 'select');
        selTools.addControl(selectButton);
        selTools.panbutton = selectButton;
    }

    if (navTools) {
        if (this.options.mode === '3d') {
            var orbitButton = new AVU.Button('toolbar-orbitTool', {app: this.app});
            orbitButton.setToolTip('Orbit');
            orbitButton.setIcon('toolbar-orbitTool');
            orbitButton.onClick = createNavToggler(viewer, orbitButton, 'orbit');

            navTools.addControl(orbitButton);
            navTools.orbitbutton = orbitButton;
            orbitButton.setState(AVU.Button.State.ACTIVE);
            navTools.returnToDefault = function () {
                orbitButton.setState(AVU.Button.State.ACTIVE);
            };
        }

        if (!loader.options.config3d.noPan) {
            var panButton = new AVU.Button('toolbar-panTool', {app: this.app});
            panButton.setToolTip('Pan');
            panButton.setIcon('toolbar-panTool');
            panButton.onClick = createNavToggler(viewer, panButton, 'pan');

            navTools.addControl(panButton);
            navTools.panbutton = panButton;
        }

        var dollyButton = new AVU.Button('toolbar-zoomTool', {app: this.app});
        dollyButton.setToolTip('Zoom');
        dollyButton.setIcon('toolbar-zoomTool');
        dollyButton.onClick = createNavToggler(viewer, dollyButton, 'dolly');

        navTools.addControl(dollyButton);
        navTools.dollybutton = dollyButton;
    }
    ;

    avet.NavToolsExtension.prototype.initCameraStateMachine = function (mode) {
        var self = this;
        var viewer = this.viewer;
        var toolbar = viewer.getToolbar(true);
        var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

        this.toolChangedHandler = function (e) {
            // disable the fov tool
            //if (e.toolName === "fov") {
            //    self.showFocalLengthOverlay(e.active);
            //}
        };
        viewer.addEventListener(av.TOOL_CHANGE_EVENT, this.toolChangedHandler);

        this.navChangedHandler = function (e) {
            if (viewer.getDefaultNavigationToolName() === e.id)
                navTools.returnToDefault();
        };
        viewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.navChangedHandler);
    };
}

avet.NavToolsExtension.prototype.unload = function () {
    this.destroyUI();

    return true;
};

avet.NavToolsExtension.prototype.destroyUI = function () {
    // Removes the UI created in createUI
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(false);

    if (!toolbar) {
        return true;
    }

    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

    if (!navTools) {
        return true;
    }

    if (this.options.mode === '3d') {
        navTools.removeControl(navTools.orbitbutton.getId());
        navTools.orbitbutton = null;
    }

    navTools.removeControl(navTools.panbutton.getId());
    navTools.panbutton = null;

    navTools.removeControl(navTools.dollybutton.getId());
    navTools.dollybutton = null;

    // Remove Listeners
    viewer.removeEventListener(av.TOOL_CHANGE_EVENT, this.toolChangedHandler);
    this.toolChangedHandler = null;
    viewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.navChangedHandler);
    this.navChangedHandler = null;

    return true;
};

av.theExtensionManager.registerExtension('Autodesk.DefaultTools.NavTools', avet.NavToolsExtension);

})();
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Explode');

Autodesk.Viewing.Extensions.Explode.ExplodeExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
    this.app = options.app;
    this.molMan = options.app.MolMan;
};

Autodesk.Viewing.Extensions.Explode.ExplodeExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Explode.ExplodeExtension.prototype.constructor = Autodesk.Viewing.Extensions.Explode.ExplodeExtension;

Autodesk.Viewing.Extensions.Explode.ExplodeExtension.prototype.load  = function() {

    var self = this;
    var viewer = this.viewer;


    // Register the Explode tool
    if (!viewer.toolController) {
        return false;
    }

    this.tool = {
        _names: ["explode"],
        _active: false,
        getNames: function() {
            return this._names;
        },
        getName: function() {
            return this._names[0];
        },
        isActive: function() {
            return this._active;
        }
    };

    viewer.toolController.registerTool(this.tool);

    function onModelLoaded() {
        if (!self.app.Loader.options.headless) {
            self.createUI();
        }
        self.enableExplodeTool(!self.tool.isActive());
        self.bindEvents();
    }

    if (!self.app.Loader.options.headless && self.app.ViewManager.getTopView('InspectorView')) {
        onModelLoaded();
    } else {
        self.viewer.addEventListener(Autodesk.Viewing.INSPECTOR_LOADED, onModelLoaded);
    }

    return true;
};

Autodesk.Viewing.Extensions.Explode.ExplodeExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // Hide edit UI for the annotations
    this.destroyUI();

    //unbind event handlers
    this.unbindEvents();

    //Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

/**
 * Enable/disable the annotate tool.
 * @param {boolean} enable - true to enable, false to disable.
 * @returns {boolean} true if the tool state was changed.
 */
Autodesk.Viewing.Extensions.Explode.ExplodeExtension.prototype.enableExplodeTool = function(enable) {
    if (this.tool) {
        var toolController = this.viewer.toolController,
            isActive = this.tool.isActive();

        if (enable && !isActive) {
            toolController.activateTool("annotate");
            return true;
        } else if (!enable && isActive) {
            toolController.deactivateTool("annotate");
            return true;
        }
    }
    return false;
};


Autodesk.Viewing.Extensions.Explode.ExplodeExtension.prototype.bindEvents = function() {
    this.viewer.addEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT, this.updateExplodeSlider);
    this.viewer.addEventListener(Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT, this.updateExplodeSlider);
    this.viewer.addEventListener(Autodesk.Nano.MODEL_DELETED_EVENT, this.resetExplodeSlider);
};

Autodesk.Viewing.Extensions.Explode.ExplodeExtension.prototype.unbindEvents = function() {
    this.viewer.removeEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT, this.updateExplodeSlider);
    this.viewer.removeEventListener(Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT, this.updateExplodeSlider);
    this.viewer.removeEventListener(Autodesk.Nano.MODEL_DELETED_EVENT, this.resetExplodeSlider);
};

Autodesk.Viewing.Extensions.Explode.ExplodeExtension.prototype.createUI = function() {
    var AVU = Autodesk.Viewing.UI;
    var self = this;
    var viewer = this.viewer;
    var options = {
        class: 'inspector-slider',
        icon0: 'explode-0',
        icon1: 'explode-1',
        min: 0.0,
        max: 1.0,
        step: 0.01,
        val: 0.0
    };
    this.annotateToolSlider = null;

    // Create a slider for the explode tool.
    this.explodeToolSlider = new Autodesk.Viewing.UI.Slider('sliderExplode',options);
    this.explodeToolSlider.setState = function setActive(isActive) {
        if(isActive === 0) {
            this.container.classList.add('active');
        } else {
            this.container.classList.remove('active');
        }
    };

    this.explodeToolSlider.onInput = function (event) {
        self.viewer.explode(event.target.value);
        self.toggleExplodeImages(event.target.value);

        // Slider fade effect for mobile devices
        if ((!isTouchDevice() || window.innerWidth <= Autodesk.Viewing.MolViewer.MAX_PHONE_MODE_RESOLUTION) && !av.isMobileDevice()) {
            self.app.ViewManager.getTopView('InspectorView').hideInspector(event.target.parentNode);
        }
    };

    this.explodeToolSlider.onChange = function (event) {
        self.viewer.explode(event.target.value);
        self.toggleExplodeImages(event.target.value);

        // Slider fade effect for mobile devices
        if ((!isTouchDevice() || window.innerWidth <= Autodesk.Viewing.MolViewer.MAX_PHONE_MODE_RESOLUTION) && !av.isMobileDevice()) {
            self.app.ViewManager.getTopView('InspectorView').showInspector(event.target.parentNode);
        }
    };

    this.toggleExplodeImages = function toggleExplodeImages(val) {
        if(val > 0) {
            self.app.container.querySelector('.explode-0').classList.add('active');
            self.app.container.querySelector('.explode-1').classList.add('active');
        } else {
            self.app.container.querySelector('.explode-0').classList.remove('active');
            self.app.container.querySelector('.explode-1').classList.remove('active');
        }
    };

    this.resetExplodeSlider = function resetExplodeSlider() {
        self.explodeToolSlider.sliderElement.value = 0;
        self.toggleExplodeImages(0);
    };

    this.updateExplodeSlider = function updateExplodeSlider() {
        var explodeScale = self.molMan.molModels[self.molMan.currentMolModelID].getExplodeScale();
        explodeScale = parseFloat(explodeScale);
        explodeScale = isNaN(explodeScale) ? 0 : explodeScale;
        self.explodeToolSlider.sliderElement.value = explodeScale;
        self.toggleExplodeImages(explodeScale);

    };

    this.app.ViewManager.getTopView('InspectorView').getToolSet().addControl(this.explodeToolSlider, {index:0});

};

Autodesk.Viewing.Extensions.Explode.ExplodeExtension.prototype.destroyUI = function() {
    var viewer = this.viewer;

    if (viewer.model.is2d())
        return;

    var toolset = this.app.ViewManager.getTopView('InspectorView').getToolSet();
    if (toolset) {
        if (this.explodeToolSlider) {
            toolset.removeControl(this.explodeToolSlider.getId());
        }
        this.explodeToolSlider = null;
    }

};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Explode', Autodesk.Viewing.Extensions.Explode.ExplodeExtension);
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Measure');

Autodesk.Viewing.Extensions.Measure.MeasureExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
    this.app = options.app;
    this.measureMan = options.app.MeasureMan;
    this.molMan = options.app.MolMan;
};

Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.constructor = Autodesk.Viewing.Extensions.Measure.MeasureExtension;

Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.load = function() {

    var self   = this;
    var viewer = this.viewer;

    this.escapeHotkeyId = 'Autodesk.Measure.Hotkeys.Escape';

    // Register the Measure tool
    if (!viewer.toolController){
        return false;
    }
    this.tool = new Autodesk.Viewing.Extensions.Measure.MeasureTool(viewer, this.molMan, this.measureMan, { onCloseCallback: function(e) {
        self.enableMeasureTool(false);
    }});
    viewer.toolController.registerTool(this.tool);

    function onModelLoaded() {
        if (!self.app.Loader.options.headless) {
            self.createUI();
        }


    }


    if (!self.app.Loader.options.headless && self.app.ViewManager.getTopView('InspectorView')) {
        self.createUI();
    } else {
        this.viewer.addEventListener(Autodesk.Viewing.INSPECTOR_LOADED, onModelLoaded);
    }

    // add a callback to restore the state of the measuring tool from the URL.
    viewer.addEventListener(Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT, stateRestoredCB);

    function stateRestoredCB(event) {
        var obj = event.state.measure; // might not exist if state was from headless viewer
        var tool = self.tool;
        if (obj && obj.firstClick && obj.secondClick) {
            self.enableMeasureTool(true);
            tool.setState(obj);
        } else {
            self.enableMeasureTool(false);
        }
    }

    return true;
};

Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // Remove the ui from the viewer.
    this.destroyUI();

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

/**
 * Enable/disable the measure tool.
 * @param {boolean} enable - true to enable, false to disable.
 * @returns {boolean} true if the tool state was changed.
 */
Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.enableMeasureTool = function(enable) {
    if (this.tool) {
        var toolController = this.viewer.toolController,
            isActive = this.tool.isActive();

        if (enable && !isActive) {
            toolController.activateTool("measure");
            this.measureToolButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
            return true;

        } else if (!enable && isActive) {
            toolController.deactivateTool("measure");
            this.measureToolButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
            return true;
        }
    }
    return false;
};

Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.createUI = function()
{
    var AVU    = Autodesk.Viewing.UI;
    var self   = this;
    var viewer = this.viewer;

    this.measureToolButton = null;

    // Do not add Measure Tool for 2d.
    //if (!viewer.model || viewer.model.is2d())
    //    return;

    // Create a button for the measure tool.
    this.measureToolButton = new Autodesk.Viewing.UI.InspectorButton('btnMeasure',{app: this.app});
    this.measureToolButton.container.innerHTML = 'Measure';
    this.measureToolButton.setState = function setActive(isActive) {
        if(isActive === 0) {
            this.container.classList.add('active');
        } else {
            this.container.classList.remove('active');
        }
    };

    this.measureToolButton.onClick = function(e) {
        self.enableMeasureTool(!self.tool.isActive());
    };

    this.measureToolButton.addEventListener(AVU.Button.Event.STATE_CHANGED, this.onMeasureButtonStateChange);
    this.app.ViewManager.getTopView('InspectorView').getToolSet().addControl(this.measureToolButton, {index:1});

    // Escape hotkey to exit tool.
    //
    var hotkeys = [{
        keycodes: [
            Autodesk.Viewing.theHotkeyManager.KEYCODES.ESCAPE
        ],
        onRelease: function () {
            return self.enableMeasureTool(false);
        }
    }];
    Autodesk.Viewing.theHotkeyManager.pushHotkeys(this.escapeHotkeyId, hotkeys);
};

Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.destroyUI = function() {
    var viewer = this.viewer;

    if (viewer.model.is2d())
        return;

    if (this.measureToolButton) {
        this.measureToolButton.removeEventListener(Autodesk.Viewing.UI.Button.Event.STATE_CHANGED, this.onMeasureButtonStateChange);
    }

    var toolset = this.app.ViewManager.getTopView('InspectorView').getToolSet();
    if (toolset) {
        if (this.measureToolButton) {
            toolset.removeControl(this.measureToolButton.getId());
        }
        this.measureToolButton = null;
    }

    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.escapeHotkeyId);
};

// get the data for the current state of the measuring tool. this data will be written
// into a URL that can later be shared.
Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.getState = function(viewerState) {
    var tool = this.tool;
    viewerState.measure = tool.getState();
};


Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Measure', Autodesk.Viewing.Extensions.Measure.MeasureExtension);
;AutodeskNamespace('Autodesk.Viewing.Extensions.Measure');

//
// /** @constructor */
//
//
Autodesk.Viewing.Extensions.Measure.MeasureTool = function( viewer, molMan, measureMan, options )
{
    var tool = this;

    var _viewer  = viewer;
    var _molMan = molMan;
    var _measureMan = measureMan;
    var _options = options;
    var _names  = ["measure"];
    var _active = false;

    var _firstClick = null;
    var _secondClick = null;
    var _isDragging = false;
    var _interacting = false;
    var _activePoint = 0;
    var _firstClickGeometry = null;
    var _secondClickGeometry = null;

    var _hideXYZ = true; // hide x, y, and z axes;
    var _units = "";
    var _precision = 3;
    var _distances = {};

    var _angle = 0;

    var _redraw = false;

    // UI.
    var _indicator = null;
    var _measurePanel = null;
    var _cursor = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAKZJREFUeNrclLEKwzAQQ9+FgH/Nk7d8ViFT+6cG36IsNXgIdMg5kAoOIw8WSDoDvAEN04BdEhFjgCTR4e6klFxSIgDLSNydbdsAPgRCktRaUylFkfZ0Z2qtVTlnAfugGibwAur3JFrAxoBnYGEy1pGYmQCLLNB6Uqmw182M9eRS0yzqGo+y6D9rytSQR8vM7DKfbtHy4x+/xG8J+d4W9WAi8fxFOwYA8W0ypu2ZfcsAAAAASUVORK5CYII=), wait";

    // Snapper
    var _snapper = null;
    var _firstIntersectPoint = null;
    var _secondIntersectPoint = null;
    var _firstFaceNormal = null;
    var _secondFaceNormal = null;

    // Isolate Measurement
    var _isolateMeasure = false;
    var _firstClickNode = null;
    var _secondClickNode = null;

    // Multiple Viewports For 2D
    var _firstViewportIndex = null;
    var _secondViewportIndex = null;

    var _hasUI = Autodesk.Viewing.Private.GuiViewer3D && viewer instanceof Autodesk.Viewing.Private.GuiViewer3D;

    this.activeLine = null;

    this.register = function()
    {
        if (!_snapper) {
            if(_viewer.toolController.getTool('snapper')) {
               _snapper = _viewer.toolController.getTool('snapper');
            } else {
                _snapper = new Autodesk.Viewing.Extensions.Measure.Snapper(_viewer, _molMan);
                _viewer.toolController.registerTool(_snapper);
            }
        }
    };

    this.deregister = function()
    {
        this.deactivate();
        if (_measurePanel) {
            _viewer.removePanel( _measurePanel );
            _measurePanel.uninitialize();
        }

        _viewer.toolController.deregisterTool(_snapper);
        _snapper = null;
    };

    this.isActive = function()
    {
        return _active;
    };

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.getCursor = function() {
        return (_isDragging && !_interacting) ? null : _cursor;
    };

    function onCameraChange() {
        _measureMan.updateLabelPositions();
    }

    function onExplodeChange(){
        ////tool.clearMeasurement();
    }

    function onReset() {
        tool.clearMeasurement();
    }

    this.activate = function()
    {
        _active = true;
        _activePoint = 0;
        _isDragging = false;

        if (!_units) {

            _units = _viewer.model.getUnitString();
        }

        if (_viewer.model && _viewer.model.is2d()) {
            _precision = 2;
        }
        else {
            _precision = 3;
        }

        activateUI();

        _viewer.clearSelection();
        _viewer.toolController.activateTool("snapper");
    };

    this.deactivate = function()
    {
        _active = false;
        _firstClick = _secondClick = null;
        _distances = {};

        this.clearMeasurement();

        deactivateUI();

        if(_snapper && _snapper.isActive()) {
            _viewer.toolController.deactivateTool("snapper");
        }

    };

    this.update = function()
    {
        return false;
    };

    this.getUnits = function() {
        return _units;
    };


    this.getPrecision = function() {
        return _precision;
    };

    this.getAngle = function() {

            return Autodesk.Viewing.Private.formatValueWithUnits(_angle, String.fromCharCode(0xb0), 3, _precision);
    };

    this.clearMeasurement = function() {
        _firstClick = _secondClick = null;
        _firstClickGeometry = _secondClickGeometry = null;
        _firstClickNode = _secondClickNode = null;
        _firstViewportIndex = _secondViewportIndex = null;
        _activePoint = 1;
        _distances = {};
        _angle = 0;

        if (_indicator) {
            _indicator.hide();
        }
        if (_measurePanel) {
            _measurePanel.updatePanel();
            _measurePanel.hideMeasureResult();

            if (_measurePanel.isolateMeasure) {
                this.clearIsolate();
            }
        }
    };

    this.clearRubberBand = function() {
        _secondClick = null;
        _secondClickGeometry = null;
        _indicator.hideClick('second');
    };

    this.clearFirstPick = function() {
        if (_secondClick) {
            _indicator.hide();

            _firstClick = _secondClick.clone();
            _firstClickGeometry = _secondClickGeometry;
            _firstIntersectPoint = _secondIntersectPoint;
            _firstFaceNormal = _secondFaceNormal;
            _firstClickNode = _secondClickNode;
            _firstViewportIndex = _secondIntersectPoint;

            // redraw the first pick
            _redraw = true;
            if (_firstClickGeometry === SNAP_VERTEX) {
                _measureMan.showFirstVertex(_firstClick);
            }
            else if (_firstClickGeometry === SNAP_EDGE) {
                _indicator.showFirstEdge(_firstClick, _firstIntersectPoint);
            }
            else {
                _indicator.showFirstFace(_firstClick, _firstIntersectPoint);
            }
            _redraw = false;

            _secondClick = null;
            _secondClickGeometry = null;
            _secondClickNode = null;
            _secondViewportIndex = null;
            _activePoint = 2;
            _distances = {};
            _angle = 0;

            if (_measurePanel && _measurePanel.isolateMeasure) {
                this.clearIsolate();
            }
        }
        else {
            this.clearMeasurement();
        }

        if (_measurePanel) _measurePanel.showSelection1();
    };

    this.clearSecondPick = function() {
        _secondClick = null;
        _secondClickGeometry = null;
        _secondClickNode = null;
        _secondViewportIndex = null;
        _activePoint = 2;
        _distances = {};
        _angle = 0;
        _indicator.hideClick('second');

        if (_measurePanel && _measurePanel.isolateMeasure) {
            this.clearIsolate();
        }
    };

    this.getIndicator = function () {
        return _indicator;
    };

    this.getFirstGeometry = function () {
        return {"type": _firstClickGeometry, "geometry": _firstClick};
    };

    this.getSecondGeometry = function () {
        return {"type": _secondClickGeometry, "geometry": _secondClick};
    };

    this.getEdgeLength = function (edge) {
        return _indicator.getEdgeLength(edge);
    };

    this.getFaceArea = function (face) {
        return _indicator.getFaceArea(face);
    };

    this.isolateMeasurement = function () {
        if (_firstClickNode && _secondClickNode) {
            var nodeList = [_firstClickNode, _secondClickNode];
            _viewer.isolate(nodeList);
        }
    };

    this.clearIsolate = function() {
        _viewer.showAll();
    };

    // get the current state data.
    this.getState = function() {
        var obj = {};
        obj.firstClick = _firstClick;
        obj.secondClick = _secondClick;
        return obj;
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    this._handleMouseEvent = function (event) {

        if(_snapper.isSnapped()) {  // ray cast has intersection with mesh
            if (_activePoint === 0) {
                ////this.clearMeasurement();
                _activePoint = 1;
            }

            if (_activePoint === 1) {  // First Pick

                _firstViewportIndex = _snapper.getViewportIndex();

                if (_snapper.getHighlightGeometry() === SNAP_VERTEX) {

                    _firstClick = _snapper.getVertex();
                    _firstClickGeometry = SNAP_VERTEX; // first click geometry is Vertex
                    _measureMan.showFirstVertex(_firstClick);
                }
                else if (_snapper.getHighlightGeometry() === SNAP_EDGE) {

                    _firstClick = _snapper.getEdge();
                    _firstClickGeometry = SNAP_EDGE; // first click geometry is Edge
                    _firstIntersectPoint = _snapper.getIntersectPoint();
                    _indicator.showFirstEdge(_firstClick, _firstIntersectPoint);
                }
                else {  // if (_snapper.getHighlightGeometry() === SNAP_FACE) {

                    _firstClick = _snapper.getFace();
                    _firstClickGeometry = SNAP_FACE; // first click geometry is Face
                    _firstIntersectPoint = _snapper.getIntersectPoint();
                    _firstFaceNormal = _snapper.getFaceNormal();
                    _indicator.showFirstFace(_firstClick, _firstIntersectPoint);
                }

                _firstClickNode = _snapper.getSnapNode();
                if (_measurePanel) _measurePanel.showSelection1();

            } else if (_activePoint === 2) { // Second Pick

                var result; // result = [endPoint, endPoint] or result = angle

                if (_firstClickGeometry === SNAP_VERTEX && _snapper.getHighlightGeometry() === SNAP_VERTEX) { // do vertex to vertex measure

                    _secondClick = _snapper.getVertex();
                    _secondClickGeometry = SNAP_VERTEX; // second click geometry is Vertex
                    _measureMan.showSecondVertex(_secondClick);

                    _measureMan.drawLine(_firstClick, _secondClick, _hideXYZ);

                    result = [_firstClick, _secondClick];

                }
                else if (_firstClickGeometry === SNAP_EDGE && _snapper.getHighlightGeometry() === SNAP_EDGE) { // do edge to edge measure

                    _secondClick = _snapper.getEdge();
                    _secondClickGeometry = SNAP_EDGE; // second click geometry is Edge
                    _secondIntersectPoint = _snapper.getIntersectPoint();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.edgeToEdgeMeasure(_secondClick, _firstClick, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_FACE && _snapper.getHighlightGeometry() === SNAP_FACE) { // do face to face measure

                    _secondClick = _snapper.getFace();
                    _secondClickGeometry = SNAP_FACE; // second click geometry is Face
                    _secondIntersectPoint = _snapper.getIntersectPoint();
                    _secondFaceNormal = _snapper.getFaceNormal();
                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.faceToFaceMeasure(_firstIntersectPoint, _firstFaceNormal, _secondIntersectPoint, _secondFaceNormal);

                }
                else if (_firstClickGeometry === SNAP_VERTEX && _snapper.getHighlightGeometry() === SNAP_EDGE) { // do vertex to edge measure

                    _secondClick = _snapper.getEdge();
                    _secondClickGeometry = SNAP_EDGE; // second click geometry is Edge
                    _secondIntersectPoint = _snapper.getIntersectPoint();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.pointToEdgeMeasure(_firstClick, _secondClick, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_EDGE && _snapper.getHighlightGeometry() === SNAP_VERTEX) { // do edge to vertex measure

                    _secondClick = _snapper.getVertex();
                    _secondClickGeometry = SNAP_VERTEX; // second click geometry is Vertex
                    _measureMan.showSecondVertex(_secondClick);

                    result = _indicator.edgeToPointMeasure(_firstClick, _secondClick);

                }
                else if (_firstClickGeometry === SNAP_VERTEX && _snapper.getHighlightGeometry() === SNAP_FACE) { // do vertex to face measure

                    _secondClick = _snapper.getFace();
                    _secondClickGeometry = SNAP_FACE; // second click geometry is Face
                    _secondFaceNormal = _snapper.getFaceNormal();
                    _secondIntersectPoint = _snapper.getIntersectPoint();
                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.pointToFaceMeasure(_firstClick, _secondClick, _secondFaceNormal, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_FACE && _snapper.getHighlightGeometry() === SNAP_VERTEX) { // do face to vertex measure

                    _secondClick = _snapper.getVertex();
                    _secondClickGeometry = SNAP_VERTEX; // second click geometry is Vertex
                    _measureMan.showSecondVertex(_secondClick);

                    result = _indicator.faceToPointMeasure(_firstClick, _firstFaceNormal, _firstIntersectPoint, _secondClick);

                }
                else if (_firstClickGeometry === SNAP_EDGE && _snapper.getHighlightGeometry() === SNAP_FACE) { // do edge to face measure

                    _secondClick = _snapper.getFace();
                    _secondClickGeometry = SNAP_FACE; // second click geometry is Face
                    _secondFaceNormal = _snapper.getFaceNormal();
                    _secondIntersectPoint = _snapper.getIntersectPoint();
                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.edgeToFaceMeasure(_firstClick, _firstIntersectPoint, _secondClick, _secondFaceNormal, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_FACE && _snapper.getHighlightGeometry() === SNAP_EDGE) { // do face to edge measure

                    _secondClick = _snapper.getEdge();
                    _secondClickGeometry = SNAP_EDGE; // second click geometry is Edge
                    _secondIntersectPoint = _snapper.getIntersectPoint();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.faceToEdgeMeasure(_firstClick, _firstFaceNormal, _firstIntersectPoint, _secondClick, _secondIntersectPoint);

                }

                if (_measureMan.getConsumeSingleClick()) {

                    if (result.length === undefined) {

                        _angle = result;

                        if (_measurePanel) _measurePanel.showAngleResult();
                    }
                    else {

                        var ep1 = result[0].clone();
                        var ep2 = result[1].clone();

                        if (_viewer.model.is2d()) {
                            _viewer.model.pageToModel(ep1, _firstViewportIndex);
                            _viewer.model.pageToModel(ep2, _firstViewportIndex);
                        }

                        _distances.xyz = ep1.distanceTo(ep2);
                        _distances.x = Math.abs(ep1.x - ep2.x);
                        _distances.y = Math.abs(ep1.y - ep2.y);
                        _distances.z = Math.abs(ep1.z - ep2.z);

                        if (_measurePanel) _measurePanel.showDistanceResult();
                    }

                    if (_measurePanel) {
                        _measurePanel.showSelection2();
                        _measurePanel.updatePanel();
                    }
                    _measureMan.updateDistance(_measureMan.getMeasurementByEndpoints(ep1,ep2));
                    _indicator.updateAngle();

                    _secondClickNode = _snapper.getSnapNode();
                    _secondViewportIndex = _snapper.getViewportIndex();

                    if (_measurePanel && _measurePanel.isolateMeasure) {
                        this.isolateMeasurement();
                    }
                }

                _measureMan.updateLabelPositions();

            }
            return true;
        }
        else {  // show "rubber band" even when user is NOT over any 2nd pick geometry
            if (_activePoint === 2) {
                var result; // result = [endPoint, endPoint] or result = angle

                if (_firstClickGeometry === SNAP_VERTEX) { // do vertex to vertex measure

                    _secondClick = this.inverseProject(event.canvasX, event.canvasY);
                    _secondClickGeometry = SNAP_VERTEX; // second click geometry is Vertex

                    _measureMan.drawLine(_firstClick, _secondClick, _hideXYZ);

                    result = [_firstClick, _secondClick];

                }
                else if (_firstClickGeometry === SNAP_EDGE) { // do edge to vertex measure

                    _secondClick = this.inverseProject(event.canvasX, event.canvasY);
                    _secondClickGeometry = SNAP_VERTEX; // second click geometry is Vertex

                    result = _indicator.edgeToPointMeasure(_firstClick, _secondClick);

                }
                else if (_firstClickGeometry === SNAP_FACE) { // do face to vertex measure

                    _secondClick = this.inverseProject(event.canvasX, event.canvasY);
                    _secondClickGeometry = SNAP_VERTEX; // second click geometry is Vertex

                    result = _indicator.faceToPointMeasure(_firstClick, _firstFaceNormal, _firstIntersectPoint, _secondClick);

                }
            }
        }
        return false;
    };

    this.inverseProject = function (canvasX, canvasY) {

        var camera = _viewer.navigation.getCamera(),
            containerBounds = _viewer.navigation.getScreenViewport(),
            p = new THREE.Vector3();

        p.x = canvasX / containerBounds.width * 2 - 1;
        p.y = -(canvasY / containerBounds.height * 2 - 1);
        p.z = 0;

        p = p.unproject(camera);

        return p;
    };

    this.handleButtonDown = function (event, button) {
        _isDragging = true;
        if (button === 0 && !event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {

            _measureMan.setConsumeSingleClick(true);
        }
        return false;
    };

    this.handleMouseMove = function (event) {
        _measureMan.setConsumeSingleClick(false);
        if(_activePoint === 2) {
            this.clearRubberBand();
            this._handleMouseEvent(event);
        }
        return false;
    };

    this.handleButtonUp = function (event, button) {
        _isDragging = false;
        return false;
    };

    this.handleSingleClick = function (event, button) {
        if (_measureMan.getConsumeSingleClick()) {

            if (!this._handleMouseEvent(event)) {
                this.clearMeasurement();
                _activePoint = 0;
            }

            if (_activePoint === 1 || _activePoint === 2) {
                _activePoint = (_activePoint === 1) ? 2 : 0;
            }

            _measureMan.setConsumeSingleClick(false);
        }
        return true;
    };

    this.handleDoubleClick = function( event, button ) {
        return true;
    };

    this.handleWheelInput = function (delta) {
        _measureMan.updateScale();
        return false;
    };

    // Create UI and initially hide it.
    function activateUI( )
    {
        var container = _viewer.container;
        var measurements = _measureMan.getMeasurements();
        var i;
        var labels = container.querySelectorAll('.measure-length');
        if (!_indicator) {
            _indicator = new Indicator( _viewer );
        }
        _indicator.hide();

        if (_measurePanel) {
            _measurePanel.setVisible(true);
            _measurePanel.updatePanel();

            if (_viewer.model && _viewer.model.is2d()) {
                _measurePanel.isolate.setDisabled(true);
            }

            if (!_units) {
                _measurePanel.disableUnitOption();
            }
            else {
                _measurePanel.disableUnitOption(0);  // disable "Unknown" option when the model has units
            }
        }

        for (i = 0; i < labels.length; ++i) {
            labels[i].classList.remove('inactive');
        }

    }

    function deactivateUI()
    {
        var container = _viewer.container;
        var measurements = _measureMan.getMeasurements();
        var i;
        var label;

        if (_indicator) {
            _indicator.hide();
            _indicator.destroy();
        }

        _distances = {};

        if (_measurePanel) {
            _measurePanel.setVisible(false);
            _measurePanel.updatePanel();
        }

        for (i = 0; i < measurements.length; ++i) {
            label = container.querySelector('#label-'+measurements[i].id);
            if (label) {
                label.classList.add('inactive');
            }
        }
    }

    // /** @constructor */
    function Indicator( viewer )
    {
        var that = this,
            _simple = false,
            kIndicatorColor = 0x1E8FFF,
            kLineEndColor = 0xFF9900,
            kIndicatorOpacity = 0.7,
            kLineEndOpacity = 1.0,
            kEndPointOverlayName = 'MeasureTool-endPoint',
            kEdgeOverlayName = 'MeasureTool-edge',
            kFaceOverlayName = 'MeasureTool-face',
            kAngleOverlayName = 'MeasureTool-angle',
            kAngleOutlineOverlayName = 'MeasureTool-angle-outline',
            kExtensionLineOverlayName = 'MeasureTool-extensionLine',
            kExtensionFaceOverlayName = 'MeasureTool-extensionFace',
            _materialPoint = null,
            _materialLine = null,
            _materialFace = null,
            _materialAngle = null,
            _materialAngleOutline = null,
            _materialExtensionLine = null,
            _materialExtensionFace = null,
            _endPoints = {first: {}, second: {}},
            _edges = {first: {}, second: {}},
            _faces = {first: {}, second: {}},
            _lines = {
                xyz: {axis: false, color: 'FF9900'},
                x:   {axis: true,  color: 'F12C2C'},
                y:   {axis: true,  color: '0BB80B'},
                z:   {axis: true,  color: '2C2CF1'}
            },
            _angleLabel = {},
            _labels = [],
            kHudOffset = 4; // pixels

        this.showFirstEdge = function(geom, point)
        {
            this.showEdge('first', geom, point);
        };

        this.showSecondEdge = function(geom, point)
        {
            this.showEdge('second', geom, point);
        };

        this.showEdge = function(name, geom, point) {

            if (!_materialLine) {

                _materialLine = new THREE.LineBasicMaterial({
                    color: kIndicatorColor,
                    opacity: kIndicatorOpacity,
                    linewidth: 5,
                    depthTest: false,
                    depthWrite: false
                });

                _viewer.impl.createOverlayScene(kEdgeOverlayName);
            }

            var edge = _edges[name];

            if (edge.line) {
                _viewer.impl.removeOverlay(kEdgeOverlayName, edge.line);
            }

            edge.line = new THREE.Line(geom, _materialLine, THREE.LinePieces);
            _viewer.impl.addOverlay(kEdgeOverlayName, edge.line);

            if (_measureMan.getConsumeSingleClick() || _redraw) {

                var label = edge.label;
                if (!label) {

                    label = edge.label = document.createElement('div');
                    label.className = 'measure-label';
                    _viewer.container.appendChild(label);

                    // Stop showing length of edges per Jay's request
                    //var label_text = document.createElement('div');
                    //label_text.className = 'measure-label-text';
                    //label.appendChild(label_text);
                    var label_icon = document.createElement('div');
                    label_icon.className = 'adsk-icon-' + name + ' measure-label-icon';
                    label.appendChild(label_icon);
                }

                //label.children[0].textContent = this.getEdgeLength(geom);
                label.classList.toggle('visible', true);

                edge.intersectPoint = point.clone();

                this.updateLabelPositions();
            }
        };

        this.showFirstFace = function(geom, point) {

            this.showFace('first', geom, point);
        };

        this.showSecondFace = function(geom, point) {

            this.showFace('second', geom, point);
        };

        this.showFace = function(name, geom, point) {

            if (!_materialFace) {
                _materialFace = new THREE.MeshPhongMaterial({
                        color: kIndicatorColor,
                        ambient: kIndicatorColor,
                        opacity: kIndicatorOpacity,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    }
                );

                _viewer.impl.createOverlayScene(kFaceOverlayName);
            }

            var face = _faces[name];

            if (face.mesh) {
                _viewer.impl.removeOverlay(kFaceOverlayName, face.mesh);
            }

            face.mesh = new THREE.Mesh(geom, _materialFace);
            _viewer.impl.addOverlay(kFaceOverlayName, face.mesh);

            if (_measureMan.getConsumeSingleClick() || _redraw) {

                var label = face.label;
                if (!label) {

                    label = face.label = document.createElement('div');
                    label.className = 'measure-label';
                    _viewer.container.appendChild(label);

                    // Stop showing area of faces per Jay's request
                    //var label_text = document.createElement('div');
                    //label_text.className = 'measure-label-text';
                    //label.appendChild(label_text);
                    var label_icon = document.createElement('div');
                    label_icon.className = 'adsk-icon-' + name + ' measure-label-icon';
                    label.appendChild(label_icon);
                }

                //label.children[0].textContent = this.getFaceArea(geom);
                label.classList.toggle('visible', true);

                face.intersectPoint = point.clone();

                this.updateLabelPositions();
            }
        };

        this.drawExtensionFace = function(geom, intersectPoint, normal) {

            if (!_materialExtensionFace) {
                _materialExtensionFace = new THREE.MeshPhongMaterial({
                        color: 0x66CCFF,
                        ambient: 0x00CCFF,
                        opacity: 0.2,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    }
                );

                _viewer.impl.createOverlayScene(kExtensionFaceOverlayName);
            }

            var face = new THREE.Mesh(geom, _materialExtensionFace);

            face.position.set(intersectPoint.x, intersectPoint.y, intersectPoint.z);
            var V = face.position.clone();
            V.add(normal);
            face.lookAt(V);
            face.updateMatrixWorld();

            _viewer.impl.addOverlay(kExtensionFaceOverlayName, face);
        };

        this.getEdgeLength = function(edge) {

            var length = 0;
            var eg = edge.clone();
            var vertices = eg.vertices;
            for (var i = 0; i < vertices.length; i += 2) {

                if (_viewer.model.is2d()) {
                    _viewer.model.pageToModel(vertices[i], _firstViewportIndex);
                    _viewer.model.pageToModel(vertices[i + 1], _firstViewportIndex);
                }

                length += vertices[i].distanceTo(vertices[i + 1]);
            }

            length = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _units, length);

            return Autodesk.Viewing.Private.formatValueWithUnits(length, _units, 3, _precision);
        };

        this.getFaceArea = function(face) {

            var area = 0;
            var vertices = face.vertices;
            var V1 = new THREE.Vector3();
            var V2 = new THREE.Vector3();

            for (var i = 0; i < vertices.length; i += 3) {

                V1.subVectors(vertices[i + 1], vertices[i]);
                V2.subVectors(vertices[i + 2], vertices[i]);

                area += V1.length() * V2.length() * Math.sin(V1.angleTo(V2)) / 2;
            }

            area = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _units, area, 'square');

            if (_units) {

                return Autodesk.Viewing.Private.formatValueWithUnits(area, _units+'^2', 3, _precision);
            }
            else {

                return Autodesk.Viewing.Private.formatValueWithUnits(area, null, 3, _precision);
            }

        };

        this.updateLabels = function() {

            if (_firstClickGeometry === SNAP_EDGE) { // edge

                _edges['first'].label.children[0].textContent = this.getEdgeLength(_firstClick);
            }
            else if (_firstClickGeometry === SNAP_FACE) { // face

                _faces['first'].label.children[0].textContent = this.getFaceArea(_firstClick);
            }

            if (_secondClickGeometry === SNAP_EDGE) { // edge

                _edges['second'].label.children[0].textContent = this.getEdgeLength(_secondClick);
            }
            else if (_secondClickGeometry === SNAP_FACE) { // face

                _faces['second'].label.children[0].textContent = this.getFaceArea(_secondClick);
            }

        };

        // Update angle measurement label
        this.updateAngle = function() {
            var label = _angleLabel.label;
            if (label) {
                label.children[0].textContent = tool.getAngle();
            }
        };

        this.drawExtensionLine = function(point, lineStart, lineEnd) {

            var p1, p2;
            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();
            var nearestPoint;
            var param;

            X0.subVectors(lineStart, point);
            X1.subVectors(lineEnd, lineStart);
            param = X0.dot(X1);
            X0.subVectors(lineEnd, lineStart);
            param = -param / X0.dot(X0);

            X0.subVectors(lineEnd, lineStart);
            X0.multiplyScalar(param);
            nearestPoint = X0.add(lineStart);


            if (param < 0) {
                p1 = lineStart;
                p2 = nearestPoint;
            }
            else if (param > 1) {
                p1 = lineEnd;
                p2 = nearestPoint;
            }
            else {
                return;
            }

            if (!_materialExtensionLine) {

                _materialExtensionLine = new THREE.LineDashedMaterial({
                    color: 0x0033FF,
                    linewidth: 1,
                    dashSize: 1,
                    gapSize: 0.5,
                    depthTest: false,
                    depthWrite: false
                });

                _viewer.impl.createOverlayScene(kExtensionLineOverlayName);
            }

            // make the rubber band 50% transparent.
            if (_measureMan.getConsumeSingleClick()) {
                _materialExtensionLine.opacity = 1;
            }
            else {
                _materialExtensionLine.opacity = kIndicatorOpacity;
            }

            var dashScale = this.setScale(p1);
            _materialExtensionLine.dashSize = dashScale * 4;
            _materialExtensionLine.gapSize = dashScale * 2;

            var geometry = new THREE.Geometry();
            geometry.vertices.push(p1);
            geometry.vertices.push(p2);

            geometry.computeLineDistances();

            var line = new THREE.Line(geometry, _materialExtensionLine);
            _viewer.impl.addOverlay(kExtensionLineOverlayName, line);
        };

        this.drawExtensionLinePointToPoint = function(lineStart, lineEnd) {

            var p1 = lineStart;
            var p2 = lineEnd;

            if (!_materialExtensionLine) {

                _materialExtensionLine = new THREE.LineDashedMaterial({
                    color: 0x0033FF,
                    linewidth: 1,
                    dashSize: 1,
                    gapSize: 0.5,
                    depthTest: false,
                    depthWrite: false
                });

                _viewer.impl.createOverlayScene(kExtensionLineOverlayName);
            }

            // make the rubber band 50% transparent.
            if (_measureMan.getConsumeSingleClick()) {
                _materialExtensionLine.opacity = 1;
            }
            else {
                _materialExtensionLine.opacity = kIndicatorOpacity;
            }

            var dashScale = this.setScale(p1);
            _materialExtensionLine.dashSize = dashScale * 4;
            _materialExtensionLine.gapSize = dashScale * 2;

            var geometry = new THREE.Geometry();
            geometry.vertices.push(p1);
            geometry.vertices.push(p2);

            geometry.computeLineDistances();

            var line = new THREE.Line(geometry, _materialExtensionLine);
            _viewer.impl.addOverlay(kExtensionLineOverlayName, line);
        };

        // Get the two nearest endpoints between two line segments
        this.nearestPointsInSegmentToSegment = function (p1, p2, p3, p4) {

            var smallNum = 0.001;
            var u = new THREE.Vector3();
            var v = new THREE.Vector3();
            var w = new THREE.Vector3();

            u.subVectors(p2, p1);
            v.subVectors(p4, p3);
            w.subVectors(p1, p3);

            var a = u.dot(u);
            var b = u.dot(v);
            var c = v.dot(v);
            var d = u.dot(w);
            var e = v.dot(w);
            var D = a * c - b * b;
            var sc, sN, sD = D;
            var tc, tN, tD = D;

            // Compute the line parameters of the two closest points
            if (D < smallNum) { // the lines are almost parallel
                sN = 0.0;  // for using point p1 on segment p1p2
                sD = 1.0;  // to prevent possible division by 0.0 later
                tN = e;
                tD = c;
            }
            else {  // get the closest points on the infinite lines
                sN = b * e - c * d;
                tN = a * e - b * d;
                if (sN < 0.0) {  // sc < 0 => the s = 0 is visible
                    sN = 0.0;
                    tN = e;
                    tD = c;
                }
                else if (sN > sD) {  // sc > 1 => the s = 1 edge is visible
                    sN = sD;
                    tN = e + b;
                    tD = c;
                }
            }

            if (tN < 0.0) {  // tc < 0 => the t = 0 edge is visible
                tN = 0.0;
                // recompute sc for this edge
                if (-d < 0.0)
                    sN = 0.0;
                else if (-d > a)
                    sN = sD;
                else {
                    sN = -d;
                    sD = a;
                }
            }
            else if (tN > tD) {  // tc > 1 => the t = 1 edge is visible
                tN = tD;
                // recompute sc for this edge
                if ((-d + b) < 0.0)
                    sN = 0;
                else if ((-d + b) > a)
                    sN = sD;
                else {
                    sN = -d + b;
                    sD = a;
                }
            }

            // finally do the division to get sc and tc
            sc = Math.abs(sN) < smallNum ? 0.0 : sN / sD;
            tc = Math.abs(tN) < smallNum ? 0.0 : tN / tD;

            // get the difference of the two closest points
            u.multiplyScalar(sc);
            v.multiplyScalar(tc);
            w.add(u);
            w.sub(v);

            //return w.length();

            u.add(p1);
            v.add(p3);
            return [u, v];
        };

        // Measure from Edge to Edge
        this.edgeToEdgeMeasure = function(edge1, edge2, intersectPoint) {

            var smallNum = 0.01;

            var eps = _snapper.getEndPointsInEdge(edge1);
            var p1 = eps[0].clone();
            var p2 = eps[1].clone();
            eps = _snapper.getEndPointsInEdge(edge2);
            var p3 = eps[0].clone();
            var p4 = eps[1].clone();

            var va = this.nearestPointInPointToLine(p1, p3, p4);
            var vb = this.nearestPointInPointToLine(p2, p3, p4);

            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();
            var angle;

            // Find the nearest point on the edge to the intersectPoint, make this point as the new endpoint of the edge,
            // because we don't want to draw the arc so big, this is consistent with Fusion
            var newEp = this.nearestPointInPointToLine(intersectPoint, p1, p2);

            // Find the nearest endpoints of the two edges
            // Draw arc between p1p2 and p3p4
            if (p1.distanceTo(p3) < p1.distanceTo(p4) && p1.distanceTo(p3) < p2.distanceTo(p3) && p1.distanceTo(p3) < p2.distanceTo(p4)) {

                v1.subVectors(p1, p2);
                v2.subVectors(p3, p4);
                v1.normalize();
                v2.normalize();

                if (this.isEqualVectors(v1, v2, smallNum) || this.isInverseVectors(v1, v2, smallNum)) {

                    this.drawLine(p1, va, _hideXYZ);
                    this.drawExtensionLine(p1, p3, p4);
                    return [p1, va];
                }
                else {

                    angle = this.angleVectorToVector(v1, v2);
                    this.drawAngleLineToLine(p1, newEp, p3, p4, angle);
                    return angle;
                }
            }
            // Draw arc between p1p2 and p4p3
            else if (p1.distanceTo(p4) < p1.distanceTo(p3) && p1.distanceTo(p4) < p2.distanceTo(p3) && p1.distanceTo(p4) < p2.distanceTo(p4)) {

                v1.subVectors(p1, p2);
                v2.subVectors(p4, p3);
                v1.normalize();
                v2.normalize();

                if (this.isEqualVectors(v1, v2, smallNum) || this.isInverseVectors(v1, v2, smallNum)) {

                    this.drawLine(p1, va, _hideXYZ);
                    this.drawExtensionLine(p1, p3, p4);
                    return [p1, va];
                }
                else {

                    angle = this.angleVectorToVector(v1, v2);
                    this.drawAngleLineToLine(p1, newEp, p4, p3, angle);
                    return angle;
                }
            }
            // Draw arc between p2p1 and p3p4
            else if (p2.distanceTo(p3) < p1.distanceTo(p3) && p2.distanceTo(p3) < p1.distanceTo(p4) && p2.distanceTo(p3) < p2.distanceTo(p4)) {

                v1.subVectors(p2, p1);
                v2.subVectors(p3, p4);
                v1.normalize();
                v2.normalize();

                if (this.isEqualVectors(v1, v2, smallNum) || this.isInverseVectors(v1, v2, smallNum)) {

                    this.drawLine(p2, vb, _hideXYZ);
                    this.drawExtensionLine(p2, p3, p4);
                    return [p2, vb];
                }
                else {

                    angle = this.angleVectorToVector(v1, v2);
                    this.drawAngleLineToLine(p2, newEp, p3, p4, angle);
                    return angle;
                }
            }
            // Draw arc between p2p1 and p4p3
            else {  // if (p2.distanceTo(p4) < p1.distanceTo(p3) && p2.distanceTo(p4) < p1.distanceTo(p4) && p2.distanceTo(p4) < p2.distanceTo(p3)) {

                v1.subVectors(p2, p1);
                v2.subVectors(p4, p3);
                v1.normalize();
                v2.normalize();

                if (this.isEqualVectors(v1, v2, smallNum) || this.isInverseVectors(v1, v2, smallNum)) {

                    this.drawLine(p2, vb, _hideXYZ);
                    this.drawExtensionLine(p2, p3, p4);
                    return [p2, vb];
                }
                else {

                    angle = this.angleVectorToVector(v1, v2);
                    this.drawAngleLineToLine(p2, newEp, p4, p3, angle);
                    return angle;
                }
            }

        };

        // Get the nearest point on the line segment from point to line segment
        this.nearestPointInPointToSegment = function (point, lineStart, lineEnd) {

            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();
            var nearestPoint;
            var param;

            X0.subVectors(lineStart, point);
            X1.subVectors(lineEnd, lineStart);
            param = X0.dot(X1);
            X0.subVectors(lineEnd, lineStart);
            param = -param / X0.dot(X0);

            if (param < 0) {
                nearestPoint = lineStart;
            }
            else if (param > 1) {
                nearestPoint = lineEnd;
            }
            else {
                X0.subVectors(lineEnd, lineStart);
                X0.multiplyScalar(param);
                nearestPoint = X0.add(lineStart);
            }

            return nearestPoint;
        };

        // Get the nearest point on the line from point to line
        this.nearestPointInPointToLine = function(point, lineStart, lineEnd) {

            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();
            var nearestPoint;
            var param;

            X0.subVectors(lineStart, point);
            X1.subVectors(lineEnd, lineStart);
            param = X0.dot(X1);
            X0.subVectors(lineEnd, lineStart);
            param = -param / X0.dot(X0);

            X0.subVectors(lineEnd, lineStart);
            X0.multiplyScalar(param);
            nearestPoint = X0.add(lineStart);

            return nearestPoint;
        };

        // Measure from Point to Edge
        this.pointToEdgeMeasure = function(point, edge, intersectPoint) {

            var eps = _snapper.getEndPointsInEdge(edge);

            var lineStart = eps[0];
            var lineEnd = eps[1];

            var X0 = this.nearestPointInPointToLine(point, lineStart, lineEnd);
            var X1 = this.nearestPointInPointToLine(intersectPoint, lineStart, lineEnd);

            var p1 = new THREE.Vector3();
            p1.subVectors(X1, X0);
            p1.add(point);

            this.drawLine(p1, X1, _hideXYZ);

            this.drawExtensionLinePointToPoint(point, p1);

            return [point, X0];
        };

        // Measure from Edge to Point
        this.edgeToPointMeasure = function(edge, point) {

            var eps = _snapper.getEndPointsInEdge(edge);

            var lineStart = eps[0];
            var lineEnd = eps[1];

            var X0 = this.nearestPointInPointToLine(point, lineStart, lineEnd);

            this.drawLine(point, X0, _hideXYZ);

            this.drawExtensionLine(point, lineStart, lineEnd);

            return [point, X0];
        };

        // Measure from Face to Face
        this.faceToFaceMeasure = function(p1, n1, p2, n2) {

            var smallNum = 0.01;
            var firstNormal = n1.clone();
            var secondNormal = n2.clone();

            var angle = this.angleVectorToVector(n1, n2);

            if (((firstNormal.x <= secondNormal.x + smallNum) && (firstNormal.x >= secondNormal.x - smallNum)
                && (firstNormal.y <= secondNormal.y + smallNum) && (firstNormal.y >= secondNormal.y - smallNum)
                && (firstNormal.z <= secondNormal.z + smallNum) && (firstNormal.z >= secondNormal.z - smallNum))
                || ((firstNormal.x <= -secondNormal.x + smallNum) && (firstNormal.x >= -secondNormal.x - smallNum)
                && (firstNormal.y <= -secondNormal.y + smallNum) && (firstNormal.y >= -secondNormal.y - smallNum)
                && (firstNormal.z <= -secondNormal.z + smallNum) && (firstNormal.z >= -secondNormal.z - smallNum)))
            {
                var X0 = new THREE.Vector3();
                X0.subVectors(p1, p2);
                var t = firstNormal.dot(X0) / firstNormal.dot(secondNormal);

                X0.addVectors(p2, secondNormal.multiplyScalar(t));

                //var dist = new THREE.Vector3();
                //dist.subVectors(X0, p1);
                //var extendFace = _faces['first'].mesh.geometry.clone();
                //extendFace.applyMatrix(new THREE.Matrix4().makeTranslation(dist.x, dist.y, dist.z));

                var dist = X0.distanceTo(p1) * 2;
                var extendFace = new THREE.PlaneBufferGeometry(dist, dist);
                this.drawExtensionFace(extendFace, p1, n1);
                //this.drawExtensionLinePointToPoint(p1, X0);

                this.drawLine(p2, X0, _hideXYZ);
                return [p2, X0, angle];
            }
            else {

                //this.drawLine(p1, p2);
                //return [p1, p2, angle];

                angle = this.drawAngleFaceToFace(p1, n1, p2, n2);
                return angle;
            }
        };

        this.angleVectorToVector = function(v1, v2) {

            var a = v1.angleTo(v2) * 180 / Math.PI;
            return a;
        };

        // Find the intersection of two nonparallel planes
        this.intersectPlaneToPlane = function(p1, n1, p2, n2) {

            var u = new THREE.Vector3();
            u.crossVectors(n1, n2);
            var ax = (u.x >= 0 ? u.x : -u.x);
            var ay = (u.y >= 0 ? u.y : -u.y);
            var az = (u.z >= 0 ? u.z : -u.z);

            var maxc;  // max coordinate
            if (ax > ay) {
                if (ax > az)
                    maxc = 1;
                else
                    maxc = 3;
            }
            else {
                if (ay > az)
                    maxc = 2;
                else maxc = 3;
            }

            var iP = new THREE.Vector3(); // intersect point
            var d1, d2;
            d1 = -n1.dot(p1);
            d2 = -n2.dot(p2);

            switch (maxc) {

                case 1:  // intersect with x = 0
                    iP.x = 0;
                    if (u.x !== 0) {
                        iP.y = (d2 * n1.z - d1 * n2.z) / u.x;
                        iP.z = (d1 * n2.y - d2 * n1.y) / u.x;
                    }
                    else {
                        iP.y = - (d2 * n1.z) / (n1.z * n2.y);
                        iP.z = - (d1 * n2.y) / (n1.z * n2.y);
                    }
                    break;
                case 2:
                    iP.y = 0;
                    if (u.y !== 0) {
                        iP.x = (d1 * n2.z - d2 * n1.z) / u.y;
                        iP.z = (d2 * n1.x - d1 * n2.x) / u.y;
                    }
                    else {
                        iP.x = - (d1 * n2.z) / (n1.x * n2.z);
                        iP.z = - (d2 * n1.x) / (n1.x * n2.z);
                    }
                    break;
                case 3:
                    iP.z = 0;
                    if (u.z !== 0) {
                        iP.x = (d2 * n1.y - d1 * n2.y) / u.z;
                        iP.y = (d1 * n2.x - d2 * n1.x) / u.z;
                    }
                    else {
                        iP.x = - (d2 * n1.y) / (n1.y * n2.x);
                        iP.y = - (d1 * n2.x) / (n1.y * n2.x);
                    }
                    break;
            }

            var iP2 = new THREE.Vector3();
            iP2.addVectors(iP, u.multiplyScalar(100));

            var vP1 = this.nearestPointInPointToLine(p1, iP, iP2);
            var vP2 = this.nearestPointInPointToLine(p2, iP, iP2);

            return [vP1, vP2];

        };

        this.drawAngle = function (p, ep1, ep2, n, angle, midPoint) {

            var smallNum = 0.001;

            if (!_materialAngle) {

                _materialAngle = new THREE.MeshPhongMaterial({
                        color: 0x999999,
                        ambient: 0x999999,
                        opacity: 0.5,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    }
                );

                _materialAngleOutline = new THREE.LineBasicMaterial({
                    color: 0xFF9900,
                    opacity: 1,
                    linewidth: 5,
                    depthTest: false
                });

                _viewer.impl.createOverlayScene(kAngleOverlayName, _materialAngle);
                _viewer.impl.createOverlayScene(kAngleOutlineOverlayName, _materialAngleOutline);
            }

            _viewer.impl.clearOverlay(kAngleOverlayName);
            _viewer.impl.clearOverlay(kAngleOutlineOverlayName);


            // draw arc of angle
            var radius = p.distanceTo(ep1);
            var segments = 100;
            //angle = angle * Math.PI / 180;

            var circleGeometry = new THREE.CircleGeometry(radius, segments, 0, angle * Math.PI / 180);
            var arc = new THREE.Mesh(circleGeometry, _materialAngle);

            var center = arc.geometry.vertices[0].clone();
            arc.geometry.vertices.push(center);


            // Translate and rotate the arc to the plane where it should lie in
            arc.position.set(p.x, p.y, p.z);
            var V = arc.position.clone();
            V.add(n);
            arc.lookAt(V);
            arc.updateMatrixWorld();


            // Rotate the arc in the plane to the right place
            var vA = arc.geometry.vertices[1].clone();
            var vB = arc.geometry.vertices[arc.geometry.vertices.length - 2].clone();
            vA.applyMatrix4(arc.matrixWorld);
            vB.applyMatrix4(arc.matrixWorld);

            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();
            var v3 = new THREE.Vector3();
            var v4 = new THREE.Vector3();
            v1.subVectors(vA, p);
            v2.subVectors(vB, p);
            v3.subVectors(ep1, p);
            v4.subVectors(ep2, p);

            var a13 = v1.angleTo(v3);
            var a14 = v1.angleTo(v4);
            var a23 = v2.angleTo(v3);
            var a24 = v2.angleTo(v4);

            //console.log(a13 * 180 / Math.PI + " " + a14 * 180 / Math.PI + " " + a23 * 180 / Math.PI + " " + a24 * 180 / Math.PI);

            var ra;
            // The arc is in the right place
            if (((a13 <= smallNum && a13 >= -smallNum) || (a14 <= smallNum && a14 >= -smallNum))
                && ((a23 <= smallNum && a23 >= -smallNum) || (a24 <= smallNum && a24 >= -smallNum))) {

                ra =0;
            }
            // The arc needs to be rotated 180 degree to the right place
            else if (((a13 <= Math.PI + smallNum && a13 >= Math.PI - smallNum) || (a14 <= Math.PI + smallNum && a14 >= Math.PI - smallNum))
                && ((a23 <= Math.PI + smallNum && a23 >= Math.PI - smallNum) || (a24 <= Math.PI + smallNum && a24 >= Math.PI - smallNum))) {

                ra = Math.PI;
            }
            // The arc needs to be rotated a13 radian
            else if ((a13 <= a23 + smallNum && a13 >= a23 - smallNum) || (a13 <= a24 + smallNum && a13 >= a24 - smallNum)) {

                ra = a13;
            }
            // The arc needs to be rotated a14 radian
            else {

                ra = a14;
            }

            var rotWorldMatrix = new THREE.Matrix4();
            rotWorldMatrix.makeRotationAxis(n, ra);
            //arc.matrix.multiply(rotWorldMatrix);
            rotWorldMatrix.multiply(arc.matrix);
            arc.matrix = rotWorldMatrix;
            arc.rotation.setFromRotationMatrix(arc.matrix);

            // Check if rotate to the wrong direction, if so, rotate back twice of the degree
            arc.updateMatrixWorld();
            vA = arc.geometry.vertices[1].clone();
            vB = arc.geometry.vertices[arc.geometry.vertices.length - 2].clone();
            vA.applyMatrix4(arc.matrixWorld);
            vB.applyMatrix4(arc.matrixWorld);

            v1.subVectors(vA, p);
            v2.subVectors(vB, p);

            a13 = v1.angleTo(v3);
            a14 = v1.angleTo(v4);
            a23 = v2.angleTo(v3);
            a24 = v2.angleTo(v4);

            //console.log(a13 * 180 / Math.PI + " " + a14 * 180 / Math.PI + " " + a23 * 180 / Math.PI + " " + a24 * 180 / Math.PI);

            if (a13 >= smallNum && a14 >= smallNum) {

                var rotWorldMatrix = new THREE.Matrix4();
                rotWorldMatrix.makeRotationAxis(n, - ra * 2);
                //arc.matrix.multiply(rotWorldMatrix);
                rotWorldMatrix.multiply(arc.matrix);
                arc.matrix = rotWorldMatrix;
                arc.rotation.setFromRotationMatrix(arc.matrix);
            }

            // draw outline of the arc
            var outlineGeometry = new THREE.CircleGeometry(radius * 0.9, segments, 0, angle * Math.PI / 180);
            var outline = new THREE.Line(outlineGeometry, _materialAngleOutline);
            outline.geometry.vertices.splice(0, 1);

            arc.updateMatrixWorld();
            outline.applyMatrix(arc.matrixWorld);

            // draw lines of angle
            var geom1 = new THREE.Geometry();
            var geom2 = new THREE.Geometry();
            geom1.vertices.push(arc.geometry.vertices[0], arc.geometry.vertices[1]);
            geom2.vertices.push(arc.geometry.vertices[0], arc.geometry.vertices[arc.geometry.vertices.length - 2]);
            var line1 = new THREE.Line(geom1, _materialAngle);
            var line2 = new THREE.Line(geom2, _materialAngle);
            line1.applyMatrix(arc.matrixWorld);
            line2.applyMatrix(arc.matrixWorld);


            _viewer.impl.addOverlay(kAngleOverlayName, arc);
            _viewer.impl.addOverlay(kAngleOutlineOverlayName, outline);
            _viewer.impl.addOverlay(kAngleOutlineOverlayName, line1);
            _viewer.impl.addOverlay(kAngleOutlineOverlayName, line2);

            // This is used for angle label's position
            midPoint.copy(arc.geometry.vertices[Math.round(arc.geometry.vertices.length / 2) - 1]);
            midPoint.applyMatrix4(arc.matrixWorld);
        };

        // Draw angle between face to face
        this.drawAngleFaceToFace = function (p1, n1, p2, n2) {

            var vPs = this.intersectPlaneToPlane(p1, n1, p2, n2);

            var X1 = new THREE.Vector3();
            var X2 = new THREE.Vector3();
            X1.subVectors(p1, vPs[0]);
            X2.subVectors(p2, vPs[1]);

            var angle = this.angleVectorToVector(X1, X2);

            var p = vPs[0].clone();
            var n = new THREE.Vector3();
            n.crossVectors(n1, n2);
            n.normalize();

            vPs = this.intersectPlaneToPlane(p1, n1, p, n);
            var ep1 = vPs[0].clone();
            vPs = this.intersectPlaneToPlane(p2, n2, p, n);
            var ep2 = vPs[0].clone();

            var midPoint = new THREE.Vector3();

            this.drawAngle(p, ep1, ep2, n, angle, midPoint);

            if (_measureMan.getConsumeSingleClick()) {

                var label = _angleLabel.label;
                if (!label) {

                    label = _angleLabel.label = document.createElement('div');
                    label.className = 'measure-length';
                    _viewer.container.appendChild(label);

                    var text = document.createElement('div');
                    text.className = 'measure-length-text';
                    label.appendChild(text);

                    // This button is for Markup and Comments
                    //var button = document.createElement('div');
                    //button.className = 'measure-length-button';
                    //button.style.cursor = 'pointer';
                    //button.addEventListener('click', function (event) {
                    //
                    //}, true);
                    //label.appendChild(button);
                }

                label.children[0].textContent = tool.getAngle();
                label.classList.toggle('visible', true);

                _angleLabel.p1 = midPoint.clone();
                _angleLabel.p2 = midPoint.clone();

                this.updateLabelPositions();
            }

            return angle;
        };

        // Draw angle between line to line
        this.drawAngleLineToLine = function (p1, p2, p3, p4, angle) {

            var p = p1;
            var n = new THREE.Vector3();
            var n1 = new THREE.Vector3();
            var n2 = new THREE.Vector3();
            n1.subVectors(p1, p2);
            n2.subVectors(p3, p4);
            n.crossVectors(n1, n2);
            n.normalize();


            var ep1 = p2;
            var ep2 = new THREE.Vector3();
            ep2.subVectors(p, p3);
            ep2.add(p4);

            var midPoint = new THREE.Vector3();

            this.drawAngle(p, ep1, ep2, n, angle, midPoint);

            if (_measureMan.getConsumeSingleClick()) {

                var label = _angleLabel.label;
                if (!label) {

                    label = _angleLabel.label = document.createElement('div');
                    label.className = 'measure-length';
                    _viewer.container.appendChild(label);

                    var text = document.createElement('div');
                    text.className = 'measure-length-text';
                    label.appendChild(text);

                    // This button is for Markup and Comments
                    //var button = document.createElement('div');
                    //button.className = 'measure-length-button';
                    //button.style.cursor = 'pointer';
                    //button.addEventListener('click', function (event) {
                    //
                    //}, true);
                    //label.appendChild(button);
                }

                label.children[0].textContent = tool.getAngle();
                label.classList.toggle('visible', true);

                _angleLabel.p1 = midPoint.clone();
                _angleLabel.p2 = midPoint.clone();

                this.updateLabelPositions();
            }
        };

        // Find the intersection point of two nonparallel lines
        this.intersectLineToLine = function(p1, v1, p2, v2) {

            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();

            X0.subVectors(p2, p1);
            X0.cross(v2);
            X1.crossVectors(v1, v2);

            var scalar = X0.divide(X1);

            X1 = v1.clone();
            X1.multiplyScalar(scalar);
            X0.addVectors(p1, X1);

            return X0;
        };

        // Find the nearest point from point to plane
        this.nearestPointInPointToPlane = function(p1, p2, n) {

            var nearestPoint = new THREE.Vector3();
            var norm = n.clone();
            var X0 = new THREE.Vector3();
            X0.subVectors(p1, p2);

            var sn = -norm.dot(X0);
            var sd = norm.dot(norm);
            var sb = sn / sd;

            nearestPoint.addVectors(p1, norm.multiplyScalar(sb));
            return nearestPoint;
        };

        // Measure from face to vertex
        this.faceToPointMeasure = function(face, normal, intersectPoint, point) {

            var p = face.vertices[0];

            var X0 = this.nearestPointInPointToPlane(point, p, normal);

            var p1 = intersectPoint.clone();
            var p2 = new THREE.Vector3();
            p2.subVectors(p1, X0);
            p2.add(point);

            //var dist = new THREE.Vector3();
            //dist.subVectors(X0, p1);
            //var extendFace = face.clone();
            //extendFace.applyMatrix(new THREE.Matrix4().makeTranslation(dist.x, dist.y, dist.z));

            var dist = X0.distanceTo(intersectPoint) * 2;
            var extendFace = new THREE.PlaneBufferGeometry(dist, dist);
            this.drawExtensionFace(extendFace, intersectPoint, normal);

            this.drawLine(point, X0, _hideXYZ);
            //this.drawExtensionLinePointToPoint(p1, X0);
            return [point, X0];
        };

        // Find the nearest point from point to face
        this.nearestPointInPointToFace = function(point, face, normal) {

            var nearestPoint;
            var minDist = Number.MAX_VALUE;
            var u = new THREE.Vector3();
            var v = new THREE.Vector3();
            var w = new THREE.Vector3();
            var n = new THREE.Vector3();

            for (var i = 0; i < face.vertices.length; i += 3) {

                u.subVectors(face.vertices[i + 1], face.vertices[i]);
                v.subVectors(face.vertices[i + 2], face.vertices[i]);
                n.crossVectors(u, v);
                w.subVectors(point, face.vertices[i]);

                u.cross(w);
                var r = u.dot(n) / n.dot(n);
                w.cross(v);
                var b = w.dot(n) / n.dot(n);
                var a = 1 - r - b;

                if (a >= 0 && a <= 1 && b >= 0 && b <= 1 && r >= 0 && r <= 1) {

                    nearestPoint = this.nearestPointInPointToPlane(point, face.vertices[0], normal);
                    return nearestPoint;
                }
            }

            for (var i = 0; i < face.vertices.length; i += 3) {

                var p = this.nearestPointInPointToSegment(point, face.vertices[i], face.vertices[i + 1]);
                if (point.distanceTo(p) < minDist) {
                    minDist = point.distanceTo(p);
                    nearestPoint = p.clone();
                }

                p = this.nearestPointInPointToSegment(point, face.vertices[i], face.vertices[i + 2]);
                if (point.distanceTo(p) < minDist) {
                    minDist = point.distanceTo(p);
                    nearestPoint = p.clone();
                }

                p = this.nearestPointInPointToSegment(point, face.vertices[i + 1], face.vertices[i + 2]);
                if (point.distanceTo(p) < minDist) {
                    minDist = point.distanceTo(p);
                    nearestPoint = p.clone();
                }
            }

            return nearestPoint;
        };

        // Measure from point to face
        this.pointToFaceMeasure = function(point, face, normal, intersectPoint) {

            var p = face.vertices[0];

            var X0 = this.nearestPointInPointToPlane(point, p, normal);

            var p1 = intersectPoint.clone();
            var p2 = new THREE.Vector3();
            p2.subVectors(p1, X0);
            p2.add(point);

            this.drawLine(p1, p2, _hideXYZ);
            this.drawExtensionLinePointToPoint(point, p2);
            return [point, X0];

        };

        // Find the two nearest points between edge and face
        this.nearestPointsInEdgeToFace = function(edge, face) {

            var nearestPoints = [];
            var minDist = Number.MAX_VALUE;

            var eps = _snapper.getEndPointsInEdge(edge);
            var p1 = eps[0];
            var p2 = eps[1];

            var p3, p4;

            for (var i = 0; i < face.vertices.length; i += 3) {

                p3 = face.vertices[i];
                p4 = face.vertices[i + 1];
                var p = this.nearestPointsInSegmentToSegment(p1, p2, p3, p4);
                if (p[0].distanceTo(p[1]) < minDist) {
                    minDist = p[0].distanceTo(p[1]);
                    nearestPoints[0] = p[0].clone();
                    nearestPoints[1] = p[1].clone();
                }

                p3 = face.vertices[i];
                p4 = face.vertices[i + 2];
                p = this.nearestPointsInSegmentToSegment(p1, p2, p3, p4);
                if (p[0].distanceTo(p[1]) < minDist) {
                    minDist = p[0].distanceTo(p[1]);
                    nearestPoints[0] = p[0].clone();
                    nearestPoints[1] = p[1].clone();
                }

                p3 = face.vertices[i + 1];
                p4 = face.vertices[i + 2];
                p = this.nearestPointsInSegmentToSegment(p1, p2, p3, p4);
                if (p[0].distanceTo(p[1]) < minDist) {
                    minDist = p[0].distanceTo(p[1]);
                    nearestPoints[0] = p[0].clone();
                    nearestPoints[1] = p[1].clone();
                }
            }

            return nearestPoints;
        };

        // Measure from Face to Edge
        this.faceToEdgeMeasure = function(face, normal, faceIntersectPoint, edge, edgeIntersectPoint) {

            var smallNum = 0.01;

            var eps = _snapper.getEndPointsInEdge(edge);
            var p1;
            var p2;

            if (eps[0].distanceTo(faceIntersectPoint) < eps[1].distanceTo(faceIntersectPoint)) {
                p1 = eps[0];
                p2 = eps[1];
            }
            else {
                p1 = eps[1];
                p2 = eps[0];
            }

            var X0 = new THREE.Vector3();
            X0.subVectors(p2, p1);

            var angle = this.angleLineToPlane(X0, normal);

            if (X0.dot(normal) <= smallNum && X0.dot(normal) >= -smallNum) { // the edge is parallel with the face

                var p = face.vertices[0];
                var X1 = this.nearestPointInPointToPlane(p1, p, normal);

                var point = this.nearestPointInPointToLine(edgeIntersectPoint, p1, p2);
                this.faceToPointMeasure(face, normal, faceIntersectPoint, point);

                return [p1, X1, angle];
            }
            else { // nonparallel between edge and face

                // Find the nearest point on the edge to the intersectPoint, make this point as the new endpoint of the edge,
                // because we don't want to draw the arc so big, this is consistent with Fusion
                var newEp = this.nearestPointInPointToLine(edgeIntersectPoint, p1, p2);

                this.drawAngleEdgeToFace(face.vertices[0], normal, faceIntersectPoint, p1, newEp, angle);

                //var X1 = this.nearestPointsInEdgeToFace(edge, face);

                //this.drawLine(X1[0], X1[1]);
                //return [X1[0], X1[1], angle];
                return angle;
            }

        };

        // Measure from Edge to Face
        this.edgeToFaceMeasure = function(edge, edgeIntersectPoint, face, normal, faceIntersectPoint) {

            var smallNum = 0.01;

            var eps = _snapper.getEndPointsInEdge(edge);
            var p1;
            var p2;

            if (eps[0].distanceTo(faceIntersectPoint) < eps[1].distanceTo(faceIntersectPoint)) {
                p1 = eps[0];
                p2 = eps[1];
            }
            else {
                p1 = eps[1];
                p2 = eps[0];
            }

            var X0 = new THREE.Vector3();
            X0.subVectors(p2, p1);

            var angle = this.angleLineToPlane(X0, normal);

            if (X0.dot(normal) <= smallNum && X0.dot(normal) >= -smallNum) { // the edge is parallel with the face

                var p = face.vertices[0];
                var X1 = this.nearestPointInPointToPlane(p1, p, normal);

                var newp1 = new THREE.Vector3();
                newp1.subVectors(faceIntersectPoint, X1);
                newp1.add(p1);

                var newp2 = new THREE.Vector3();
                newp2.subVectors(faceIntersectPoint, X1);
                newp2.add(p2);

                this.drawLine(newp1, faceIntersectPoint, _hideXYZ);
                this.drawExtensionLinePointToPoint(newp1, newp2);
                return [p1, X1, angle];
            }
            else { // nonparallel between edge and face

                // Find the nearest point on the edge to the intersectPoint, make this point as the new endpoint of the edge,
                // because we don't want to draw the arc so big, this is consistent with Fusion
                var newEp = this.nearestPointInPointToLine(edgeIntersectPoint, p1, p2);

                this.drawAngleEdgeToFace(face.vertices[0], normal, faceIntersectPoint, p1, newEp, angle);

                //var X1 = this.nearestPointsInEdgeToFace(edge, face);

                //this.drawLine(X1[0], X1[1]);
                //return [X1[0], X1[1], angle];
                return angle;
            }

        };

        // Get the angle between line and plane
        this.angleLineToPlane = function(v, n) {

            var angle = this.angleVectorToVector(v, n);

            if (angle > 90) {
                angle -= 90;
            }
            else {
                angle = 90 - angle;
            }

            return angle;
        };

        // Draw angle between edge and face
        this.drawAngleEdgeToFace = function(p0, n0, faceIntersectPoint, p1, p2, angle) {

            var p = this.intersectPointLineToPlane(p0, n0, p1, p2);
            if (!p) {
                return;
            }

            var ep1 = p2;

            if (angle === 90) {   // edge and face are vertical with each other
                var ep2 = faceIntersectPoint.clone();
            }
            else {
                var ep2 = this.nearestPointInPointToPlane(p2, p0, n0);
            }

            var n = new THREE.Vector3();
            var n1 = new THREE.Vector3();
            var n2 = new THREE.Vector3();
            n1.subVectors(p2, p1);
            n2.subVectors(ep2, p);
            n.crossVectors(n1, n2);
            n.normalize();

            var midPoint = new THREE.Vector3();

            this.drawAngle(p, ep1, ep2, n, angle, midPoint);

            if (_measureMan.getConsumeSingleClick()) {

                var label = _angleLabel.label;
                if (!label) {

                    label = _angleLabel.label = document.createElement('div');
                    label.className = 'measure-length';
                    _viewer.container.appendChild(label);

                    var text = document.createElement('div');
                    text.className = 'measure-length-text';
                    label.appendChild(text);

                    // This button is for Markup and Comments
                    //var button = document.createElement('div');
                    //button.className = 'measure-length-button';
                    //button.style.cursor = 'pointer';
                    //button.addEventListener('click', function (event) {
                    //
                    //}, true);
                    //label.appendChild(button);
                }

                label.children[0].textContent = tool.getAngle();
                label.classList.toggle('visible', true);

                _angleLabel.p1 = midPoint.clone();
                _angleLabel.p2 = midPoint.clone();

                this.updateLabelPositions();
            }
        };

        // Get the intersect point between line and plane
        this.intersectPointLineToPlane = function(p0, n0, p1, p2) {

            var smallNum = 0.001;

            var u = new THREE.Vector3();
            var w = new THREE.Vector3();
            u.subVectors(p2, p1);
            w.subVectors(p1, p0);

            var D = n0.dot(u);
            var N = -n0.dot(w);

            if (Math.abs(D) < smallNum) {  // edge is parallel to plane
                if (N == 0)                      // edge lies in plane
                    return null;
                else
                    return null;                    // no intersection
            }

            // they are not parallel
            u.multiplyScalar(N / D);             // compute segment intersect point
            u.add(p1);
            return u;
        };

        this.isEqualVectors = function (v1, v2, precision) {

            if (v1.x <= v2.x + precision && v1.x >= v2.x - precision && v1.y <= v2.y + precision && v1.y >= v2.y - precision
                && v1.z <= v2.z + precision && v1.z >= v2.z - precision) {

                return true;
            }

            return false;
        };

        this.isInverseVectors = function (v1, v2, precision) {

            if (v1.x <= -v2.x + precision && v1.x >= -v2.x - precision && v1.y <= -v2.y + precision && v1.y >= -v2.y - precision
                && v1.z <= -v2.z + precision && v1.z >= -v2.z - precision) {

                return true;
            }

            return false;
        };

        // Set if collapse or expand the xyz delta distance
        this.setSimple = function (simple) {
            if (_simple != simple) {
                _simple = simple;

                for (var name in _lines) {
                    if (name !== 'xyz' && _lines.hasOwnProperty(name)) {
                        var item = _lines[name];
                        if (item.line) {
                            item.line.visible = !simple;

                            if (item.label) {
                                item.label.classList.toggle('visible', !simple);
                            }
                        }
                    }
                }

                _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);
            }
        };

        this.hide = function () {
            var name;

            for (name in _endPoints) {
                if (_endPoints.hasOwnProperty(name)) {
                    var endPoint = _endPoints[name];
                    if (endPoint.mesh) {
                        endPoint.mesh.visible = false;
                    }
                    if (endPoint.label) {
                        endPoint.label.classList.remove('visible');
                    }
                }
            }

            for (name in _edges) {
                if (_edges.hasOwnProperty(name)) {
                    var edge = _edges[name];
                    if (edge.line) {
                        edge.line.visible = false;
                    }
                    if (edge.label) {
                        edge.label.classList.remove('visible');
                    }
                }
            }

            for (name in _faces) {
                if (_faces.hasOwnProperty(name)) {
                    var face = _faces[name];
                    if (face.mesh) {
                        face.mesh.visible = false;
                    }
                    if (face.label) {
                        face.label.classList.remove('visible');
                    }
                }
            }

            for (name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        item.line.visible = false;
                    }
                    if (item.label) {
                        item.label.classList.remove('visible');
                    }
                }
            }

            if (_angleLabel.label) {
                _angleLabel.label.classList.remove('visible');
            }

            if (_materialAngle) {

                _viewer.impl.clearOverlay(kAngleOverlayName);
                _viewer.impl.clearOverlay(kAngleOutlineOverlayName);
            }

            if (_materialExtensionLine) {

                _viewer.impl.clearOverlay(kExtensionLineOverlayName);
            }

            if (_materialExtensionFace) {

                _viewer.impl.clearOverlay(kExtensionFaceOverlayName);
            }

            _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);
        };

        this.hideClick = function(clickName) {

            if (_endPoints.hasOwnProperty(clickName)) {
                var endPoint = _endPoints[clickName];
                if (endPoint.mesh) {
                    endPoint.mesh.visible = false;
                }
                if (endPoint.label) {
                    endPoint.label.classList.remove('visible');
                }
            }

            if (_edges.hasOwnProperty(clickName)) {
                var edge = _edges[clickName];
                if (edge.line) {
                    edge.line.visible = false;
                }
                if (edge.label) {
                    edge.label.classList.remove('visible');
                }
            }

            if (_faces.hasOwnProperty(clickName)) {
                var face = _faces[clickName];
                if (face.mesh) {
                    face.mesh.visible = false;
                }
                if (face.label) {
                    face.label.classList.remove('visible');
                }
            }

            for (var name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        item.line.visible = false;
                    }
                    if (item.label) {
                        item.label.classList.remove('visible');
                    }
                }
            }

            if (_angleLabel.label) {
                _angleLabel.label.classList.remove('visible');
            }

            if (_materialAngle) {

                _viewer.impl.clearOverlay(kAngleOverlayName);
                _viewer.impl.clearOverlay(kAngleOutlineOverlayName);
            }

            if (_materialExtensionLine) {

                _viewer.impl.clearOverlay(kExtensionLineOverlayName);
            }

            if (_materialExtensionFace) {

                _viewer.impl.clearOverlay(kExtensionFaceOverlayName);
            }

            _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);

        };

        this.destroy = function () {
            var name;

            for (name in _endPoints) {
                if (_endPoints.hasOwnProperty(name)) {
                    var endPoint = _endPoints[name];
                    if (endPoint.mesh) {
                        _viewer.impl.removeOverlay(kEndPointOverlayName, endPoint.mesh);
                        endPoint.mesh = endPoint.geometry = null;
                    }
                    if (endPoint.label) {
                        endPoint.label.parentNode.removeChild(endPoint.label);
                        endPoint.label = null;
                    }
                }
            }

            for (name in _edges) {
                if (_edges.hasOwnProperty(name)) {
                    var edge = _edges[name];
                    if (edge.line) {
                        _viewer.impl.removeOverlay(kEdgeOverlayName, edge.line);
                        edge.line = edge.intersectPoint = null;
                    }
                    if (edge.label) {
                        edge.label.parentNode.removeChild(edge.label);
                        edge.label = null;
                    }
                }
            }

            for (name in _faces) {
                if (_faces.hasOwnProperty(name)) {
                    var face = _faces[name];
                    if (face.mesh) {
                        _viewer.impl.removeOverlay(kFaceOverlayName, face.mesh);
                        face.mesh = face.intersectPoint = null;
                    }
                    if (face.label) {
                        face.label.parentNode.removeChild(face.label);
                        face.label = null;
                    }
                }
            }

            if (_materialPoint) {
                _materialPoint = null;
                _viewer.impl.removeOverlayScene(kEndPointOverlayName);
            }

            if (_materialFace) {
                _materialFace = null;
                _viewer.impl.removeOverlayScene(kFaceOverlayName);
            }

            if (_materialLine) {
                _materialLine = null;
                _viewer.impl.removeOverlayScene(kEdgeOverlayName);
            }

            if (_materialExtensionLine) {
                _materialExtensionLine = null;
                _viewer.impl.removeOverlayScene(kExtensionLineOverlayName);
            }

            if (_materialExtensionFace) {
                _materialExtensionFace = null;
                _viewer.impl.removeOverlayScene(kExtensionFaceOverlayName);
            }

            for (name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        _viewer.impl.removeOverlay(item.overlayName, item.line);
                        _viewer.impl.removeOverlayScene(item.overlayName);
                        item.material = item.line = item.geometry = null;
                    }

                    if (item.label) {
                        item.label.parentNode.removeChild(item.label);
                        item.label = null;
                    }
                    item.material = item.line = item.geometry = item.label = item.p1 = item.p2 = null;
                }
            }

            if (_angleLabel.label) {
                _angleLabel.label.parentNode.removeChild(_angleLabel.label);
                _angleLabel.label = null;
            }
            _angleLabel.label = _angleLabel.p1 = _angleLabel.p2 = null;

        };
    }
};
;AutodeskNamespace('Autodesk.Viewing.Extensions.Measure');

var SNAP_VERTEX = 0;
var SNAP_EDGE = 1;
var SNAP_FACE = 2;
var SNAP_PRECISION = 0.001;

//
// /** @constructor */
//
//
Autodesk.Viewing.Extensions.Measure.Snapper = function(viewer, molMan) {

    var _viewer = viewer;
    var _molMan = molMan;

    var _names = ["snapper"];
    var _active = false;

    var _faceOverlayName = 'MeasureTool-snapper-face';
    var _vertexOverlayName = 'MeasureTool-snapper-vertex';
    var _edgeOverlayName = 'MeasureTool-snapper-edge';

    var _radius = 0.05;
    var _distanceToEdge = null;
    var _distanceToVertex = null;

    var _geomFace = null;
    var _geomEdge = null;
    var _geomVertex = null;
    var _snapNode = null;

    var _geomHighlighted = null; //  {"VERTEX": 0, "EDGE": 1, "FACE": 2}

    var _intersectPoint = null;
    var _faceNormal = null;

    var _isDragging = false;

    var _snappingNode = null;

    var _isSnapped = false;

    var _viewportIndex2d = null;

    this.atomLabel = document.createElement('div');
    this.atomLabel.setAttribute('class','atom-label');
    _viewer.container.appendChild(this.atomLabel);

    this.isActive = function() {
        return _active;
    };

    this.getNames = function() {
        return _names;
    };

    this.getName = function() {
        return _names[0];
    };

    this.activate = function() {
        _active = true;
    };

    this.deactivate = function() {
        _active = false;
        this.destroy();
    };

    this.getFace = function() {
        return _geomFace;
    };

    this.getEdge = function() {
        return _geomEdge;
    };

    this.getVertex = function() {
        return _geomVertex;
    };

    this.getSnapNode = function() {
        return _snapNode;
    };

    this.getHighlightGeometry = function() {
        return _geomHighlighted;
    };

    this.getIntersectPoint = function() {
        return _intersectPoint;
    };

    this.getFaceNormal = function() {
        return _faceNormal;
    };

    this.getEndPointsInEdge = function(edge) {

        var vertices = edge.vertices;
        var endPoints = [];

        for (var i = 0; i < vertices.length; ++i) {

            var duplicate = false;

            for (var j = 0; j < vertices.length; ++j) {

                if (j !== i && vertices[j].equals(vertices[i])) {

                    duplicate = true;
                    break;
                }
            }

            if (!duplicate) {

                endPoints.push(vertices[i]);

            }
        }

        return endPoints;
    };

    this.getViewportIndex = function() {
        return _viewportIndex2d;
    };

    this.isSnapped = function() {
        return _isSnapped;
    };

    this.isEqualWithPrecision = function(a, b) {

        if (a <= b + SNAP_PRECISION && a >= b - SNAP_PRECISION) {
            return true;
        }

        return false;
    };

    this.isEqualVectorsWithPrecision = function(v1, v2) {

        if (v1.x <= v2.x + SNAP_PRECISION && v1.x >= v2.x - SNAP_PRECISION && v1.y <= v2.y + SNAP_PRECISION && v1.y >= v2.y - SNAP_PRECISION
            && v1.z <= v2.z + SNAP_PRECISION && v1.z >= v2.z - SNAP_PRECISION) {

            return true;
        }

        return false;
    };

    this.isInverseVectorsWithPrecision = function(v1, v2) {

        if (v1.x <= -v2.x + SNAP_PRECISION && v1.x >= -v2.x - SNAP_PRECISION && v1.y <= -v2.y + SNAP_PRECISION && v1.y >= -v2.y - SNAP_PRECISION
            && v1.z <= -v2.z + SNAP_PRECISION && v1.z >= -v2.z - SNAP_PRECISION) {

            return true;
        }

        return false;
    };

    this.getAtomInfo = function getAtomInfo(atomID) {
        var md = _molMan.molModels[_molMan.currentMolModelID].molMetadata,
            vm2d = _viewer.app.ViewManager,
            chain = 'Chain ' + md.chains[atomID],
            residue = vm2d.fullnames[ md.residues[atomID]],
            atom = md.metaData[atomID].detailType;
        if(!residue) {
            residue = md.residues[atomID];
        }

        residue += (' ' + md.metaArray[atomID][1]);

        return [chain,residue,atom];
    };

    this.setAtomLabel = function setAtomLabel(atomInfo,atomID) {
        this.atomLabel.innerHTML = '<span class="model-subtitle dark">' + atomInfo[0] + '&nbsp;&rang;&nbsp;' + atomInfo[1] + '&nbsp;&rang;&nbsp;</span>' + atomInfo[2];
        this.atomLabel.classList.add('visible');
    };

    this.setLabelPosition = function setLabelPosition(x, y, z) {
        var camera = _viewer.navigation.getCamera(),
            containerBounds = _viewer.navigation.getScreenViewport(),
            p = new THREE.Vector3(x, y, z),
            x,
            y;

        p = p.project(camera);
        x = Math.round(( p.x + 1) / 2 * containerBounds.width) + 10,    // Add 5px to make the label not to be on the object
        y = Math.round((-p.y + 1) / 2 * containerBounds.height) + 10    // Add 5px to make the label not to be on the object
        x = x + this.atomLabel.clientWidth >= containerBounds.width ? ((x - this.atomLabel.clientWidth) - 10) : x;
        y = y + 23 >= containerBounds.height ? y - 39 : y;

        return {
            x: x,
            y: y
        };
    };

    /**
     * 3D Snapping
     * @param result -Result of Hit Test.
     */
    this.snapping3D = function(result) {
        var atomInfo = this.getAtomInfo(result.atomID),
            labelPosition;
        _snapNode = result.dbId;

        var obj = _molMan.getAtomPosition(result.instance,result.atomID);
        var point = new THREE.Vector3(obj.x, obj.y, obj.z);
        _geomVertex = point;
        this.drawPoint(point);
        _geomHighlighted = SNAP_VERTEX;
        _isSnapped = true;
        this.setAtomLabel(atomInfo, result.atomID);
        labelPosition = this.setLabelPosition(point.x, point.y, point.z);

        this.atomLabel.style.top = labelPosition.y + 'px';
        this.atomLabel.style.left = labelPosition.x + 'px';
        this.atomLabel.classList.add('visible');
    };

    /**
     * Find the closest face next to the cast ray
     * @param face - the intersect triangle of Hit Test.
     * @param geometry - the geometry of mesh
     */
    this.faceSnapping = function(face, geometry) {

        var vA = new THREE.Vector3();
        var vB = new THREE.Vector3();
        var vC = new THREE.Vector3();

        var geom = new THREE.Geometry();  //Geometry which includes all the triangles on the same plane.

        var attributes = geometry.attributes;

        if (attributes.index !== undefined) {

            var indices = attributes.index.array || geometry.ib;
            var positions = geometry.vb ? geometry.vb : attributes.position.array;
            var stride = geometry.vb ? geometry.vbstride : 3;
            var offsets = geometry.offsets;

            if ( !offsets || offsets.length === 0) {

                offsets = [{start: 0, count: indices.length, index: 0}];

            }

            for (var oi = 0; oi < offsets.length; ++oi) {

                var start = offsets[oi].start;
                var count = offsets[oi].count;
                var index = offsets[oi].index;

                for (var i = start; i < start + count; i += 3) {

                    var a = index + indices[i];
                    var b = index + indices[i + 1];
                    var c = index + indices[i + 2];

                    vA.set(
                        positions[a * stride],
                        positions[a * stride + 1],
                        positions[a * stride + 2]
                    );
                    vB.set(
                        positions[b * stride],
                        positions[b * stride + 1],
                        positions[b * stride + 2]
                    );
                    vC.set(
                        positions[c * stride],
                        positions[c * stride + 1],
                        positions[c * stride + 2]
                    );

                    var faceNormal = THREE.Triangle.normal(vA, vB, vC);

                    var va = new THREE.Vector3();
                    va.set(
                        positions[ face.a * stride ],
                        positions[ face.a * stride + 1 ],
                        positions[ face.a * stride + 2 ]
                    );

                    if (this.isEqualVectorsWithPrecision(faceNormal, face.normal) && this.isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))
                    {

                        var vIndex = geom.vertices.length;

                        geom.vertices.push(vA.clone());
                        geom.vertices.push(vB.clone());
                        geom.vertices.push(vC.clone());

                        geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));

                    }
                }
            }
        }

        if (geom.vertices.length > 0) {

            return this.getTrianglesOnSameFace(geom, face, positions, stride);
        }
        else {

            return null;
        }
    };

    /**
     * Find triangles on the same face with the triangle intersected with the cast ray
     * @param geom -Geometry which includes all the triangles on the same plane.
     * @param face -Triangle which intersects with the cast ray.
     * @param positions -Positions of all vertices.
     * @param stride -Stride for the interleaved buffer.
     */
    this.getTrianglesOnSameFace = function(geom, face, positions, stride) {

        var isIncludeFace = false; // Check if the intersect face is in the mesh
        var vertexIndices = geom.vertices.slice();

        var va = new THREE.Vector3();
        va.set(
            positions[ face.a * stride ],
            positions[ face.a * stride + 1 ],
            positions[ face.a * stride + 2 ]
        );
        var vb = new THREE.Vector3();
        vb.set(
            positions[ face.b * stride ],
            positions[ face.b * stride + 1 ],
            positions[ face.b * stride + 2 ]
        );
        var vc = new THREE.Vector3();
        vc.set(
            positions[ face.c * stride ],
            positions[ face.c * stride + 1 ],
            positions[ face.c * stride + 2 ]
        );
        var intersectFace = new THREE.Geometry();
        intersectFace.vertices.push(va);
        intersectFace.vertices.push(vb);
        intersectFace.vertices.push(vc);
        intersectFace.faces.push(new THREE.Face3(0, 1, 2));

        var vCount = [];

        do {

            vCount = [];

            for (var j = 0; j < vertexIndices.length; j += 3) {

                // The triangle which is intersected with the ray
                if (vertexIndices[j].equals(va) && vertexIndices[j + 1].equals(vb) && vertexIndices[j + 2].equals(vc)) {

                    isIncludeFace = true;
                    vCount.push(j);
                    continue;
                }

                for (var k = 0; k < intersectFace.vertices.length; k += 3) {

                    // The triangles which are on the same face with the intersected triangle
                    if (this.trianglesSharedEdge(vertexIndices[j], vertexIndices[j + 1], vertexIndices[j + 2],
                            intersectFace.vertices[k], intersectFace.vertices[k + 1], intersectFace.vertices[k + 2])) {

                        var vIndex = intersectFace.vertices.length;
                        intersectFace.vertices.push(vertexIndices[j].clone());
                        intersectFace.vertices.push(vertexIndices[j + 1].clone());
                        intersectFace.vertices.push(vertexIndices[j + 2].clone());
                        intersectFace.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));

                        vCount.push(j);
                        break;
                    }
                }
            }

            for (var ci = vCount.length - 1; ci >= 0; --ci) {

                vertexIndices.splice(vCount[ci], 3);

            }

        } while (vCount.length > 0);

        if (isIncludeFace) {
            return intersectFace;
        }
        else {
            return null;
        }

    };

    /**
     * Check if the two triangle share edge, the inputs are their vertices
     */
    this.trianglesSharedEdge = function(a1, a2, a3, b1, b2, b3) {

        var c1 = false;
        var c2 = false;
        var c3 = false;

        if (a1.equals(b1) || a1.equals(b2) || a1.equals(b3)) {
            c1 = true;
        }
        if (a2.equals(b1) || a2.equals(b2) || a2.equals(b3)) {
            c2 = true;
        }
        if (a3.equals(b1) || a3.equals(b2) || a3.equals(b3)) {
            c3 = true;
        }

        if (c1 & c2 || c1 & c3 || c2 & c3) {
            return true;
        }

        return false;
    };

    /**
     * Find the closest edge next to the intersect point
     * @param face -Face which is found by faceSnapping.
     * @param intersectPoint -IntersectPoint between cast ray and face.
     * @param mesh -The whole mesh of one fragment.
     */
    this.edgeSnapping = function(face, intersectPoint, mesh) {

        var lineGeom = new THREE.Geometry();
        var isEdge_12 = true;
        var isEdge_13 = true;
        var isEdge_23 = true;

        for (var i = 0; i < face.vertices.length; i += 3) {

            for (var j = 0; j < face.vertices.length; j += 3) {

                if ( i !== j ) {
                    // Check edge 12
                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])
                        || face.vertices[i].equals(face.vertices[j + 2]))
                        && (face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])
                        || face.vertices[i + 1].equals(face.vertices[j + 2]))) {

                        isEdge_12 = false;

                    }
                    // Check edge 13
                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])
                        || face.vertices[i].equals(face.vertices[j + 2]))
                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])
                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {

                        isEdge_13 = false;

                    }
                    // Check edge 23
                    if ((face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])
                        || face.vertices[i + 1].equals(face.vertices[j + 2]))
                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])
                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {

                        isEdge_23 = false;

                    }
                }
            }

            if (isEdge_12) {

                lineGeom.vertices.push(face.vertices[i].clone());
                lineGeom.vertices.push(face.vertices[i + 1].clone());

            }
            if (isEdge_13) {

                lineGeom.vertices.push(face.vertices[i].clone());
                lineGeom.vertices.push(face.vertices[i + 2].clone());

            }
            if (isEdge_23) {

                lineGeom.vertices.push(face.vertices[i + 1].clone());
                lineGeom.vertices.push(face.vertices[i + 2].clone());

            }

            isEdge_12 = true;
            isEdge_13 = true;
            isEdge_23 = true;

        }

        //return lineGeom;

        var edgeGeom = new THREE.Geometry();
        var minDistIndex;
        var minDist = Number.MAX_VALUE;
        var matrix = new THREE.Matrix4();
        matrix.getInverse(mesh.matrixWorld);
        intersectPoint.applyMatrix4(matrix);

        for (var k = 0; k < lineGeom.vertices.length; k += 2) {

            var dist = this.distancePointToLine(intersectPoint, lineGeom.vertices[k], lineGeom.vertices[k + 1]);

            if (dist < minDist) {
                minDist = dist;
                minDistIndex = k;
            }

        }

        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex ].clone());
        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex + 1 ].clone());

        edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeGeom.vertices);

        _distanceToEdge = minDist;

        return edgeGeom;

    };

    this.distancePointToLine = function (point, lineStart, lineEnd) {

        var X0 = new THREE.Vector3();
        var X1 = new THREE.Vector3();
        var distance;
        var param;

        X0.subVectors(lineStart, point);
        X1.subVectors(lineEnd, lineStart);
        param = X0.dot(X1);
        X0.subVectors(lineEnd, lineStart);
        param = -param / X0.dot(X0);

        if (param < 0) {
            distance = point.distanceTo(lineStart);
        }
        else if (param > 1) {
            distance = point.distanceTo(lineEnd);
        }
        else {
            X0.subVectors(point, lineStart);
            X1.subVectors(point, lineEnd);
            X0.cross(X1);
            X1.subVectors(lineEnd, lineStart);

            distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));
        }

        return distance;
    };

    this.getConnectedLineSegmentsOnSameLine = function(lineGeom, edgeVertices) {

        var vertices = lineGeom.vertices.slice();
        var va = edgeVertices[0];
        var vb = edgeVertices[1];

        var vCount = [];

        do {

            vCount = [];

            for (var j = 0; j < vertices.length; j += 2) {

                // The line which has min distance to intersection point
                if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {

                    continue;
                }

                for (var k = 0; k < edgeVertices.length; k += 2) {

                    // The line segments which are connected on the same line
                    if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||
                        vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {

                        var V0 = new THREE.Vector3();
                        var V1 = new THREE.Vector3();

                        V0.subVectors(edgeVertices[k],  edgeVertices[k + 1]);
                        V0.normalize();
                        V1.subVectors(vertices[j],vertices[j + 1]);
                        V1.normalize();

                        //if (V0.equals(V1) || V0.equals(V1.negate())) {
                        if (this.isEqualVectorsWithPrecision(V0, V1) || this.isInverseVectorsWithPrecision(V0, V1))
                        {

                            vCount.push(j);
                            break;

                        }
                    }
                }
            }

            for (var ci = vCount.length - 1; ci >= 0; --ci) {

                edgeVertices.push(vertices[ vCount[ci] ]);
                edgeVertices.push(vertices[ vCount[ci] + 1 ]);
                vertices.splice(vCount[ci], 2);

            }

        } while (vCount.length > 0);

        return edgeVertices;

    };

    /**
     * Find the closest vertex next to the intersect point
     * @param edge -Edge which is found by edgeSnapping.
     * @param intersectPoint -IntersectPoint between cast ray and face.
     */
    this.vertexSnapping = function(edge, intersectPoint) {

        var minDist = Number.MAX_VALUE;
        var point;

        for (var i = 0; i < edge.vertices.length; ++i) {

            var dist = intersectPoint.distanceTo(edge.vertices[i]);

            if (dist < minDist - SNAP_PRECISION) {

                minDist = dist;
                point = edge.vertices[i].clone();

            }
        }

        _distanceToVertex = minDist;

        return point;
    };

    this.angleVector2 = function(vector) {

        if (vector.x > 0 && vector.y >= 0) {
            return Math.atan(vector.y / vector.x);
        }
        else if (vector.x >= 0 && vector.y < 0) {
            return Math.atan(vector.y / vector.x) + Math.PI * 2;
        }
        else if (vector.x < 0 && vector.y <= 0) {
            return Math.atan(vector.y / vector.x) + Math.PI;
        }
        else if (vector.x <= 0 && vector.y > 0) {
            return Math.atan(vector.y / vector.x) + Math.PI;
        }
        else{ // x = 0, y = 0
            return null;
        }
    };

    function GeometryCallback(viewer, snapper) {
        this.viewer = viewer;
        this.snapper = snapper;

        this.lineGeom = new THREE.Geometry();
        this.circularArc = null;
        this.circularArcCenter;
        this.ellipticalArc = null;

        this.minDist = Number.MAX_VALUE;

        this.vpIdLine = null;
        this.vpIdCircular = null;
        this.vpIdElliptical = null;
    }

    GeometryCallback.prototype.onLineSegment = function(x1, y1, x2, y2, vpId) {
        //stderr("line segment");
        var vertices = this.lineGeom.vertices;
        var v1 = new THREE.Vector3(x1, y1, 0);
        var v2 = new THREE.Vector3(x2, y2, 0);

        var intersectPoint = this.snapper.getIntersectPoint();
        var dist = this.snapper.distancePointToLine(intersectPoint, v1, v2);
        if (dist < this.minDist) {

            vertices.splice(0, 2, v1, v2);
            this.minDist = dist;

            this.vpIdLine = vpId;
        }
    };

    GeometryCallback.prototype.onCircularArc = function(cx, cy, start, end, radius, vpId) {
        //stderr("circular arc");
        var intersectPoint = this.snapper.getIntersectPoint();
        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);

        var center = new THREE.Vector2(cx, cy);
        var dist = point.distanceTo(center);
        point.sub(center);

        var angle = this.snapper.angleVector2(point);

        if (dist <= radius + 0.1 && dist >= radius - 0.1) {

            if (end > start && angle >= start && angle <= end) {
                var arc = new THREE.CircleGeometry(radius, 100, start, end - start);
            }
            else if (end < start && (angle >= start || angle <= end)) {
                var arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);
            }
            else {
                return;
            }
            arc.vertices.splice(0, 1);
            this.circularArc = arc;
            this.circularArcCenter = new THREE.Vector3(cx, cy, 0);

            this.vpIdCircular = vpId;
        }
    };

    GeometryCallback.prototype.onEllipticalArc = function(cx, cy, start, end, major, minor, tilt, vpId) {
        //stderr("elliptical arc");
        //console.log("cx " + cx + " cy " + cy + " major " + major + " minor " + minor + " start " + start + " end " + end + " tilt " + tilt);
        var intersectPoint = this.snapper.getIntersectPoint();
        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);

        var equation = (point.x - cx) * (point.x - cx) / (major * major) + (point.y - cy) * (point.y - cy) / (minor * minor);

        var center = new THREE.Vector2(cx, cy);
        point.sub(center);
        point.x *= minor;
        point.y *= major;
        var angle = this.snapper.angleVector2(point);

        if (end > Math.PI * 2) {
            end = Math.PI * 2;
        }

        if (equation <= 1 + 0.1 && equation >= 1 - 0.1) {

            if ((end > start && angle >= start && angle <= end) || (end < start && (angle >= start || angle <= end))){
                var curve = new THREE.EllipseCurve(cx, cy, major, minor, start, end, false);
                var path = new THREE.Path(curve.getPoints(50));
                var arc = path.createPointsGeometry(50);

                if (!this.isEqualWithPrecision(end - start, Math.PI * 2))
                {
                    arc.vertices.pop();
                }
                this.ellipticalArc = arc;

                this.vpIdElliptical = vpId;
            }
        }
    };


    this.snapping2D = function(result) {

        if (!result) {
            return;
        }

        var intersectPoint = result.intersectPoint;
        var fragIds = result.fragId;

        if (typeof fragIds === "undefined") {
            return;
        }
        else if (!Array.isArray(fragIds)) {
            fragIds = [fragIds];
        }

        _intersectPoint = intersectPoint;

        var gc = new GeometryCallback(_viewer, this);

        for (var fi = 0; fi < fragIds.length; ++fi) {

            var mesh = _viewer.impl.getRenderProxy(_viewer.model, fragIds[fi]);

            var vbr = new Autodesk.Viewing.Private.VertexBufferReader(mesh.geometry);
            vbr.enumGeomsForObject(result.dbId, gc);

        }

        if (gc.circularArc) {

            this.drawArc(gc.circularArc, gc.circularArcCenter);
            gc.circularArc = null;

            _geomVertex = gc.circularArcCenter;
            //this.drawPoint(_geomVertex);
            _geomHighlighted = SNAP_VERTEX;

            _viewportIndex2d = gc.vpIdCircular;

            _isSnapped = true;

        }
        else if (gc.ellipticalArc) {

            this.drawArc(gc.ellipticalArc);
            gc.ellipticalArc = null;
        }
        else if (gc.lineGeom.vertices.length) {

            // Determine which one should be drawn: line segment or point
            _radius = this.setDetectRadius(intersectPoint);
            if (intersectPoint.distanceTo(gc.lineGeom.vertices[0]) < _radius) {

                _geomVertex = gc.lineGeom.vertices[0];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else if (intersectPoint.distanceTo(gc.lineGeom.vertices[1]) < _radius) {

                _geomVertex = gc.lineGeom.vertices[1];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else {

                _geomEdge = gc.lineGeom;
                this.drawLine(_geomEdge);
                _geomHighlighted = SNAP_EDGE;
            }

            _viewportIndex2d = gc.vpIdLine;

            _isSnapped = true;
        }

    };

    this.createOverlay = function(overlayName) {

        _viewer.impl.createOverlayScene(overlayName);

    };

    this.addOverlay = function(overlayName, mesh) {

        _viewer.impl.addOverlay(overlayName, mesh);

    };

    this.clearOverlay = function() {

        if (_viewer.impl.overlayScenes[_faceOverlayName]) {
            _viewer.impl.clearOverlay(_faceOverlayName);
        }

        if (_viewer.impl.overlayScenes[_vertexOverlayName]) {
            _viewer.impl.clearOverlay(_vertexOverlayName);
        }

        if (_viewer.impl.overlayScenes[_edgeOverlayName]) {
            _viewer.impl.clearOverlay(_edgeOverlayName);
        }

    };

    /**
     * Draw the planar face
     * @param geom -Geometry which needs to be draw.
     * @param mesh -Mesh which is loaded.
     */
    this.drawFace = function(geom) {

        this.createOverlay(_faceOverlayName);

        var planeColor = 0x00CC00;
        var planeOpacity = 0.5;

        var material = new THREE.MeshPhongMaterial({
            color: planeColor,
            ambient: planeColor,
            opacity: planeOpacity,
            transparent: true,
            depthTest: false,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        //geom.attributes.index.array = new geom.attributes.index.array.constructor(indicesNew);
        var snapperPlane = new THREE.Mesh(geom, material, true);
        //snapperPlane.matrixWorld = mesh.matrixWorld;

        this.addOverlay(_faceOverlayName, snapperPlane);

    };

    this.drawLine = function(geom) {

        this.createOverlay(_edgeOverlayName);

        var material = new THREE.LineBasicMaterial({
            color: 0x00CC00,
            opacity: 0.5,
            linewidth: 5,
            depthTest: false,
            depthWrite: false
        });

        var line = new THREE.Line(geom, material, THREE.LinePieces);
        //line.applyMatrix(mesh.matrixWorld);

        this.addOverlay(_edgeOverlayName, line);
    };

    this.drawArc = function(geom, center) {

        this.createOverlay(_edgeOverlayName);

        var material = new THREE.LineBasicMaterial({
            color: 0x00CC00,
            opacity: 0.5,
            linewidth: 5,
            depthTest: false,
            depthWrite: false
        });

        var arc = new THREE.Line(geom, material);
        if (center) {
            arc.position.set(center.x, center.y, center.z);
        }

        this.addOverlay(_edgeOverlayName, arc);
    };

    this.drawPoint = function(point) {

        this.createOverlay(_vertexOverlayName);

        var planeColor = 0x00CC00;
        var planeOpacity = 0.5;

        var material = new THREE.MeshPhongMaterial({
            color: planeColor,
            ambient: planeColor,
            opacity: planeOpacity,
            transparent: true,
            depthTest: false,
            depthWrite: false
        });

        var pointMesh = new THREE.Mesh(new THREE.SphereGeometry(1.0), material);
        //point.applyMatrix4(mesh.matrixWorld);
        pointMesh.position.set(point.x, point.y, point.z);

        this.setPointScale(pointMesh);

        this.addOverlay(_vertexOverlayName, pointMesh);

    };

    this.setPointScale = function (pointMesh) {

        var pixelSize = 5;

        var navapi = _viewer.navigation;
        var camera = navapi.getCamera();

        var view = navapi.getEyeVector();
        var position = navapi.getPosition();

        var point = pointMesh.position.clone();

        var distance = camera.isPerspective ? point.sub(position).dot(view.normalize())
            : navapi.getEyeVector().length();

        var fov = navapi.getVerticalFov();
        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

        var viewport = navapi.getScreenViewport();
        var devicePixelRatio = window.devicePixelRatio || 1;
        var scale = pixelSize * worldHeight / (viewport.height * devicePixelRatio);

        pointMesh.scale.x = scale;
        pointMesh.scale.y = scale;
        pointMesh.scale.z = scale;

    };

    this.updatePointScale = function() {

        var overlay = _viewer.impl.overlayScenes[_vertexOverlayName];
        if (overlay) {
            var scene = overlay.scene;

            for (var i = 0; i < scene.children.length; i++) {
                var pointMesh = scene.children[i];
                if (pointMesh) {

                    this.setPointScale(pointMesh);
                }
            }
        }
    };

    this.setDetectRadius = function(point) {

        var pixelSize = 1.5;

        var navapi = _viewer.navigation;
        var camera = navapi.getCamera();

        var view = navapi.getEyeVector();
        var position = navapi.getPosition();

        var p = point.clone();

        var distance = camera.isPerspective ? p.sub(position).dot(view.normalize())
            : navapi.getEyeVector().length();

        var fov = navapi.getVerticalFov();
        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

        var viewport = navapi.getScreenViewport();
        var devicePixelRatio = window.devicePixelRatio || 1;
        var radius = pixelSize * worldHeight / (viewport.height * devicePixelRatio);

        if (_viewer.impl.is2d) {
            radius *= 10;
        }

        return radius;
    };

    this.drawIntersectFace = function(face, positions, stride, mesh) {

        this.createOverlay();

        var va = new THREE.Vector3();
        va.set(
            positions[ face.a * stride ],
            positions[ face.a * stride + 1 ],
            positions[ face.a * stride + 2 ]
        );
        var vb = new THREE.Vector3();
        vb.set(
            positions[ face.b * stride ],
            positions[ face.b * stride + 1 ],
            positions[ face.b * stride + 2 ]
        );
        var vc = new THREE.Vector3();
        vc.set(
            positions[ face.c * stride ],
            positions[ face.c * stride + 1 ],
            positions[ face.c * stride + 2 ]
        );

        var intersectFace = new THREE.Geometry();
        intersectFace.vertices.push(va);
        intersectFace.vertices.push(vb);
        intersectFace.vertices.push(vc);
        intersectFace.faces.push(new THREE.Face3(0, 1, 2));

        var faceMesh = new THREE.Mesh(intersectFace, mesh.material, true);
        faceMesh.matrixWorld = mesh.matrixWorld;

        this.addOverlay(faceMesh);

    };

    this.handleWheelInput = function (delta) {
        this.updatePointScale();
        return false;
    };

    this.handleButtonDown = function (event, button) {
        _isDragging = true;
        return false;
    };

    this.handleButtonUp = function (event, button) {
        _isDragging = false;
        return false;
    };

    this.handleMouseMove = function (event) {

        if (!_isDragging) {

            if (_snappingNode) {
                
                _viewer.impl.matman().highlightObject2D(_snappingNode.dbId, false);
            }

            this.clearOverlay();

            _geomFace = null;
            _geomEdge = null;
            _geomVertex = null;

            _isSnapped = false;

            var result = _viewer.impl.hitTest(event.canvasX, event.canvasY, false);

            if (result && result.atomID != -1) {
                this.snapping3D(result);

            } else {
                this.atomLabel.classList.remove('visible');
                this.atomLabel.innerHTML = '';
            }
        }
        return false;
    };

    this.destroy = function() {

        this.clearOverlay();

        _viewer.impl.removeOverlayScene(_faceOverlayName);
        _viewer.impl.removeOverlayScene(_vertexOverlayName);
        _viewer.impl.removeOverlayScene(_edgeOverlayName);

    };

};
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Section');

/**
 * SectionExtension adds UI elements for section analysis
 */
Autodesk.Viewing.Extensions.Section.SectionExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
    this.viewer = viewer;
    this.app = options.app;

};

Autodesk.Viewing.Extensions.Section.SectionExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.constructor = Autodesk.Viewing.Extensions.Section.SectionExtension;

Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.load = function() {
    var self = this;
    var viewer = this.viewer;

    this.tool = new Autodesk.Viewing.Extensions.Section.SectionTool(viewer);
    viewer.toolController.registerTool(this.tool);

    if (!self.app.Loader.options.headless && self.app.ViewManager.getTopView('InspectorView')) {
        self.createUI();
    } else {
        this.viewer.addEventListener(Autodesk.Viewing.INSPECTOR_LOADED, onModelLoaded);
    }

    function onModelLoaded() {
        if (!self.app.Loader.options.headless) {
            self.createUI();
        }
    }

    viewer.addEventListener(Autodesk.Viewing.RESET_EVENT, function () {
        if (self.tool) {
            self.tool.resetSection();
        }
    });

    viewer.addEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT, function () {
        if (self.tool && self.tool.isActive()) {
            self.tool.resetSection();
        }
    });

    viewer.addEventListener(Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT, function(event) {
        if(self.tool && self.tool.isActive()) {
            self.tool.hideControls();
        }
    });

    this.HOTKEYS_ID = "Autodesk.Section.Hotkeys";
    var hotkeys = [{
        keycodes: [
            Autodesk.Viewing.theHotkeyManager.KEYCODES.ESCAPE
        ],
        onRelease: function () {
            return self.enableSectionTool(false);
        }
    }];
    Autodesk.Viewing.theHotkeyManager.pushHotkeys(this.HOTKEYS_ID, hotkeys);

    return true;
};

Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.enableSectionTool = function(enable) {
    if (this.tool) {
        var toolController = this.viewer.toolController,
            isActive = this.tool.isActive();

        if (enable && !isActive) {
            toolController.activateTool("section");
            this.sectionToolButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
            return true;

        } else if (!enable && isActive) {
            toolController.deactivateTool("section");
            this.sectionToolButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
            return true;
        }
    }
    return false;
};

Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.createUI = function()
{
    var viewer = this.viewer;
    var self = this;
    var AVU = Autodesk.Viewing.UI;

    this.sectionToolButton = new AVU.InspectorComboButton("sectionTool", {app: this.app});
    this.sectionToolButton.setToolTip('Section analysis');
    this.sectionToolButton.setIcon("icon-section-analysis");
    this.sectionToolButton.icon.innerHTML = 'Cut';
    this.createSubmenu(this.sectionToolButton);

    this.app.ViewManager.getTopView('InspectorView').getToolSet().addControl(this.sectionToolButton, {index:1});
};

Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.createSubmenu = function(parentButton)
{
    var self = this;
    var viewer = this.viewer;
    var AVU = Autodesk.Viewing.UI;

    function createNavToggler(button, name) {
        return function() {
            var state = button.getState();
            if (state === AVU.Button.State.INACTIVE) {
                button.setState(AVU.Button.State.ACTIVE);
                self.enableSectionTool(true);
                if (this instanceof AVU.ComboButton === false) {
                    self.tool.setSection(name);
                } else {
                    self.tool.attachControl(true);
                }
            } else if (state === AVU.Button.State.ACTIVE) {
                button.setState(AVU.Button.State.INACTIVE);
                self.enableSectionTool(false);
            }
        };
    }

    function updateSectionButtons() {
        var areVectorsEqual = (function () {
            var v = new THREE.Vector3();
            return function(a, b, sqtol) {
                v.subVectors(a, b);
                return v.lengthSq() < sqtol;
            };
        })();

        var unitx = new THREE.Vector3(1, 0, 0);
        var unity = new THREE.Vector3(0, 1, 0);
        var unitz = new THREE.Vector3(0, 0, 1);
        var right = viewer.autocam.getWorldRightVector();
        var up = viewer.autocam.getWorldUpVector();
        var front = viewer.autocam.getWorldFrontVector();

        var tol = 0.0001;
        if (areVectorsEqual(up, unitx, tol)) {
            self.sectionYButton.setIcon("icon-plane-x");
        } else if (areVectorsEqual(up, unitz, tol)) {
            self.sectionYButton.setIcon("icon-plane-z");
        } else {
            self.sectionYButton.setIcon("icon-plane-y");
        }

        if (areVectorsEqual(right, unity, tol)) {
            self.sectionXButton.setIcon("icon-plane-y");
        } else if (areVectorsEqual(right, unitz, tol)) {
            self.sectionXButton.setIcon("icon-plane-z");
        } else {
            self.sectionXButton.setIcon("icon-plane-x");
        }

        if (areVectorsEqual(front, unitx, tol)) {
            self.sectionZButton.setIcon("icon-plane-x");
        } else if (areVectorsEqual(front, unity, tol)) {
            self.sectionZButton.setIcon("icon-plane-y");
        } else {
            self.sectionZButton.setIcon("icon-plane-z");
        }

        viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, updateSectionButtons);
    }
    var buttonText;
    var sectionXButton = this.sectionXButton = new AVU.ListButton("sectionTool-x", {app: this.app});
    buttonText = document.createTextNode('Left - Right');
    sectionXButton.setToolTip('Add X plane');
    sectionXButton.setIcon("icon-plane-x");
    sectionXButton.container.appendChild(buttonText);
    sectionXButton.onClick = createNavToggler(sectionXButton, 'X');
    parentButton.addControl(sectionXButton);

    var sectionYButton = this.sectionYButton = new AVU.ListButton("sectionTool-y", {app: this.app});
    buttonText = document.createTextNode('Top - Bottom');
    sectionYButton.setToolTip('Add Y plane');
    sectionYButton.setIcon("icon-plane-y");
    sectionYButton.container.appendChild(buttonText);
    sectionYButton.onClick = createNavToggler(sectionYButton, 'Y');
    parentButton.addControl(sectionYButton);

    var sectionZButton = this.sectionZButton = new AVU.ListButton("sectionTool-z", {app: this.app});
    buttonText = document.createTextNode('Front - Back');
    sectionZButton.setToolTip('Add Z plane');
    sectionZButton.setIcon("icon-plane-z");
    sectionZButton.container.appendChild(buttonText);
    sectionZButton.onClick = createNavToggler(sectionZButton, 'Z');
    parentButton.addControl(sectionZButton);

    var sectionBoxButton = this.sectionBoxButton = new AVU.ListButton("sectionTool-box", {app: this.app});
    buttonText = document.createTextNode('Box');
    sectionBoxButton.setToolTip('Add box');
    sectionBoxButton.setIcon("icon-box");
    sectionBoxButton.container.appendChild(buttonText);
    sectionBoxButton.onClick = createNavToggler(sectionBoxButton, 'BOX');
    parentButton.addControl(sectionBoxButton);

    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, updateSectionButtons);
};

Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.destroyUI = function()
{
    var viewer = this.viewer;

    var toolset = this.app.ViewManager.getTopView('InspectorView').getToolSet();
    if (toolset) {
        if (this.sectionToolButton) {
            toolset.removeControl(this.sectionToolButton.getId());
        }
        this.sectionToolButton = null;
    }
};

Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // remove hotkey
    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);

    this.destroyUI();

    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Section', Autodesk.Viewing.Extensions.Section.SectionExtension);
;AutodeskNamespace('Autodesk.Viewing.Extensions.Section');


Autodesk.Viewing.Extensions.Section.tintColor = { r: 1, g: 1, b: 0 };
Autodesk.Viewing.Extensions.Section.tintIntensity = 0.2;


/**
 * Tool that provides visual controls for the user to change the cutplane's position and angle.
 * It can (and should) be hooked to [ToolController's registerTool]{@Autodesk.Viewing.ToolController#registerTool}
 *
 * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer3D instance
 * @param {Object} [options] - This component is not customizable.
 * @constructor
 */
Autodesk.Viewing.Extensions.Section.SectionTool = function(viewer, options)
{
    var _viewer  = viewer.impl;

    var _names = ["section"];
    var _active = false;

    var _isDragging = false;
    var _isPlaneOn = true;

    var _transRotControl;
    var _transControl;
    var _sectionGroups = [];
    var _sectionPlanes = [];
    var _sectionPicker = [];
    var _activeMode = "";
    var _overlayName = "gizmo";
    var _touchType = null;
    var _initialized = false;
    var _visibleAtFirst = true;
    var _outlineIndices = [[0, 1], [1, 3], [3, 2], [2, 0]];
    var AVES = Autodesk.Viewing.Extensions.Section;
    
    init_TransformGizmos();
    init_SectionMesh();

    function initControl() {

        if (_initialized)
            return;

        _transRotControl = new THREE.TransformControls(_viewer.camera, _viewer.canvas, "transrotate");
        this.transRotControl = _transRotControl;
        _transRotControl.addEventListener('change', updateViewer);
        _transRotControl.setSnap(Math.PI/2, Math.PI/36); // snap to 90 degs within 5 degs range 

        _transControl = new THREE.TransformControls(_viewer.camera, _viewer.canvas, "translate");
        _transControl.addEventListener('change', updateViewer);

        // add to overlay scene
        if (_viewer.overlayScenes[_overlayName] === undefined) {
            _viewer.createOverlayScene(_overlayName);
        }
        _viewer.addOverlay(_overlayName, _transRotControl);
        _viewer.addOverlay(_overlayName, _transControl);

        viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, updateControls);
        viewer.addEventListener(Autodesk.Viewing.ISOLATE_EVENT, updateSections);
        viewer.addEventListener(Autodesk.Viewing.HIDE_EVENT, updateSections);
        viewer.addEventListener(Autodesk.Viewing.SHOW_EVENT, updateSections);
        _initialized = true;
    }

    function deinitControl() {
        
        if (!_initialized)
            return;
    
        _viewer.removeOverlay(_overlayName, _transRotControl);
        _transRotControl.removeEventListener('change', updateViewer);
        _transRotControl = null;
        _viewer.removeOverlay(_overlayName, _transControl);
        _transControl.removeEventListener('change', updateViewer);
        _transControl = null;
        _viewer.removeOverlayScene(_overlayName);

        viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, updateControls);
        viewer.removeEventListener(Autodesk.Viewing.ISOLATE_EVENT, updateSections);
        viewer.removeEventListener(Autodesk.Viewing.HIDE_EVENT, updateSections);
        viewer.removeEventListener(Autodesk.Viewing.SHOW_EVENT, updateSections);
        _initialized = false;
    }

    function updateViewer() {
        _viewer.invalidate(false, false, true);
    }

    function updateControls() {
        if (_transRotControl) {
            _transRotControl.update();
        }
        if (_transControl) {
            _transControl.update();
        }
    }

    function updateSections() {
        if (_sectionPlanes.length === 1) {
            updatePlaneMeshes(true);
            updateControls();
            updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
        }
    }

    function mix(a, b, val) {
        return a * (1.0 - val) + b * val;
    }
    
    function getDiffuseColor(material) {
       return material.color || new THREE.Color(0xffffff);
    }

    function getSpecularColor(material) {
        return material.specular || new THREE.Color(0xffffff);
    }

    function tintColor(c) {
        var intensity = Autodesk.Viewing.Extensions.Section.tintIntensity;
        var tc = Autodesk.Viewing.Extensions.Section.tintColor;
        c.r = mix(c.r, tc.r, intensity);
        c.g = mix(c.g, tc.g, intensity);
        c.b = mix(c.b, tc.b, intensity);
    }
    
    function updateCapMeshes(plane) {

        init_three_triangulator();
        init_three_intersector();
    

        var oldsection = _viewer.sceneAfter.getObjectByName("section");
        if (oldsection)
            _viewer.sceneAfter.remove(oldsection);
            
        var section = new THREE.Object3D();
        section.name = "section";
        _viewer.sceneAfter.add(section);
        
        var section3D = new THREE.Object3D();
        section.add(section3D);
        var section2D = new THREE.Object3D();
        section.add(section2D);

        var avp = Autodesk.Viewing.Private;


        var toPlaneCoords = avp.Intersector.makePlaneBasis(plane);
        var fromPaneCoords = new THREE.Matrix4().getInverse(toPlaneCoords);

        var mat2dname = _viewer.matman().create2DMaterial(null, {skipCircles:true, skipEllipticals:true}, false, false);
        var mat2d = _viewer.matman().findMaterial(null, mat2dname);
        mat2d.transparent = true;
        mat2d.depthTest = true;
        mat2d.polygonOffset = true;
        mat2d.polygonOffsetFactor = -1;
        mat2d.polygonOffsetUnits = 0.1;    // 1.0 is usually way too high, see LMV-1072

        var box = new THREE.Box3();

        var worldBox = _viewer.getVisibleBounds(true);   
        
        //some heuristic for line width of the section outline based on model size
        //half a percent of the model size is what we do here.
        var lineWidth = 0.5 * 5e-5 * worldBox.size().length();

        var models = _viewer.modelQueue().getModels();

        models.forEach(function(model) {

            var it = model.getData().instanceTree;
            if (!it)
                return;
            var frags = model.getFragmentList();

            //We have to go node by node and combine the fragments for each node into
            //a single 2D slice polygon.
            it.enumNodeChildren(model.getRootId(), function(dbId) {

                if (it.isNodeHidden(dbId) || it.isNodeOff(dbId)) {
                    return;
                }

                var intersects = [];
                var m;

                //All fragments that belong to the same node make part of the
                //same object so we have to accumulate all their intersections into one list
                it.enumNodeFragments(dbId, function(fragId) {

                    frags.getWorldBounds(fragId, box);
                    if (!avp.Intersector.intersectBoxPlane(plane, box))
                        return;

                    m = frags.getVizmesh(fragId);

                    if (!m.geometry)
                        return;
                    if (m.geometry.is2d || m.geometry.isLines)
                        return;
                    if (!m.material.cutplanes)
                        return;

                    avp.Intersector.intersectMeshPlane(plane, m, intersects);

                 }, false);


                if (intersects.length) {

                    var bbox = new THREE.Box3();
                    avp.Intersector.convertToPlaneCoords(toPlaneCoords, intersects, bbox);

                    //Create the 2D line geometry
                    var vbb = new avp.VertexBufferBuilder(false, 8 * intersects.length);

                    var color = getDiffuseColor(m.material);
                    var r = 0|(color.r * 0.25)*255.5;
                    var g = 0|(color.g * 0.25)*255.5;
                    var b = 0|(color.b * 0.25)*255.5;

                    var c = 0xff000000 | (b<<16) | (g<<8) | r;

                    var cset = new avp.Triangulator.ContourSet(intersects, bbox);
                    cset.snapEdges();
                    cset.sanitizeEdges();
                    cset.stitchContours();

                    for (var j=0; j<cset.contours.length; j++) {

                        var cntr = cset.contours[j];

                        var r = 0|Math.random()*255.5;
                        var g = 0|Math.random()*255.5;
                        var b = 0|Math.random()*255.5;
                        var rc = 0xff000000 | (b<<16) | (g<<8) | r;

                        var isClosed = (cntr[0] === cntr[cntr.length-1]);

                        for (var k=1; k<cntr.length; k++) {
                            var pt1 = cset.pts[cntr[k-1]];
                            var pt2 = cset.pts[cntr[k]];
                            vbb.addSegment(pt1.x, pt1.y, pt2.x, pt2.y, 0, 0.02, /*isClosed ? c : rc*/c, dbId, 0);
                        }

                    }


                    var mdata = { mesh: vbb.toMesh() };

                    avp.BufferGeometryUtils.meshToGeometry(mdata);

                    var bg2d = mdata.geometry;
                    bg2d.streamingDraw = true;
                    bg2d.streamingIndex = true;

                    var mesh2d = new THREE.Mesh(bg2d, mat2d);

                    mesh2d.matrix.copy(fromPaneCoords);
                    mesh2d.matrixAutoUpdate = false;
                    mesh2d.frustumCulled = false;
                    section2D.add(mesh2d);


                    //Create triangulated capping polygon
                    if (true) {

                        //Create the 3D mesh
                        var tin = new avp.Triangulator.TriangulatedSurface(cset);

                        if (tin.indices.length) {

                            var bg = new THREE.BufferGeometry();

                            var pos = new Float32Array(3*tin.pts.length);
                            for (var j=0; j<tin.pts.length; j++) {
                                pos[3*j] = tin.pts[j].x;
                                pos[3*j+1] = tin.pts[j].y;
                                pos[3*j+2] = 0;
                            }
                            bg.addAttribute("position", new THREE.BufferAttribute(pos, 3));

                            var packNormals = m.material.packedNormals;
                            var normal = packNormals ? new Uint16Array(2*tin.pts.length) : new Float32Array(3*tin.pts.length);

                            for (var j=0; j<tin.pts.length; j++) {

                                if (packNormals) {
                                    var pnx = (0/*Math.atan2(0, 0)*/ / Math.PI + 1.0) * 0.5;
                                    var pny = (1.0 + 1.0) * 0.5;

                                    normal[j*2] = (pnx * 65535)|0;
                                    normal[j*2+1] = (pny * 65535)|0;
                                } else {
                                    normal[3*j] = 0;
                                    normal[3*j+1] = 0;
                                    normal[3*j+2] = 1;
                                }
                            }

                            bg.addAttribute("normal", new THREE.BufferAttribute(normal, packNormals ? 2 : 3));
                            if (packNormals) {
                                bg.attributes.normal.bytesPerItem = 2;
                                bg.attributes.normal.normalize = true;
                            }

                            var index = new Uint16Array(tin.indices.length);
                            index.set(tin.indices);

                            bg.addAttribute("index", new THREE.BufferAttribute(index, 1));

                            bg.streamingDraw = true;
                            bg.streamingIndex = true;

                            var mat = _viewer.matman().cloneMaterial(m.material);

                            mat.packedNormals = packNormals;
                            mat.cutplanes = null;
                            mat.side = THREE.FrontSide;
                            mat.depthTest = true;
                            mat.map = null;
                            mat.bumpMap = null;
                            mat.normalMap = null;
                            mat.alphaMap = null;
                            mat.specularMap = null;
                            mat.transparent = false;
                            mat.depthWrite = true;
                            mat.hatchPattern = true;
                            mat.needsUpdate = true;

                            var angle = (m.material.id+2) * Math.PI * 0.125;
                            var tan = Math.tan(angle);
                            mat.hatchParams = new THREE.Vector2(tan, 10.0);
                            mat.hatchTintColor = Autodesk.Viewing.Extensions.Section.tintColor;
                            mat.hatchTintIntensity = Autodesk.Viewing.Extensions.Section.tintIntensity;

                            // If the material is prism, clear all the map definitions.
                            if (mat.prismType != null) {
                                mat.defines = {};
                                mat.defines[mat.prismType.toUpperCase()] = "";
                                if (mat.prismType == "PrismWood") {
                                    mat.defines["NO_UVW"] = "";
                                }
                            }

                            var capmesh = new THREE.Mesh(bg, mat);
                            capmesh.matrix.copy(fromPaneCoords);
                            capmesh.matrixAutoUpdate = false;
                            capmesh.dbId = dbId;
                            capmesh.fragId = intersects.fragId;

                            section3D.add(capmesh);
                        }

                    }

                }


            }, true); //enumNodeChildren

        }); //models.forEach

    }

    function createPlaneMesh(plane, bbox) {
        var quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), plane.normal);
        var geometry;

        if (bbox) {
            // project bbox to set plane size
            var ptMax = plane.projectPoint(bbox.max);
            var ptMin = plane.projectPoint(bbox.min);
            var invQuat = quat.clone().inverse();
            ptMax.applyQuaternion(invQuat);
            ptMin.applyQuaternion(invQuat);
            var size = new THREE.Vector3().subVectors(ptMax, ptMin);
            geometry = new THREE.PlaneBufferGeometry(size.x, size.y);
        } else {
            // project bounding sphere
            bbox = _viewer.getVisibleBounds();
            var size = 2.0 * bbox.getBoundingSphere().radius;
            geometry = new THREE.PlaneBufferGeometry(size, size);
        }

        var material = new THREE.MeshBasicMaterial({
            opacity: 0,
            color: 0xffffff,
            side: THREE.DoubleSide,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });

        var mesh = new AVES.SectionMesh(geometry, material, plane);
        var pt = plane.projectPoint(bbox.center());       
        mesh.position.copy(pt);
        mesh.quaternion.multiply(quat);

        // add outlines with inverted background color
        var bgColor = Autodesk.Viewing.Private.LightPresets[_viewer.currentLightPreset()].bgColorGradient;
        var color = "rgb(" + (255-bgColor[0]) + "," + (255-bgColor[1]) + "," + (255-bgColor[2]) + ")";
        var lineMaterial = new THREE.LineBasicMaterial({color: color, linewidth:1, depthTest: false});
        var pos = mesh.geometry.getAttribute('position');
        for (var i = 0; i < _outlineIndices.length; i++) {
            var geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3().fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize),
                                   new THREE.Vector3().fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize));
            var line = new THREE.Line(geometry, lineMaterial);
            mesh.add(line);
            mesh.outlines.push(line);
        }

        return mesh;
    }

    function updatePlaneMeshes(rebuild) {
    
        traverseSections(function(child) {
            if (child instanceof AVES.SectionMesh) {

                if (child.connectivity.length > 0) {
                    // section box
                    var minv = new THREE.Matrix4().getInverse(child.matrixWorld);
                    var pt = new THREE.Vector3();
                    var pos = child.geometry.getAttribute('position');
                    for (var i = 0; i < pos.length / pos.itemSize; i++) {
                        var connect = child.connectivity[i];
                        if (intersectPlanes(child.plane, connect[0], connect[1], pt) !== null) {
                            pt.applyMatrix4(minv);
                            pos.setXYZ(i, pt.x, pt.y, pt.z);
                        }
                    };
                    pos.needsUpdate = true;
                    child.geometry.computeBoundingBox();
                    child.geometry.computeBoundingSphere();

                    for (var i = 0; i < child.outlines.length; i++) {
                        var line = child.outlines[i];
                        line.geometry.vertices[0].fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize);
                        line.geometry.vertices[1].fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize);
                        line.geometry.verticesNeedUpdate = true;
                    }
                } else {
                    // section plane
                    if (rebuild) {
                        var bbox = _viewer.getVisibleBounds();
                        var size = 2.0 * bbox.getBoundingSphere().radius;
                        var pt = child.plane.projectPoint(bbox.center());
                        child.geometry = new THREE.PlaneBufferGeometry(size, size);
                        child.position.copy(pt);
                        var pos = child.geometry.getAttribute('position');
                        for (var i = 0; i < child.outlines.length; i++) {
                            var line = child.outlines[i];
                            line.geometry.vertices[0].fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize);
                            line.geometry.vertices[1].fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize);
                            line.geometry.verticesNeedUpdate = true;
                        }
                    }
                }
            }
        });
    }

    function traverseSections(callback) {
        for (var i = 0; i < _sectionGroups.length; i++) {           
            _sectionGroups[i].traverse(callback);
        }
    }

    function setSectionPlanes() {
        traverseSections(function(child) {
            if (child instanceof AVES.SectionMesh) {
                child.update();
            }
        });
        if (_sectionPlanes.length === 1) {
            updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
        }
        _viewer.setCutPlanes(_sectionPlanes);
    }

    function showPlane(set) {
        for (var i = 0; i < _sectionGroups.length; i++) {
            _sectionGroups[i].visible = set;
        }
        
        if (_isPlaneOn !== set)
            updateViewer();

        _isPlaneOn = set;
    }

    function showSection(set) {
        if (set && _sectionPlanes.length > 0) {
            if (_sectionPlanes.length === 1) {
                updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
            }
            viewer.setCutPlanes(_sectionPlanes);
        }
        showPlane(set);
    }

    function attachControl(control, mesh) {
        control.attach(mesh);
        control.setPosition(mesh.position);
        control.visible = true;
    }

    function setPlane(normal) {
        // flip normal if facing inward as eye direction
        var eyeVec = _viewer.api.navigation.getEyeVector();
        if (eyeVec.dot(normal) > 0) {
            normal.negate();
        }

        // create cut plane equation; position the plane at the object's center.
        var pivotPoint = _viewer.camera.pivot;
        var d = -normal.dot(pivotPoint);
        var plane = new THREE.Plane(normal, d);
        
        var mesh = createPlaneMesh(plane, null, 0.05); // apply 5% margin
        var group = new THREE.Group();
        group.add(mesh);

        _sectionPlanes.push(mesh.planeVec);
        _sectionGroups.push(group);
        _viewer.addOverlay(_overlayName, group);
        attachControl(_transRotControl, mesh);
        _transRotControl.showRotationGizmos(true);
        _sectionPicker = _transRotControl.getPicker();
        setSectionPlanes();
    }

    function setBox() {
        var normals = [
            new THREE.Vector3(1, 0, 0), 
            new THREE.Vector3(0, 1, 0), 
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(-1, 0, 0),
            new THREE.Vector3(0, -1, 0),
            new THREE.Vector3(0, 0, -1)
        ];

        var connectivities = [
            [[1, 2], [1, 5], [2, 4], [4, 5]], // 0
            [[3, 5], [0, 5], [2, 3], [0, 2]], // 1
            [[1, 3], [0, 1], [3, 4], [0, 4]], // 2
            [[1, 5], [1, 2], [4, 5], [2, 4]], // 3
            [[2, 3], [0, 2], [3, 5], [0, 5]], // 4
            [[0, 1], [3, 1], [0, 4], [3, 4]]  // 5
        ];

        var group = new THREE.Group();
        var obbox = _viewer.getVisibleBounds();
        var center = obbox.center();
        var bbox = new THREE.Box3(obbox.min, center);
        var planes = [], meshes = [];
        for (var i = 0; i < normals.length; i++) {
            var plane = new THREE.Plane(normals[i], -1 * center.dot(normals[i]));
            planes.push(plane);

            // offset plane with negative normal to form an octant
            if (i > 2) {
                var ptMax = plane.orthoPoint(bbox.max);
                var ptMin = plane.orthoPoint(bbox.min);
                var size = new THREE.Vector3().subVectors(ptMax, ptMin);
                plane.constant -= size.length();                
            }

            var mesh = createPlaneMesh(plane, bbox);
            group.add(mesh);
            meshes.push(mesh);
            _sectionPlanes.push(mesh.planeVec);
        }

        // build connectivity
        for (var i = 0; i < meshes.length; i++) {
            var mesh = meshes[i];
            var connectivity = connectivities[i];
            for (var j = 0; j < connectivity.length; j++) {
                var nc = [];
                var ct = connectivity[j];
                for (var k = 0; k < ct.length; k++) {
                    nc.push(planes[ct[k]]);
                }
                mesh.connectivity.push(nc);
            }
        }
        
        _sectionGroups.push(group);
        _viewer.addOverlay(_overlayName, group);

        attachControl(_transRotControl, _sectionGroups[0].children[0]);
        attachControl(_transControl, _sectionGroups[0]);
        _transRotControl.showRotationGizmos(false);
        _sectionPicker = _transRotControl.getPicker().concat(_transControl.getPicker());

        setSectionPlanes();
    }

    var intersectPlanes = (function () {
        var m = new THREE.Matrix3();
        var n23 = new THREE.Vector3();
        var n31 = new THREE.Vector3();
        var n12 = new THREE.Vector3();
        return function(plane1, plane2, plane3, optionalTarget) {
            m.set(plane1.normal.x, plane1.normal.y, plane1.normal.z,
                  plane2.normal.x, plane2.normal.y, plane2.normal.z,
                  plane3.normal.x, plane3.normal.y, plane3.normal.z);
            
            var det = m.determinant();
            if (det === 0) return null;

            n23.crossVectors(plane2.normal, plane3.normal).multiplyScalar(-plane1.constant);
            n31.crossVectors(plane3.normal, plane1.normal).multiplyScalar(-plane2.constant);
            n12.crossVectors(plane1.normal, plane2.normal).multiplyScalar(-plane3.constant);

            var result = optionalTarget || new THREE.Vector3();
            return result.copy(n23).add(n31).add(n12).divideScalar(det);
        };
    })();

    var intersectObjects = (function () {
        var pointerVector = new THREE.Vector3();
        var pointerDir = new THREE.Vector3();
        var ray = new THREE.Raycaster();
        var camera = _viewer.camera;

        return function(pointer, objects, recursive) {
            var rect = _viewer.canvas.getBoundingClientRect();
            var x = ((pointer.clientX - rect.left) / rect.width) * 2 - 1;
            var y = - ((pointer.clientY - rect.top) / rect.height) * 2 + 1;
            
            if (camera.isPerspective) {
                pointerVector.set(x, y, 0.5);
                pointerVector.unproject(camera);
                ray.set(camera.position, pointerVector.sub(camera.position).normalize());
            } else {
                pointerVector.set(x, y, -1);
                pointerVector.unproject(camera);
                pointerDir.set(0, 0, -1);
                ray.set(pointerVector, pointerDir.transformDirection(camera.matrixWorld));
            }

            var intersections = ray.intersectObjects(objects, recursive);
            return intersections[0] ? intersections[0] : null;
        };
    })();

    // public functions

    /**
     * When active, the geometry will be sectioned by the current set cut plane.
     * @returns {boolean}
     */
    this.isActive = function() {
        return _active;
    };

    /**
     * Facilitates the initialization of a cut plane
     *
     * @param {String} name - Either 'X', 'Y', 'Z' or 'BOX'
     */
    this.setSection = function(name) {
        this.clearSection();
        switch (name) {
            case 'X':
                var normal = new THREE.Vector3(1, 0, 0);
                setPlane(normal);
                break;
            case 'Y':
                var normal = new THREE.Vector3(0, 1, 0);
                setPlane(normal);
                break;
            case 'Z':
                var normal = new THREE.Vector3(0, 0, 1);
                setPlane(normal);
                break;
            case 'BOX':
                setBox();
                break;
        }
        _activeMode = name;
    };

    /**
     * Removes any (and all) currently set cut plane(s).
     */
    this.clearSection = function() {

        if (_transRotControl)
            _transRotControl.detach();

        if (_transControl)
            _transControl.detach();

        // remove all sections
        while(_sectionPlanes.length > 0) {
            _sectionPlanes.pop();
        }

        while(_sectionGroups.length > 0) {
            var group = _sectionGroups.pop();
            _viewer.removeOverlay(_overlayName, group);
        }
        
        var oldsection = _viewer.sceneAfter.getObjectByName("section");
        if (oldsection)
            _viewer.sceneAfter.remove(oldsection);

        _viewer.setCutPlanes();
    };

    this.isPlaneOn = function() {
        return _isPlaneOn;
    };

    this.showPlane = function(set) {
        showPlane(set);
    };

    //turn off controls and plane
    this.hideControls = function() {
        showPlane(false);
        if (_transRotControl) {
            attachControl(false);
        }
    };

    /**
     * Whether translation and rotation controls are visible or not.
     * @param {Boolean} set
     */
    this.attachControl = function(set) {
        if (set) {
            attachControl(_transRotControl, _sectionGroups[0].children[0]);
            _transRotControl.highlight();
            if (_activeMode === 'BOX')
                attachControl(_transControl, _sectionGroups[0]);
        } else {
            _transRotControl.detach();
            _transControl.detach();
        }
    };

    /**
     * Invokes setSection with the last set of parameters used.
     */
    this.resetSection = function() {
        this.setSection(_activeMode);
    };

    // tool interface

    this.getNames = function() {
        return _names;
    };

    this.getName = function() {
        return _names[0];
    };

    this.register = function() {
    };

    this.deregister = function() {
        this.clearSection();
        deinitControl();
    };

    /**
     * [ToolInterface] Activates the tool
     * @param {String} name - unused
     */
    this.activate = function(name) {

        initControl();

        _active = true;
        _isDragging = false;
        _visibleAtFirst = true;

        // keep only one section all the time per design
        _sectionPlanes = _sectionPlanes || [];

        showSection(true);
    };

    /**
     * [ToolInterface] Deactivates the tool
     * @param {String} name - unused
     */
    this.deactivate = function(name) {
        _active = false;
        _isDragging = false;

        var oldsection = _viewer.sceneAfter.getObjectByName("section");
        if (oldsection)
            _viewer.sceneAfter.remove(oldsection);


        showSection(false);
        _viewer.setCutPlanes();
        _transRotControl.detach();
        _transControl.detach();
    };

    this.update = function(highResTimestamp) {
        return false;
    };

    this.handleSingleClick = function(event, button) {
        var pointer = event.pointers ? event.pointers[ 0 ] : event;
        var result = intersectObjects(pointer, _sectionGroups[0].children);
        if (result) {
            attachControl(_transRotControl, result.object);
            _transRotControl.highlight();
            updateViewer();
        }

        return false;
    };

    this.handleDoubleClick = function(event, button) {
        return false;
    };

    this.handleSingleTap = function(event) {
        return this.handleSingleClick(event, 0);
    };

    this.handleDoubleTap = function(event) {
        return false;
    };

    this.handleKeyDown = function(event, keyCode) {
        return false;
    };

     this.handleKeyUp = function(event, keyCode) {
        return false;
    };

    this.handleWheelInput = function(delta) {
        return false;
    };

    this.handleButtonDown = function(event, button) {
        _isDragging = true;
        if (_transControl.onPointerDown(event))
            return true;
        return _transRotControl.onPointerDown(event);
    };

    this.handleButtonUp = function(event, button) {
        _isDragging = false;
        if (_transControl.onPointerUp(event)) 
            return true;
        return _transRotControl.onPointerUp(event);
    };

    this.handleMouseMove = function(event) {
        if (_isDragging) {
            if (_transControl.onPointerMove(event) ) {
                setSectionPlanes();
                _transRotControl.update();
                return true;
            }
            if (_transRotControl.onPointerMove(event)) {
                setSectionPlanes();
                updatePlaneMeshes();
                return true;
            }
        }

        if (event.pointerType !== 'touch') {
            var pointer = event.pointers ? event.pointers[ 0 ] : event;
            var result = intersectObjects(pointer, _sectionGroups[0].children);
            if (result) {
                _visibleAtFirst = false;
            }

            // show gizmo + plane when intersecting on non-touch 
            var visible = _visibleAtFirst || (result || intersectObjects(pointer, _sectionPicker, true)) ? true : false;
            _transRotControl.visible = visible;
            _transControl.visible = _transControl.object !== undefined && visible;
            showPlane(visible);
        }

        if (_transControl.onPointerHover(event))
            return true;

        return _transRotControl.onPointerHover(event);
    };

    this.handleGesture = function(event) {
        switch (event.type) {
            case "dragstart":
                _touchType = "drag";
                // Single touch, fake the mouse for now...
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "dragend":
                if (_touchType === "drag") {
                    _touchType = null;
                    return this.handleButtonUp(event, 0);
                }
                return false;
        }
        return false;
    };

    this.handleBlur = function(event) {
        return false;
    };

    this.handleResize = function() {
    };

    this.handlePressHold = function(event) {
        return true;
    };
};

function init_SectionMesh() {

if (Autodesk.Viewing.Extensions.Section.SectionMesh)
    return;

Autodesk.Viewing.Extensions.Section.SectionMesh = function(geometry, material, plane)
{
    THREE.Mesh.call(this, geometry, material, false);

    this.plane = plane;
    this.planeVec = new THREE.Vector4(plane.normal.x, plane.normal.y, plane.normal.z, plane.constant);
    this.connectivity = [];
    this.outlines = [];
};

Autodesk.Viewing.Extensions.Section.SectionMesh.prototype = Object.create(THREE.Mesh.prototype);
Autodesk.Viewing.Extensions.Section.SectionMesh.prototype.constructor = Autodesk.Viewing.Extensions.Section.SectionMesh;

Autodesk.Viewing.Extensions.Section.SectionMesh.prototype.update = function()
{
    this.plane.normal.set(0, 0, 1);
    this.plane.normal.applyQuaternion(this.quaternion);

    var normal = this.plane.normal;
    var d = -1 * this.getWorldPosition().dot(normal);
    this.planeVec.set(normal.x, normal.y, normal.z, d);
    this.plane.constant = d;
};

}

;/**
 * Created by andrewkimoto on 6/8/16.
 */
var Autodesk = Autodesk || {};
Autodesk.Gallery = function Gallery() {
    this.sources = [];
    this.frames = [];
    this.buttons = [];
};

Autodesk.Gallery.prototype.initialize = function initialize() {
    var xhr = new XMLHttpRequest();
    var self = this;
    var oSource = {};
    var galleryId = this._getGalleryIdFromUrl();
    var callID = THREE.Math.generateUUID();

    xhr.open('GET', '/loadsession/' + galleryId, true);
    xhr.setRequestHeader("Connection-ID", THREE.Math.generateUUID());
    xhr.setRequestHeader("Socket-ID", callID);
    xhr.setRequestHeader("Stack-Trace", 'Gallery.initialize');
    xhr.onload = function(e) {
        if (xhr.status === 200) {
            oSource = JSON.parse(xhr.responseText);
            self.sources = oSource.frames;
            self._initializeElements();
            self._initializeEvents();
        } else {
            console.error('failed',e);
            ApiConnector.displayError('Failed to load gallery data.');
        }
    };
    xhr.send();


};

Autodesk.Gallery.prototype._getGalleryIdFromUrl = function getGalleryIdFromUrl() {
    var url = window.location.href;
    var galleryId = this.getParameterByName('gid');
    if(galleryId === '') {
        galleryId = 'sample-gallery';
    }
    return galleryId;
};

Autodesk.Gallery.prototype._initializeElements = function initializeFrames() {
    var i;

    for (i = 0; i < this.sources.length; ++i) {
        this.buttons[i] = document.createElement('button');
        this.buttons[i].id = 'frameButton' + i;
        this.buttons[i].setAttribute('class','frame-switcher' + (i === 0 ? ' active' : ''));
        this.buttons[i].setAttribute('data-index',i);
        this.buttons[i].style.width = (100/this.sources.length)+'%';
        if(i === this.sources.length -1) {
            this.buttons[i].classList.add('right');
        }
        this.buttons[i].innerHTML = this.sources[i].name;
        this.frames[i] = document.createElement('iframe');
        this.frames[i].id = 'frame-' + i;
        this.frames[i].setAttribute('class', 'viewer-frame' + (i === 0 ? ' active' : ''));
        this.frames[i].src = '/index.html?session='  + this.sources[i].sessionId + '&viewcube=false&nP=true&hB=true&hH=true&hI=true&dB=true&dI=true&tV=mol-gallery-topviews';
        document.body.appendChild(this.buttons[i]);
    }

    for (i = 0; i < this.sources.length; ++i) {
        document.body.appendChild(this.frames[i]);
    }

};

Autodesk.Gallery.prototype._initializeEvents = function initializeEvents() {
    var i;
    var self = this;

    this.switchFrames = function switchFrames(sIndex) {
        var i;
        var index = parseInt(sIndex,10);
        for (i = 0; i < this.frames.length; ++i) {
            if (i === index) {
                self.frames[i].classList.add('active');
                self.buttons[i].classList.add('active');
            } else {
                self.frames[i].classList.remove('active');
                self.buttons[i].classList.remove('active');
            }
        }
    };

    for (i = 0; i < this.buttons.length; ++i) {
        this.buttons[i].addEventListener('click', function(event) {
            var j = event.target.getAttribute('data-index');
            self.switchFrames(j);
        });
    }
};


Autodesk.Gallery.prototype.getParameterByName = function (name) {
    name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
    var url = window.location.href;
    var regexS = "[\\?&]" + name + "=([^&#]*)";
    var regex = new RegExp(regexS);
    var results = regex.exec(url);
    if (results == null)
        return "";
    else
        return decodeURIComponent(results[1].replace(/\+/g, " "));
};
;/**
 * Created by andrewkimoto on 4/13/15.
 */

Autodesk.Viewing.MolViewer.BrowserView = function(args) {
    var me = Autodesk.Viewing.MolViewer.BrowserView.prototype;
    this.viewer = args.viewer;
    this.app = args.app;
    this.molMan = args.app.MolMan;
    this.svfName = args.svfName;
    this.visible = true;
    this.type = 'BrowserView';
    this.animateDirection = 'left';
    this.displayType = 'flex';
    this.flexDirection = 'column';
    this.resizeMin = [90,90];
    this.width = args.width;
    this.parentElement = document.querySelector('#contents' + '-' + this.app.appID);
    this._initialize();
};

Autodesk.Viewing.MolViewer.BrowserView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.BrowserView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.BrowserView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.BrowserView.prototype._initializeElements = function _initializeElements() {
    this.openBrowserButton = document.createElement('div');
    this.openBrowserButton.className = "open-button browse";

    this.openBrowserImage = document.createElement('div');
    this.openBrowserImage.className = "arrow-image";
    this.openBrowserButton.appendChild(this.openBrowserImage);

    this.parentElement.insertBefore(this.openBrowserButton, document.querySelector('#center' + '-' + this.app.appID));

    this.el = document.createElement('DIV');
    this.el.style.flex = '0 0 ' + this.width  + 'px';
    this.el.style.WebkitFlex = '0 0 ' + this.width  + 'px';
    this.el.setAttribute('id','browser-' + this.app.appID);
    this.el.setAttribute('class','browser');

    this.browserHeader = document.createElement('div');
    this.browserHeader.setAttribute('id','browserHeader-' + this.app.appID);
    this.browserHeader.setAttribute('class','browserHeader');
    this.titleDiv = document.createElement('div');
    this.titleDiv.className = "title-div";
    this.modelTitle = document.createElement('div');
    this.modelTitle.setAttribute('class','model-title');
    this.modelTitle.innerHTML = this.svfName;
    this.titleDiv.appendChild(this.modelTitle);
    this.closeButton = document.createElement('div');
    this.closeButton.className = "close-button";
    this.closeImg = document.createElement('div');
    this.closeImg.className = "close-img";
    this.closeButton.appendChild(this.closeImg);
    this.titleDiv.appendChild(this.closeButton);
    this.infoDiv = document.createElement('div');
    this.infoDiv.setAttribute('class','browser-info');
    this.infoButton = document.createElement('div');
    this.infoButton.setAttribute('class','browser-info-button');
    this.infoButton.innerHTML = 'Info';
    this.selectedButton = document.createElement('div');
    this.selectedButton.setAttribute('class','browser-selected-button');
    this.selectedButton.innerHTML = 'Show selected only';
    this.buttonPanel = document.createElement('div');
    this.buttonPanel.setAttribute('class','button-panel');
    this.assemblyDiv = document.createElement('div');
    this.assemblyDiv.setAttribute('id','assemblyDiv-' + this.app.appID);
    this.assemblyDiv.setAttribute('class','assemblyDiv');
    this.assemblyDiv.setAttribute('class','browser-control');
    this.assemblyValue = document.createElement('div');
    this.assemblyValue.setAttribute('class','browser-value');
    this.assemblyValue.innerHTML = 'Asymmetric Unit';
    this.assemblyDiv.appendChild(this.assemblyValue);
    this.browserHeader.appendChild(this.titleDiv);
    this.buttonPanel.appendChild(this.infoButton);
    this.buttonPanel.appendChild(this.selectedButton);
    this.buttonPanel.appendChild(this.assemblyDiv);
    this.browserHeader.appendChild(this.buttonPanel);
    this.browserHeader.appendChild(this.infoDiv);
    this.el.appendChild(this.browserHeader);
    this.browserBody = document.createElement('div');
    this.browserBody.setAttribute('id','browserBody-' + this.app.appID);
    this.browserBody.setAttribute('class','browserBody');
    this.el.appendChild(this.browserBody);
    this.browserFooter = document.createElement('div');
    this.browserFooter.setAttribute('id','browserFooter-' + this.app.appID);
    this.browserFooter.setAttribute('class','browserFooter');
    this.el.appendChild(this.browserFooter);

    this.parentElement.insertBefore(this.el, document.querySelector('#center-' + this.app.appID));
};

Autodesk.Viewing.MolViewer.BrowserView.prototype._initializeEvents = function _initializeEvents() {
    var self = this;

    this.buildScrollbar = function buildScrollbar(e) {
        if(!e || typeof e.modelType === 'string') {
            if (!self.scrollbar) {
                self.scrollbar = new Autodesk.Nano.ScrollView(self, self.browserHeader, self.infoDiv,(self.titleDiv.clientHeight + self.buttonPanel.clientHeight),0);
            }
        }
    };


    this.addDropdownEvents = function addDropdownEvents() {
        var dropDownItems = self.assemblyDropdown.querySelectorAll('.browser-drop-down-item'),
            i,
            id,
            that = this,
            args;

        for (i = 0; i < dropDownItems.length; i++) {
            id = dropDownItems[i].innerHTML.replace(/Assembly /, '');
            id = (dropDownItems[i].innerHTML === 'Asymmetric Unit' ? null : id);
            dropDownItems[i].addEventListener('click', that.switchToAssembly.bind(that, id));
        }
    };

    this.switchToAssembly = function switchToAssembly(id) {
        self.app.ViewManager.getTopView('StatusView').showCustomMessage('Switching to asssembly ' + id +'...');
        self.assemblyDropdown.classList.remove('visible');
        window.setTimeout(function() { //give browser time to show the status view
            self.molMan.molModels[self.molMan.currentMolModelID].switchToAssembly(id); //todo need to fix with multi-model
        },100,id);
    };

    this.switchToAssemblyCB = function switchToAssemblyCB(event) {
        var rootViewName = self.app.ViewManager.getRootView();
        var rootView;
        if(rootViewName) {
            rootView = self.app.ViewManager.findViews(rootViewName)[0];
            self.app.ViewManager.destroyView(rootView,false,false);
            rootView.clearView();
            rootView.itemList.buildItems(rootView.el);
        }
        self.molMan.clearSelection();
        self.updateAssemblyValue();
        self.getInfo();
        self.app.ViewManager.getTopView('StatusView').hide();
    };

    this.updateAssemblyValue = function updateValue() {
        var activeAssembly = self.molMan.molModels[self.molMan.currentMolModelID].getActiveAssembly();
        self.assemblyValue.innerHTML = (activeAssembly === null ? 'Asymmetric Unit' : 'Assembly ' + activeAssembly.assemblyID);
    };

    this.updateTitle = function updateTitle(e) {
        if(!e || e.modelType ==='mol') {
            var md = self.molMan.molModels[self.molMan.currentMolModelID].molMetadata;
            self.modelTitle.innerHTML = md.title; //self.svfName;
            // We need to come up with a better location for this text so disabled for now
            //self.subTitle.innerHTML = md.subTitle;
            self.assemblyDiv.removeChild(self.assemblyValue);
            self.assemblyDiv.setAttribute('class', 'browser-control');
            self.assemblyValue = document.createElement('div');
            self.assemblyValue.setAttribute('class', 'browser-value');
            self.updateAssemblyValue();
            if (self.assemblyDropdown) {
                self.assemblyDiv.removeChild(self.assemblyDropdown);
            }

            self.assemblyDiv.appendChild(self.assemblyValue);
            self.assemblyValue.innerHTML = 'Asymmetric Unit';
            self.assemblyDropdown = self.buildAssemblyDropDown();
            self.assemblyDiv.appendChild(self.assemblyDropdown);
            self.addDropdownEvents();
            self.assemblyValue.addEventListener('click', function () {
                self.assemblyDropdown.classList.add('visible');
                document.addEventListener('click', self.doHideBrowserDropdowns);
            });
        }
    };

    this.doHideBrowserDropdowns = function doHideBrowserDropdowns(event) {
        if (!event.target.classList.contains('browser-value')) {
            self.hideBrowserDropdowns(event);
            document.removeEventListener('click',self.doHideBrowserDropdowns);
        }
    };

    this.hideBrowserDropdowns = function hideBrowserDropdowns(event) {
        var dropDowns = self.el.querySelectorAll('.browser-drop-down'),
            i;

        for (i = 0; i < dropDowns.length; i++) {
            dropDowns[i].classList.remove('visible');
        }
    };

    this.resetScrollBars = function resetScrollBars() {
        var topViews = self.app.ViewManager.topViews;
        var view;
        for (view in topViews) {
            if(topViews.hasOwnProperty(view)) {
                if(topViews[view].scrollbar) {
                    self.resetScrollBar(topViews[view]);
                }
            }
        }
    };

    this.resetScrollBar = function resetScrollBar(view) {
        if (view.scrollbar) {
            view.scrollbar.scrollElement.scrollTop = 0;
            view.scrollbar.scrollThumb.style.top = '0px';
            view.scrollbar.updateScrollbar();
        }


    };

    this.toggleSelected = function toggleSelected() {
        if (self.selectedButton.classList.contains('active')) {
            self.el.classList.remove('selected-only');
            self.selectedButton.innerHTML = 'Show selected only';
            self.selectedButton.classList.remove('active');

        } else {
            self.el.classList.add('selected-only');
            self.selectedButton.innerHTML = 'Showing selected only';
            self.selectedButton.classList.add('active');
        }
        self.resetScrollBars();
    };

    this.toggleInfo = function toggleInfo() {
        var offset;
        if (self.infoButton.classList.contains('active')) {
            self.infoDiv.classList.remove('visible');
            self.browserHeader.style.flex = '';
            self.browserHeader.style.webkitFlex = '';
            self.browserBody.setAttribute('style','');
            self.infoButton.innerHTML = 'Info';
            self.infoButton.classList.remove('active');
            self.viewer.fireEvent(Autodesk.Nano.BROWSER_RESIZED_EVENT);  //forces panelviews to resize
        } else {
            self.infoDiv.classList.add('visible');
            self.browserHeader.style.flex = '0 0 auto';
            self.browserHeader.style.webkitFlex = '0 0 auto';
            offset = self.browserHeader.offsetHeight + self.browserFooter.offsetHeight;
            self.browserBody.style.height = "calc(100% - " + offset + "px)";
            self.infoButton.innerHTML = 'Hide info';
            self.infoButton.classList.add('active');
            self.viewer.fireEvent(Autodesk.Nano.BROWSER_RESIZED_EVENT);  //forces panelviews to resize
        }
        self.resetScrollBars();
    };

    this.getInfo = function getInfo(e) {
        if(!e || e.modelType === 'mol') {
            var title,
                pdbLink,
                entity,
                entityTitle,
                entityIDs,
                entities,
                assemblyName,
                assemblyID,
                entityArray = [],
                offset,
                isAssembly = false,
                i;

            self.infoDiv.innerHTML = '';
            title = document.createElement('div');
            title.setAttribute('class', 'info-title');
            var md = self.molMan.molModels[self.molMan.currentMolModelID].molMetadata;
            title.innerHTML = md.title + ' ' + md.subTitle;
            pdbLink = document.createElement('div');
            pdbLink.setAttribute('class', 'pdb-link');
            pdbLink.innerHTML = '<a target = "_blank" href="http://www.rcsb.org/pdb/explore/explore.do?structureId=' + md.title + '">Open in Protein Databank website ></a>';
            entityTitle = document.createElement('div');
            entityTitle.setAttribute('class', 'entity-title');
            entityTitle.innerHTML = 'Entities';

            //get whether we are looking at the asymmetric unit or an assembly
            if (self.molMan.molModels[self.molMan.currentMolModelID].activeAssembly === null) {
                isAssembly = false;
                assemblyName = 'Asymmetric Unit';
                entityIDs = self.molMan.molModels[self.molMan.currentMolModelID].activeInstances[0].entityIDs;
                entities = self.molMan.molModels[self.molMan.currentMolModelID].entities;
                entityArray = self._buildEntityArray(entityIDs);
            } else {
                isAssembly = true;
                assemblyName = 'Assembly ' + self.molMan.molModels[self.molMan.currentMolModelID].activeAssembly.assemblyID;
                assemblyID = [self.molMan.molModels[self.molMan.currentMolModelID].activeAssembly.assemblyID];
                entityArray = self._buildAssemblyInfo(assemblyID);
            }

            self.infoDiv.appendChild(title);
            self.infoDiv.appendChild(pdbLink);
            self.infoDiv.appendChild(entityTitle);
            for (i = 0; i < entityArray.length; i++) {
                self.infoDiv.appendChild(entityArray[i]);
            }

            if (self.infoButton.classList.contains('active')) {
                offset = self.browserHeader.offsetHeight + self.browserFooter.offsetHeight;
                self.browserBody.style.height = "calc(100% - " + offset + "px)";
            }
        }
    };

    this.toggleBrowser = function toggleBrowser(event) {
        //Autodesk.Viewing.MolViewer.ViewManager2D._instance.toggleBrowser();
        self.app.ViewManager.toggleBrowser();
        self.molMan.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
    };

    this.selectedButton.addEventListener('click', self.toggleSelected);

    this.closeButton.addEventListener('click', self.toggleBrowser);
    this.openBrowserButton.addEventListener('click', self.toggleBrowser);

    this.infoButton.addEventListener('click', self.toggleInfo);


    this.browserResizedCB = self.updateWidth.bind(self);

    this._bindEvents = function _bindEvents() {
        self.viewer.addEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, self.updateTitle);
        self.viewer.addEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, self.getInfo);
        self.viewer.addEventListener(Autodesk.Viewing.BROWSER_RESIZED_EVENT, self.browserResizedCB);
        self.viewer.addEventListener(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED, self._unbindEvents);
        self.viewer.addEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT,self.switchToAssemblyCB);
        if(self.scrollbar) {
            self.scrollbar.updateViewer(self.viewer);
        } else {
            self.viewer.addEventListener(Autodesk.Nano.MODEL_START_LOADED_EVENT, self.buildScrollbar);
        }
    };

    this._unbindEvents = function _unbindEvents() {
        self.viewer.removeEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, self.updateTitle);
        self.viewer.removeEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, self.getInfo);
        self.viewer.removeEventListener(Autodesk.Viewing.BROWSER_RESIZED_EVENT, self.browserResizedCB);
        self.viewer.removeEventListener(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED, self._unbindEvents);
        self.viewer.removeEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT, self.switchToAssemblyCB);
        self.viewer.removeEventListener(Autodesk.Nano.MODEL_START_LOADED_EVENT, self.buildScrollbar);
    };

    this.viewer.addEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, self.updateTitle);
    this.viewer.addEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, self.getInfo);
    this.viewer.addEventListener(Autodesk.Viewing.BROWSER_RESIZED_EVENT, self.browserResizedCB);
    this.viewer.addEventListener(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED, self._unbindEvents);
    this.viewer.addEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT,self.switchToAssemblyCB);
    this.viewer.addEventListener(Autodesk.Nano.MODEL_START_LOADED_EVENT, self.buildScrollbar);

};

Autodesk.Viewing.MolViewer.BrowserView.prototype.updateWidth = function updateWidth() {
    var vm2d = this.app.ViewManager;
    var panelViews = this.app.container.querySelectorAll('.panelView');
    if(panelViews.length === 0) {
        return;
    }
    var i;
    var totalWidth = 33; //handles width of resizers and borders
    for (i = 0; i < panelViews.length; i++) {
        totalWidth += panelViews[i].clientWidth;
    }

    var subTitle = document.querySelector('.model-subtitle');

    if (!isTouchDevice() || window.innerWidth >= Autodesk.Viewing.MolViewer.MAX_TABLET_MODE_RESOLUTION) {
        if (this.viewer.app.ViewManager.isSafari) {
            this.el.style.webkitFlexBasis = totalWidth + 'px';
        } else {
            this.el.style.flexBasis = totalWidth + 'px';
        }
    }

    if (subTitle) {
        if (subTitle.scrollHeight > 42) {
            subTitle.style.visibility = 'hidden';
        } else {
            subTitle.style.visibility = 'visible';
        }
        if (vm2d) {
            vm2d.setViewerSize();
        }
    }


};

Autodesk.Viewing.MolViewer.BrowserView.prototype.updateSvfName = function updateSvfName(svfName) {
    this.svfName = svfName;
};

Autodesk.Viewing.MolViewer.BrowserView.prototype.buildAssemblyDropDown = function buildAssemblyDropDown(defaultValue) {
    var i,
        item,
        values = this.getAssemblies(this.molMan.currentMolModelID),
        len = values.length,
        output = document.createElement('div');

    output.setAttribute('id','assemblyDropdown');
    output.setAttribute('class','browser-drop-down');

    item = document.createElement('div');
    item.setAttribute('class','browser-drop-down-item');
    item.setAttribute('id', 'assemblyDropDown_Null');
    item.innerHTML = 'Asymmetric Unit';
    output.appendChild(item);

    for (i = 0; i < len; i++) {
        item = document.createElement('div');
        item.setAttribute('class','browser-drop-down-item' + (values[i] === defaultValue ? ' selected' : ''));
        item.setAttribute('id', 'assemblyDropDown_'+ values[i]);
        item.innerHTML = 'Assembly ' + values[i];
        output.appendChild(item);
    }

    return output;
};

Autodesk.Viewing.MolViewer.BrowserView.prototype.getAssemblies = function getAssemblies(modelID) {
    var output = [],
        assembly,
        assemblies = this.molMan.molModels[modelID].assemblies;
    for(assembly in assemblies) {
        if(assemblies.hasOwnProperty(assembly)) {
            output.push(assemblies[assembly].assemblyID);
        }
    }
    return output;
};




Autodesk.Viewing.MolViewer.BrowserView.prototype._buildEntityArray = function _buildEntityArray(entityIDs) {
    var i,
        j,
        entity,
        list,
        item,
        entityArray = [];

    for (i = 0; i < entityIDs.length; i++) {
        entity = document.createElement('div');
        entity.setAttribute('class','entity-desc');
        entity.innerHTML = this.molMan.molModels[this.molMan.currentMolModelID].entities[entityIDs[i]].description +'<span class="entity-type"> (' + this.molMan.molModels[this.molMan.currentMolModelID].entities[entityIDs[i]].type + ' )</span>';
        list = document.createElement('ul');
        list.setAttribute('class','chain-list');
        for (j = 0; j < this.molMan.molModels[this.molMan.currentMolModelID].entities[entityIDs[i]].chainIDs.length; j++) {
            item = document.createElement('li');
            item.innerHTML = 'Chain ' + this.molMan.molModels[this.molMan.currentMolModelID].entities[entityIDs[i]].chainIDs[j];
            list.appendChild(item);
        }
        entity.appendChild(list);
        entityArray.push(entity);
    }
    return entityArray;
};


Autodesk.Viewing.MolViewer.BrowserView.prototype._buildAssemblyInfo = function _buildEntityArray(assemblyID) {
    var i,
        entity,
        list,
        item,
        entityArray = [];


    entity = document.createElement('div');
    entity.setAttribute('class','entity-desc');
    entity.innerHTML = this.molMan.molModels[this.molMan.currentMolModelID].assemblies[assemblyID].details;
    list = document.createElement('ul');
    list.setAttribute('class','chain-list');
    for (i = 0; i < this.molMan.molModels[this.molMan.currentMolModelID].assemblies[assemblyID].chains.length; i++) {
        item = document.createElement('li');
        item.innerHTML = 'Chain ' + this.molMan.molModels[this.molMan.currentMolModelID].assemblies[assemblyID].chains[i];
        list.appendChild(item);
    }
    entity.appendChild(list);
    entityArray.push(entity);

    return entityArray;
};

Autodesk.Viewing.MolViewer.BrowserView.prototype.updateTitleFromString = function updateTitleFromString(title) {
    this.modelTitle.innerHTML = title;
};
;/**
 * Created by andrewkimoto on 9/9/16.
 */

Autodesk.Viewing.MolViewer.PresentationBrowserView = function(args) {
    var me = Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype;
    this.app = args.app;
    this.molMan = args.app.MolMan;
    this.viewer = args.viewer;
    this.svfName = args.svfName;
    this.visible = true;
    this.type = 'BrowserView';
    this.animateDirection = 'left';
    this.displayType = 'flex';
    this.flexDirection = 'row';
    this.resizeMin = [0,90];
    this.width = args.width;
    this.maxWidth = Autodesk.Viewing.isPhone() ? '100vw' : '300px';
    this.parentElement = document.querySelector('#contents-' + this.app.appID);
    this._initialize();
};

Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype._initializeElements = function _initializeElements() {
    var helpHTML;
    var getDesktopLink = function getDesktopLink() {
        var link = document.location.href,
            url = link,
            split,
            params,
            paramString = '',
            i;

        if (link.match(/\?/)) {
            split = link.split('?');
            params = split[1].split('&');
            url = split[0];
            for (i = params.length -1; i >=0; --i) {
                if (params[i].match(/^tV=presentation|^hH=/)) {
                    params.splice(i,1);
                }
            }

            for (i = 0; i < params.length; ++i) {
                paramString += (i === 0 ? '?' : '&') + params[i];
            }
            url += paramString;
        }
        return url;
    };

    this.openBrowserButton = document.createElement('div');
    this.openBrowserButton.className = "pres-menu-button browse";

    this.openBrowserImage = document.createElement('div');
    this.openBrowserImage.className = "pres-menu-image white";
    this.openBrowserButton.appendChild(this.openBrowserImage);

    this.parentElement.insertBefore(this.openBrowserButton, document.querySelector('#center-' + this.app.appID));

    this.modelTitle = document.createElement('div');
    this.modelTitle.setAttribute('class','presentation-model-title');
    document.querySelector('#center-' + this.app.appID).appendChild(this.modelTitle);

    this.el = document.createElement('DIV');
    this.el.style.flex = '0 0 0px';
    this.el.style.webkitFlex = '0 0 0px';
    this.el.style.flexDirection = this.flexDirection;
    this.el.style.webkitFlexDirection = this.flexDirection;
    this.el.style.width = '0px';
    this.el.setAttribute('id','browser-' + this.app.appID);
    this.el.setAttribute('class','browser presentation');
    this.browserHeader = document.createElement('div');
    this.browserHeader.setAttribute('id','browserHeader-' + this.app.appID);
    this.browserHeader.setAttribute('class','browserHeader presentation');
    this.titleDiv = document.createElement('div');
    this.titleDiv.className = "title-div";
    //this.modelTitle = document.createElement('div');
    //this.modelTitle.setAttribute('class','model-title');
    //this.modelTitle.innerHTML = this.svfName;
    //this.titleDiv.appendChild(this.modelTitle);
    this.closeButton = document.createElement('div');
    this.closeButton.className = "pres-menu-button right";
    this.closeImg = document.createElement('div');
    this.closeImg.className = "pres-menu-image white";
    this.closeButton.appendChild(this.closeImg);
    this.titleDiv.appendChild(this.closeButton);

    this.browserHeader.appendChild(this.titleDiv);

    this.el.appendChild(this.browserHeader);
    this.browserBody = document.createElement('div');
    this.browserBody.setAttribute('id','browserBody-' + this.app.appID);
    this.browserBody.setAttribute('class','browserBody presentation');

    this.openRow = document.createElement('div');
    this.openRow.setAttribute('class','pb-row pb-open-new');
    this.openRow.label = document.createElement('div');
    this.openRow.label.setAttribute('class','pb-label');
    this.openRow.label.innerHTML = 'Open New';
    this.openRow.content = document.createElement('div');
    this.openRow.content.setAttribute('class','pb-content');
    this.openRow.content.innerHTML = 'Enter Protein Database ID.';
    this.openRow.appendChild(this.openRow.label);
    this.openRow.appendChild(this.openRow.content);

    this.shareRow = document.createElement('div');
    this.shareRow.setAttribute('class','pb-row pb-share');
    this.shareRow.label = document.createElement('div');
    this.shareRow.label.setAttribute('class','pb-label');
    this.shareRow.label.innerHTML = 'Share';
    this.shareRow.content = document.createElement('div');
    this.shareRow.content.setAttribute('class','pb-content');
    this.shareRow.content.innerHTML = "A link to this model has been posted to your clipboard. On mobile this opens the native share dialog.";
    this.shareRow.appendChild(this.shareRow.label);
    this.shareRow.appendChild(this.shareRow.content);

    this.editRow = document.createElement('div');
    this.editRow.setAttribute('class','pb-row pb-edit');
    this.editRow.label = document.createElement('div');
    this.editRow.label.setAttribute('class','pb-label');
    this.editRow.label.innerHTML = 'Edit';
    this.editRow.content = document.createElement('div');
    this.editRow.content.setAttribute('class','pb-content');
    this.editRow.content.innerHTML = "Create, share and embed stunning molecular presentations with the Autodesk Molecular viewer on your desktop.<br><br><ul><li><a href='" + getDesktopLink() + "' target='_blank' >Open Viewer</a></li></ul>";
    this.editRow.appendChild(this.editRow.label);
    this.editRow.appendChild(this.editRow.content);

    this.editRowMobile = document.createElement('div');
    this.editRowMobile.setAttribute('class','pb-row pb-edit');
    this.editRowMobile.label = document.createElement('div');
    this.editRowMobile.label.setAttribute('class','pb-label');
    this.editRowMobile.label.innerHTML = 'Edit';
    this.editRowMobile.content = document.createElement('div');
    this.editRowMobile.content.setAttribute('class','pb-content');
    this.editRowMobile.content.innerHTML = "Create, share and embed stunning molecular presentations with the Autodesk Molecular viewer on your desktop.<br><br><ul><li><a href='http://bionano.autodesk.com/MoleculeViewer/index.html' target='_blank' >Learn More</a></li></ul>";
    this.editRowMobile.appendChild(this.editRowMobile.label);
    this.editRowMobile.appendChild(this.editRowMobile.content);

    this.vrMobileRow = document.createElement('div');
    this.vrMobileRow.setAttribute('class','pb-row pb-vr-mobile');
    this.vrMobileRow.label = document.createElement('div');
    this.vrMobileRow.label.setAttribute('class','pb-label');
    this.vrMobileRow.label.innerHTML = 'Virtual Reality';
    this.vrMobileRow.content = document.createElement('div');
    this.vrMobileRow.content.setAttribute('class','pb-content');
    this.vrMobileRow.content.innerHTML = 'View your model in virtual reality using your mobile device and Cardboard.<br>';
    this.vrMobileButton = document.createElement('button');
    this.vrMobileButton.setAttribute('class','pb-vr-button');
    this.vrMobileButton.innerHTML = 'Start';
    this.vrMobileInfo = document.createElement('div');
    this.vrMobileInfo.setAttribute('class','pb-info');
    this.vrMobileInfo.innerHTML = 'Tap the screen to switch between snapshots.';
    this.vrMobileRow.content.appendChild(this.vrMobileButton);
    this.vrMobileRow.content.appendChild(this.vrMobileInfo);
    this.vrMobileRow.appendChild(this.vrMobileRow.label);
    this.vrMobileRow.appendChild(this.vrMobileRow.content);

    this.vrRow = document.createElement('div');
    this.vrRow.setAttribute('class','pb-row pb-vr');
    this.vrRow.label = document.createElement('div');
    this.vrRow.label.setAttribute('class','pb-label');
    this.vrRow.label.innerHTML = 'Virtual Reality';
    this.vrRow.content = document.createElement('div');
    this.vrRow.content.setAttribute('class','pb-content');
    this.vrRow.content.innerHTML = 'View your model in virtual reality using a VR headset or your mobile device and Cardboard.';
    this.vrButton = document.createElement('button');
    this.vrButton.setAttribute('class','pb-text-button');
    this.vrButton.innerHTML = 'Choose VR device';
    this.vrRow.content.appendChild(this.vrButton);

    this.vrRow.appendChild(this.vrRow.label);
    this.vrRow.appendChild(this.vrRow.content);

    this.helpRowMobile = document.createElement('div');
    this.helpRowMobile.setAttribute('class','pb-row pb-help bottom');
    this.helpRowMobile.label = document.createElement('div');
    this.helpRowMobile.label.setAttribute('class','pb-label');
    this.helpRowMobile.label.innerHTML = 'Help';
    this.helpRowMobile.content = document.createElement('div');
    this.helpRowMobile.content.setAttribute('class','pb-content');
    helpHTML = '<ul><li><a target="_blank" href="https://forum.bionano.autodesk.com/t/presentation-view/135/1">Getting Started</a></li>';
    helpHTML += '<li><a target="_blank" href="https://forum.bionano.autodesk.com/t/mobile-virtual-reality/133">Virtual Reality</a></li>';
    helpHTML += '<li><a target="_blank" href="http://bionano.autodesk.com/MoleculeViewer/index.html">About</a></li></ul>';
    this.helpRowMobile.content.innerHTML = helpHTML;
    this.helpRowMobile.appendChild(this.helpRowMobile.label);
    this.helpRowMobile.appendChild(this.helpRowMobile.content);

    this.helpRow = document.createElement('div');
    this.helpRow.setAttribute('class','pb-row pb-help bottom');
    this.helpRow.label = document.createElement('div');
    this.helpRow.label.setAttribute('class','pb-label');
    this.helpRow.label.innerHTML = 'Help';
    this.helpRow.content = document.createElement('div');
    this.helpRow.content.setAttribute('class','pb-content');
    helpHTML = '<ul><li><a target="_blank" href="https://forum.bionano.autodesk.com/t/quick-start/45">Getting Started</a></li>';
    helpHTML += '<li><a target="_blank" href="https://forum.bionano.autodesk.com/c/Molecule-Viewer/User-Guide">User Manual</a></li>';
    helpHTML += '<li><a target="_blank" href="http://bionano.autodesk.com/MoleculeViewer/index.html">About</a></li></ul>';
    this.helpRow.content.innerHTML = helpHTML;
    this.helpRow.appendChild(this.helpRow.label);
    this.helpRow.appendChild(this.helpRow.content);


    this.footer = document.createElement('div');
    this.footer.setAttribute('class','pb-footer hidden');

    this.logoDiv = document.createElement('a');
    this.logoDiv.setAttribute('class','pb-logo-div');
    this.logoDiv.setAttribute('href','http://bionano.autodesk.com/MoleculeViewer/index.html');
    this.logoDiv.setAttribute('target','_blank');

    this.logoTitle = document.createElement('h2');
    this.logoTitle.innerHTML = 'Autodesk Research';

    this.logoSubtitle = document.createElement('p');
    this.logoSubtitle.innerHTML = 'Molecule Viewer';

    this.logoDiv.appendChild(this.logoTitle);
    this.logoDiv.appendChild(this.logoSubtitle);

    this.footerText = document.createElement('div');
    this.footerText.setAttribute('class','pb-footer-text');
    this.footerText.innerHTML = 'Explore, Edit and Share Large-Scale Protein Structures';
    //this.browserBody.appendChild(this.openRow);
    //this.browserBody.appendChild(this.shareRow);

    if(Autodesk.Viewing.isMobileDevice()) {
        this.browserBody.appendChild(this.editRowMobile);
    } else {
        this.browserBody.appendChild(this.editRow);
    }

    //if(Autodesk.Viewing.isPhone()) {
    if(Autodesk.Viewing.isMobileDevice()) { //temporary so we can test on tablet
        this.browserBody.appendChild(this.vrMobileRow);
    } else {
        this.browserBody.appendChild(this.vrRow);
    }
    if(Autodesk.Viewing.isMobileDevice()) {
        this.browserBody.appendChild(this.helpRowMobile);
    } else {
        this.browserBody.appendChild(this.helpRow);
    }


    this.footer.appendChild(this.logoDiv);
    this.footer.appendChild(this.footerText);
    this.browserBody.appendChild(this.footer);



    this.el.appendChild(this.browserBody);
    //this.browserFooter = document.createElement('div');
    //this.browserFooter.setAttribute('id','browserFooter');
    //this.el.appendChild(this.browserFooter);

    this.parentElement.insertBefore(this.el, document.querySelector('#center-' + this.app.appID));
};

Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype._initializeEvents = function _initializeEvents() {
    var self = this;

    //this.buildScrollbar = function buildScrollbar(e) {
    //    if(!e || typeof e.modelType === 'string') {
    //        if (!self.scrollbar) {
    //            self.scrollbar = new Autodesk.Nano.ScrollView(self, self.browserHeader, self.infoDiv,self.titleDiv.clientHeight,0);
    //        }
    //    }

    //};
    this.toggleRow = function toggleRow(event) {
        if ((event.target && event.target.href) || (event.target && event.target.className === 'pb-vr-button' || event.target && event.target.className === 'pb-text-button')) {
            return; //don't toggle the row if clicked on a child element
        }
        var rows = self.app.container.querySelectorAll('.pb-row');
        var i;
        for (i = 0; i < rows.length; ++i) {
            if (rows[i] !== event.currentTarget) {
                rows[i].content.classList.remove('visible');
                rows[i].style.height = '60px';
            }
        }
        if(event.currentTarget) {
            if (event.currentTarget.style.height === 'auto') {
                event.currentTarget.style.height = '60px';
                event.currentTarget.content.classList.remove('visible');
            } else {
                event.currentTarget.content.classList.add('visible');
                event.currentTarget.style.height = 'auto';
            }
        }

        self.updateBrowserHeight();
    };

    this.showOpenBrowserButton = function showOpenBrowserButton(show) {
        if (show) {
            self.openBrowserButton.style.display = 'block';
        } else {
            self.openBrowserButton.style.display = 'none';
        }

    };

    this.openVRDialog = function openVRDialog() {
        self.app.ViewManager.createTopView('VRView');
        window.setTimeout(function() {
            self.app.ViewManager.getTopView('VRView').show();
        },200);
    };

    this.startVR = function startVR() {
        self.app.MoleculeViewer.setActiveNavigationTool("vr");
        self.app.ViewManager.getTopView('StateView').hide();
        self.app.ViewManager.getTopView('StateView').hideScrollMessages();
        self.app.ViewManager.getTopView('StateView').showSwitcher(true);
        self.modelTitle.classList.add('hidden');
        self.showOpenBrowserButton(false);
        if (self.el.style.flexBasis === self.maxWidth) {
            self.toggleBrowser();
        }
    };

    this.endVR = function endVR() {
        self.showOpenBrowserButton(true);
        self.app.ViewManager.getTopView('StateView').showSwitcher(false);
        self.modelTitle.classList.remove('hidden');
    };

    this.vrMobileRow.addEventListener('click',this.toggleRow);
    //this.openRow.addEventListener('click',this.toggleRow);
    //this.shareRow.addEventListener('click',this.toggleRow);
    this.editRow.addEventListener('click',this.toggleRow);
    this.editRowMobile.addEventListener('click',this.toggleRow);
    this.vrMobileRow.addEventListener('click',this.toggleRow);
    this.vrRow.addEventListener('click',this.toggleRow);
    this.helpRow.addEventListener('click',this.toggleRow);
    this.helpRowMobile.addEventListener('click',this.toggleRow);

    this.vrMobileButton.addEventListener('click', this.startVR);
    this.vrButton.addEventListener('click', this.openVRDialog);

    this.addDropdownEvents = function addDropdownEvents() {
        var dropDownItems = self.assemblyDropdown.querySelectorAll('.browser-drop-down-item'),
            i,
            id,
            that = this,
            args;

        for (i = 0; i < dropDownItems.length; i++) {
            id = dropDownItems[i].innerHTML.replace(/Assembly /, '');
            id = (dropDownItems[i].innerHTML === 'Asymmetric Unit' ? null : id);
            dropDownItems[i].addEventListener('click', that.switchToAssembly.bind(that, id));
        }
    };

    this.switchToAssembly = function switchToAssembly(id) {
        self.app.ViewManager.getTopView('StatusView').showCustomMessage('Switching to asssembly ' + id +'...');
        self.assemblyDropdown.classList.remove('visible');
        window.setTimeout(function() { //give browser time to show the status view
            self.molMan.molModels[self.molMan.currentMolModelID].switchToAssembly(id); //todo need to fix with multi-model
        },100,id);
    };

    this.switchToAssemblyCB = function switchToAssemblyCB(event) {
        var rootViewName = self.app.ViewManager.getRootView();
        var rootView;
        if(rootViewName) {
            rootView = self.app.ViewManager.findViews(rootViewName)[0];
            self.app.ViewManager.destroyView(rootView,false,false);
            rootView.clearView();
            rootView.itemList.buildItems(rootView.el);
        }
        self.molMan.clearSelection();
        self.updateAssemblyValue();
        //self.getInfo(); TODO determine if we will want info somewhere in presentation mode
        self.app.ViewManager.getTopView('StatusView').hide();
    };

    //TODO decide if we  need assemby value
    this.updateAssemblyValue = function updateValue() {
        var activeAssembly = self.molMan.molModels[self.molMan.currentMolModelID].getActiveAssembly();
        //self.assemblyValue.innerHTML = (activeAssembly === null ? 'Asymmetric Unit' : 'Assembly ' + activeAssembly.assemblyID);
    };

    this.updateTitle = function updateTitle(e) {
        if(!e || e.modelType ==='mol') {
            self.modelTitle.innerHTML = self.molMan.molModels[self.molMan.currentMolModelID].molMetadata.title;
        }
    };

    this.doHideBrowserDropdowns = function doHideBrowserDropdowns(event) {
        if (!event.target.classList.contains('browser-value')) {
            self.hideBrowserDropdowns(event);
            document.removeEventListener('click',self.doHideBrowserDropdowns);
        }
    };

    this.hideBrowserDropdowns = function hideBrowserDropdowns(event) {
        var dropDowns = self.el.querySelectorAll('.browser-drop-down'),
            i;

        for (i = 0; i < dropDowns.length; i++) {
            dropDowns[i].classList.remove('visible');
        }
    };

    this.resetScrollBars = function resetScrollBars() {
        var topViews = self.app.ViewManager.topViews;
        var view;
        for (view in topViews) {
            if(topViews.hasOwnProperty(view)) {
                if(topViews[view].scrollbar) {
                    self.resetScrollBar(topViews[view]);
                }
            }
        }
    };

    this.resetScrollBar = function resetScrollBar(view) {
        if (view.scrollbar) {
            view.scrollbar.scrollElement.scrollTop = 0;
            view.scrollbar.scrollThumb.style.top = '0px';
            view.scrollbar.updateScrollbar();
        }


    };

    this.toggleSelected = function toggleSelected() {
        if (self.selectedButton.classList.contains('active')) {
            self.el.classList.remove('selected-only');
            self.selectedButton.innerHTML = 'Show selected only';
            self.selectedButton.classList.remove('active');

        } else {
            self.el.classList.add('selected-only');
            self.selectedButton.innerHTML = 'Showing selected only';
            self.selectedButton.classList.add('active');
        }
        self.resetScrollBars();
    };

    this.toggleInfo = function toggleInfo() {
        var offset;
        if (self.infoButton.classList.contains('active')) {
            self.infoDiv.classList.remove('visible');
            self.browserHeader.style.flex = '';
            self.browserHeader.style.webkitFlex = '';
            self.browserBody.setAttribute('style','');
            self.infoButton.innerHTML = 'Info';
            self.infoButton.classList.remove('active');
            self.viewer.fireEvent(Autodesk.Nano.BROWSER_RESIZED_EVENT);  //forces panelviews to resize
        } else {
            self.infoDiv.classList.add('visible');
            self.browserHeader.style.flex = '0 0 auto';
            self.browserHeader.style.webkitFlex = '0 0 auto';
            offset = self.browserHeader.offsetHeight + self.browserFooter.offsetHeight;
            self.browserBody.style.height = "calc(100% - " + offset + "px)";
            self.infoButton.innerHTML = 'Hide info';
            self.infoButton.classList.add('active');
            self.viewer.fireEvent(Autodesk.Nano.BROWSER_RESIZED_EVENT);  //forces panelviews to resize
        }
        self.resetScrollBars();
    };

    this.getInfo = function getInfo(e) {
        if(!e || e.modelType === 'mol') {
            var title,
                pdbLink,
                entity,
                entityTitle,
                entityIDs,
                entities,
                assemblyName,
                assemblyID,
                entityArray = [],
                offset,
                isAssembly = false,
                i;

            self.infoDiv.innerHTML = '';
            title = document.createElement('div');
            title.setAttribute('class', 'info-title');
            var md = self.molMan.molModels[self.molMan.currentMolModelID].molMetadata;
            title.innerHTML = md.title + ' ' + md.subTitle;
            pdbLink = document.createElement('div');
            pdbLink.setAttribute('class', 'pdb-link');
            pdbLink.innerHTML = '<a target = "_blank" href="http://www.rcsb.org/pdb/explore/explore.do?structureId=' + md.title + '">Open in Protein Databank website ></a>';
            entityTitle = document.createElement('div');
            entityTitle.setAttribute('class', 'entity-title');
            entityTitle.innerHTML = 'Entities';

            //get whether we are looking at the asymmetric unit or an assembly
            if (self.molMan.molModels[self.molMan.currentMolModelID].activeAssembly === null) {
                isAssembly = false;
                assemblyName = 'Asymmetric Unit';
                entityIDs = self.molMan.molModels[self.molMan.currentMolModelID].activeInstances[0].entityIDs;
                entities = self.molMan.molModels[self.molMan.currentMolModelID].entities;
                entityArray = self._buildEntityArray(entityIDs);
            } else {
                isAssembly = true;
                assemblyName = 'Assembly ' + self.molMan.molModels[self.molMan.currentMolModelID].activeAssembly.assemblyID;
                assemblyID = [self.molMan.molModels[self.molMan.currentMolModelID].activeAssembly.assemblyID];
                entityArray = self._buildAssemblyInfo(assemblyID);
            }

            self.infoDiv.appendChild(title);
            self.infoDiv.appendChild(pdbLink);
            self.infoDiv.appendChild(entityTitle);
            for (i = 0; i < entityArray.length; i++) {
                self.infoDiv.appendChild(entityArray[i]);
            }

            if (self.infoButton.classList.contains('active')) {
                offset = self.browserHeader.offsetHeight + self.browserFooter.offsetHeight;
                self.browserBody.style.height = "calc(100% - " + offset + "px)";
            }
        }
    };

    //for mobile (non-phone)
    this.toggleMobileBrowser = function toggleMobileBrowser(event) {

    };

    this.togglePhoneBrowser = function togglePhoneBrowser(event) {

    };



    this.toggleBrowser = function toggleBrowser(event) {
        if (this.el.style.flexBasis === this.maxWidth || this.el.style.webkitFlexBasis === this.maxWidth) {

            self.app.ViewManager.setViewerSize({browserWidth:0,resizerWidth:0,inspectorWidth:0});
            this.toggleRow({target: null, currentTarget: null}); //close up all open menus
            this.el.style.position = 'absolute';
            this.el.style.width = '0px';
            this.el.style.flexBasis = '0px';
            this.el.style.webkitFlexBasis = '0px';
            this.footer.classList.add('hidden');


        } else {
            this.footer.classList.remove('hidden');
            this.el.style.flexBasis = this.maxWidth;
            this.el.style.webkitFlexBasis = this.maxWidth;
            this.el.style.width = this.maxWidth;
            this.el.style.position = 'absolute';
        }
        var scope = this;
        window.setTimeout(function(scope) {console.log(scope);scope.el.style.position = 'initial';self.app.ViewManager.setViewerSize();},450,scope);
        //ViewManager.setViewerSize();
        //ViewManager.toggleBrowser();
        //self.molMan.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
        this.updateBrowserHeight();
    };

    this.updateBrowserHeight = function updateBrowserHeight() {
        var rows = self.app.container.querySelectorAll('.pb-row');
        var i;
        var rowsHeight = 0;
        for (i = 0; i < rows.length; ++i) {
            rowsHeight += rows[i].clientHeight;
        }
        this.browserBody.style.height = document.body.clientHeight - this.browserHeader.clientHeight + 'px';
        if (this.browserBody.scrollHeight + this.browserHeader.clientHeight === document.body.clientHeight) {
            this.browserBody.style.overflowY = 'hidden';
        } else {
            this.browserBody.style.overflowY = 'scroll';
        }
        this.footer.style.marginTop = Math.max(10,(document.body.clientHeight - (rowsHeight + this.browserHeader.clientHeight) - 182)) +'px';
    };

    this.updateBrowserHeightBind = this.updateBrowserHeight.bind(this);
    //this.getUrlWithSessionBind = this.getUrlWithSession.bind(this);
    this.toggleBrowserBind = this.toggleBrowser.bind(this);

    this.closeButton.addEventListener('click', this.toggleBrowserBind);
    this.openBrowserButton.addEventListener('click', this.toggleBrowserBind);

    this.browserResizedCB = self.updateWidth.bind(self);

    this._bindEvents = function _bindEvents() {
        self.viewer.addEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, self.updateTitle);
        self.viewer.addEventListener(Autodesk.Viewing.BROWSER_RESIZED_EVENT, self.browserResizedCB);
        self.viewer.addEventListener(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED, self._unbindEvents);
        self.viewer.addEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT,self.switchToAssemblyCB);
    };

    this._unbindEvents = function _unbindEvents() {
        self.viewer.removeEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, self.updateTitle);
        self.viewer.removeEventListener(Autodesk.Viewing.BROWSER_RESIZED_EVENT, self.browserResizedCB);
        self.viewer.removeEventListener(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED, self._unbindEvents);
        self.viewer.removeEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT, self.switchToAssemblyCB);
    };

    if(Autodesk.Viewing.isMobileDevice()) {
        window.addEventListener('orientationchange', this.updateBrowserHeightBind);
    } else {
        window.addEventListener('resize', this.updateBrowserHeightBind);
    }
    this.viewer.addEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, self.updateTitle);
    this.viewer.addEventListener(Autodesk.Viewing.BROWSER_RESIZED_EVENT, self.browserResizedCB);
    this.viewer.addEventListener(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED, self._unbindEvents);
    this.viewer.addEventListener(Autodesk.Viewing.ASSEMBLY_SET_EVENT,self.switchToAssemblyCB);
};

Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype.updateWidth = function updateWidth() {
    var vm2d = this.app.ViewManager;
    var panelViews = this.app.container.querySelectorAll('.panelView');
    if(panelViews.length === 0) {
        return;
    }
    var i;
    var totalWidth = 0; //handles width of resizers and borders

    var subTitle = this.app.container.querySelector('.model-subtitle');

    if (!isTouchDevice() || window.innerWidth >= Autodesk.Viewing.MolViewer.MAX_TABLET_MODE_RESOLUTION) {
        if (this.app.ViewManager.isSafari) {
            this.el.style.webkitFlexBasis = totalWidth + 'px';
        } else {
            this.el.style.flexBasis = totalWidth + 'px';
        }
    }

    if (vm2d) {
        vm2d.setViewerSize();
    }
};

Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype.updateSvfName = function updateSvfName(svfName) {
    this.svfName = svfName;
};

Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype.buildAssemblyDropDown = function buildAssemblyDropDown(defaultValue) {
    var i,
        item,
        values = this.getAssemblies(this.molMan.currentMolModelID),
        len = values.length,
        output = document.createElement('div');

    output.setAttribute('id','assemblyDropdown');
    output.setAttribute('class','browser-drop-down');

    item = document.createElement('div');
    item.setAttribute('class','browser-drop-down-item');
    item.setAttribute('id', 'assemblyDropDown_Null');
    item.innerHTML = 'Asymmetric Unit';
    output.appendChild(item);

    for (i = 0; i < len; i++) {
        item = document.createElement('div');
        item.setAttribute('class','browser-drop-down-item' + (values[i] === defaultValue ? ' selected' : ''));
        item.setAttribute('id', 'assemblyDropDown_'+ values[i]);
        item.innerHTML = 'Assembly ' + values[i];
        output.appendChild(item);
    }

    return output;
};

Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype.getAssemblies = function getAssemblies(modelID) {
    var output = [],
        assembly,
        assemblies = this.molMan.molModels[modelID].assemblies;
    for(assembly in assemblies) {
        if(assemblies.hasOwnProperty(assembly)) {
            output.push(assemblies[assembly].assemblyID);
        }
    }
    return output;
};




Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype._buildEntityArray = function _buildEntityArray(entityIDs) {
    var i,
        j,
        entity,
        list,
        item,
        entityArray = [];

    for (i = 0; i < entityIDs.length; i++) {
        entity = document.createElement('div');
        entity.setAttribute('class','entity-desc');
        entity.innerHTML = this.molMan.molModels[this.molMan.currentMolModelID].entities[entityIDs[i]].description +'<span class="entity-type"> (' + this.molMan.molModels[this.molMan.currentMolModelID].entities[entityIDs[i]].type + ' )</span>';
        list = document.createElement('ul');
        list.setAttribute('class','chain-list');
        for (j = 0; j < this.molMan.molModels[this.molMan.currentMolModelID].entities[entityIDs[i]].chainIDs.length; j++) {
            item = document.createElement('li');
            item.innerHTML = 'Chain ' + this.molMan.molModels[this.molMan.currentMolModelID].entities[entityIDs[i]].chainIDs[j];
            list.appendChild(item);
        }
        entity.appendChild(list);
        entityArray.push(entity);
    }
    return entityArray;
};


Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype._buildAssemblyInfo = function _buildEntityArray(assemblyID) {
    var i,
        entity,
        list,
        item,
        entityArray = [];


    entity = document.createElement('div');
    entity.setAttribute('class','entity-desc');
    entity.innerHTML = this.molMan.molModels[this.molMan.currentMolModelID].assemblies[assemblyID].details;
    list = document.createElement('ul');
    list.setAttribute('class','chain-list');
    for (i = 0; i < this.molMan.molModels[this.molMan.currentMolModelID].assemblies[assemblyID].chains.length; i++) {
        item = document.createElement('li');
        item.innerHTML = 'Chain ' + this.molMan.molModels[this.molMan.currentMolModelID].assemblies[assemblyID].chains[i];
        list.appendChild(item);
    }
    entity.appendChild(list);
    entityArray.push(entity);

    return entityArray;
};

Autodesk.Viewing.MolViewer.PresentationBrowserView.prototype.updateTitleFromString = function updateTitleFromString(title) {
    this.modelTitle.innerHTML = title;
};
;Autodesk.Viewing.MolViewer.CrumbView = function (args) {

    var me = Autodesk.Viewing.MolViewer.CrumbView.prototype;
    this.app = args.app;
    this.viewer = args.viewer;
    this.type = 'CrumbView';
    this.parentElement = document.querySelector(args.parentElement);
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this._initialize();
};

Autodesk.Viewing.MolViewer.CrumbView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.CrumbView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.CrumbView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
    this.eventQueue = new Autodesk.Nano.EventQueue(this.viewer,this.hitTest,150,'mousemove',document);
};

Autodesk.Viewing.MolViewer.CrumbView.prototype.destructor = function destructor() {
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);
};

Autodesk.Viewing.MolViewer.CrumbView.prototype._initializeElements = function _initializeElements() {
    this.el = document.createElement('DIV');
    this.el.setAttribute('id','crumbBar');

    this.parentElement.appendChild(this.el);

    this.doneButton = document.createElement('div');
    this.doneButton.className = "full-width-button";
    this.doneButton.innerHTML = "Done";

    this.parentElement.appendChild(this.doneButton);
};

Autodesk.Viewing.MolViewer.CrumbView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.clearTimedEvent = function clearTimedEvent() {
        window.clearTimeout(self._timer);
        self._timer = null;
    };

    this.hitTest = function hitTest(event)  {
        var obj;
        var vector3 = self.app.MolMan.cachedVector;

        if(event.target === self.app.container.querySelector('#canvas3D')) {
            vector3.x = event.normalizedX;
            vector3.y = event.normalizedY;
            vector3.z = 1.0;

            obj = self.app.MolMan.isModelLoaded() ? self.app.MolMan.viewer.impl.hitTestViewport(vector3) : null;

            if (obj) {
                self.getAtomInfo(obj);
            } else {
                self.el.innerHTML = '';
            }

        } else if (event.target === document.querySelector('html')) {
            self.el.innerHTML = '';
        } else if (event.target.classList.contains('instance') || event.target.parentNode.classList.contains('instance')) {
            self.get2DAtomInfo('instance', event.target);
        } else if (event.target.classList.contains('chain')) {
            self.get2DAtomInfo('chain', event.target);
        } else if (event.target.parentNode.classList.contains('chain')) {
            self.get2DAtomInfo('chain', event.target.parentNode);
        } else if (event.target.classList.contains('residue')) {
            self.get2DAtomInfo('residue', event.target);
        } else if (event.target.parentNode.classList.contains('residue')) {
            self.get2DAtomInfo('residue', event.target.parentNode);
        } else if (event.target.classList.contains('atom')) {
            self.get2DAtomInfo('atom', event.target);
        } else if (event.target.parentNode.classList.contains('atom')) {
            self.get2DAtomInfo('atom', event.target.parentNode);
        } else {
            self.el.innerHTML = '';
        }
    };

    this.get2DAtomInfo = function get2DAtomInfo(type,target) {
        var crumbs,
            atomInfo,
            atom,
            instance,
            residue;

        if(type === 'instance') {
            crumbs = target.textContent;
        } else if (type === 'chain') {
            crumbs = target.parentNode.firstChild.textContent + ' &#x276f; ' + target.textContent;
        } else if (type === 'residue') {
            crumbs = target.parentNode.parentNode.firstChild.textContent.replace(/\s\s/,'&nbsp;&#x276f;&nbsp;') + ' &#x276f;  ' + self.app.ViewManager.fullnames[self.app.ViewManager.longNames[target.firstChild.firstChild.textContent]] + ' ' + target.firstChild.childNodes[1].textContent.replace(/\./,'');
        } else if (type === 'atom') {
            instance = self.app.ViewManager.getInstanceIndexFromID(target.parentNode.getAttribute('data-instance')) + 1;
            atomInfo = self.app.MolMan.molModels[self.app.MolMan.currentMolModelID].molMetadata.metaData[target.id];
            residue = self.app.ViewManager.fullnames[atomInfo.residue];
            residue = residue === undefined ? '???' : residue;
            residue += ' ' + (atomInfo.resNumber === '.' ? '' : atomInfo.resNumber);
            atom = self.app.MolMan.molModels[self.app.MolMan.currentMolModelID].molMetadata.atomNames[atomInfo.element] + ' ' + atomInfo.detailType.replace(atomInfo.element,'');
            crumbs = 'Instance ' + instance + ' &#x276f; Chain ' + atomInfo.chainID  + ' &#x276f; ' + residue  + ' &#x276f; ' + atom;
        }

        self.el.innerHTML = crumbs;
    };

    this.getAtomInfo = function getAtomInfo(obj) {
        var self = this;
        var ID = obj.instance.molModel.id;
        var instance = obj.instance;
        var atomInfo = self.app.MolMan.molModels[ID].molMetadata.metaData[obj.atomID];
        var selectionFilter = self.app.MolMan.selectionFilter;
        var crumbs,
            atom,
            residue;

        if(selectionFilter === 'instance') {
            crumbs = 'Instance ' + (self.app.ViewManager.getInstanceIndexFromID(instance.id) + 1);
        } else if (selectionFilter === 'chain') {
            crumbs = 'Instance ' + (self.app.ViewManager.getInstanceIndexFromID(instance.id) + 1) + ' &#x276f; Chain ' + atomInfo.chainID;
        } else if (selectionFilter === 'residueID') {
            residue = self.app.ViewManager.fullnames[atomInfo.residue] + ' ' + atomInfo.resNumber.replace(/\./,'');
            crumbs = 'Instance ' + (self.app.ViewManager.getInstanceIndexFromID(instance.id) + 1) + ' &#x276f; Chain ' + atomInfo.chainID  + ' &#x276f; ' + residue;
        } else if (selectionFilter === 'atomID') {
            atom = self.app.MolMan.molModels[self.app.MolMan.currentMolModelID].molMetadata.atomNames[atomInfo.element] + ' ' + atomInfo.detailType.replace(atomInfo.element,'');
            residue = self.app.ViewManager.fullnames[atomInfo.residue] + ' ' + atomInfo.resNumber.replace(/\./,'');
            crumbs = 'Instance ' + (self.app.ViewManager.getInstanceIndexFromID(instance.id) + 1) + ' &#x276f; Chain ' + atomInfo.chainID  + ' &#x276f; ' + residue + ' &#x276f; ' + atom;
        } else {
            crumbs = '';
        }
        self.el.innerHTML = crumbs;
    };

    this.doneButton.addEventListener('touchstart', touchStartToClick);
    this.doneButton.addEventListener('click', function(event) {
        self.app.ViewManager.getTopView('HeaderView').toggleMobileMenu();
    });

};





;Autodesk.Viewing.MolViewer.AboutView = function (args) {

    var me = Autodesk.Viewing.MolViewer.AboutView.prototype;
    this.app = args.app;
    this.viewer = args.viewer;
    this.loader = args.app.Loader
    this.modal = args.modal;
    this.type = 'AboutView';
    this.parent = this.app.ViewManager.getTopView('DialogView');
    this.parentElement = this.app.ViewManager.getTopView('DialogView').dialogDiv;
    if (this.parent.activeDialog) {
        this.parent.activeDialog.destroy(); //destroy active dialog if any
    }
    this.parent.activeDialog = this;
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this.height = 400;
    this.width = 600;
    this._initialize();
};

Autodesk.Viewing.MolViewer.AboutView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.AboutView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.AboutView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.AboutView.prototype.destroy = function destroy() {
    this.app.ViewManager.getTopView('DialogView').hide();
    this.parent.el.removeEventListener('click',self.clickClose);
    this.parent.activeDialog = null;
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);

};

Autodesk.Viewing.MolViewer.AboutView.prototype._initializeElements = function _initializeElements() {
    var content = '';
    var dialogView = this.app.ViewManager.getTopView('DialogView');

    if (this.modal) {
        dialogView.setModal();
    } else {
        dialogView.setModeless();
    }

    this.el = document.createElement('DIV');
    this.el.setAttribute('id','about');
    dialogView.setDimensions(this.height,this.width);
    dialogView.setPosition(false);
    dialogView.setVerticalScroll(true);
    this.header = document.createElement('img');
    this.header.setAttribute('src','https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/about.png');
    this.subTitle = document.createElement('h2');
    this.subTitle.innerHTML ='&copy; 2016 Autodesk, Inc. All rights reserved.';
    this.bodyText = document.createElement('div');
    this.bodyText.style.width = "100%";

    content = '<p>All use of this Service is subject to the terms and conditions of the ' +
    'A360 Terms of Service and Privacy Statement accepted upon access of this Service.<p>';

    content += '<p>This service may incorporate or use background Autodesk technology components. ' +
    'For information about these components, click here: http://www.autodesk.com/cloud-platform-components</p>';

    content +='<p><strong>Trademarks</strong></p>';


    content +='<p>Autodesk is a registered trademark or trademark of Autodesk, Inc., and/or its subsidiaries and/or affiliates.</br>';
    content +='All other brand names, product names or trademarks belong to their respective holders.</p>';

    content += '<p><strong>Third-Party Software Credits and Attributions</strong></p>';

    content += '<p>Portions relating to backbone.js are Copyright (c) 2010-2013 Jeremy Ashkenas, DocumentCloud<br>';
    content += 'Portions relating to ColorMethods.js, ColorPicker.js, and ColorValuePicker.js are Copyright (c) 2007 John Dyer (http://johndyer.name)<br>';
    content += 'Portions relating to builder.js are Copyright  2013 Dan Rogers<br>';
    content += 'Portions relating dragdrop.js are Copyright (c) 2011 James Brumond<br>';
    content += 'Portions relating to iscroll.js are Copyright (c) 2011 Matteo Spinelli, http://cubiq.org/<br>';
    content += 'Portions relating to jqplot.barRenderer.js and jqplot.highlighter.js are Copyright  2009-2011 Chris Leonello<br>';
    content += 'Portions relating to jqplot.canvasAxisLabelRenderer.js, jqplot.canvasTextRenderer.js and jqplot.categoryAxisRenderer.js are Copyright (c) 2009 Chris Leonello<br>';
    content += 'Portions relating to jquery.jqplot.js are Copyright (c) 2009-2012 Chris Leonello<br>';
    content += 'Portions relating to jquery.accordion.js are Copyright (c) 2006 Jrn Zaefferer, Frank Marcia<br>';
    content += 'Portions relating to jquery.boxen-1.3.js are Copyright (c) 2009 Happy Noodle Boy (http://forums.whirlpool.net.au/user/65488); Copyright (c) 2009 Phil Brown (http://morecowbell.net.au/)<br>';
    content += 'Portions relating to jquery.fullcalendar.js are Copyright (c) 2009 Adam Shaw<br>';
    content += 'Portions relating to jquery.mobile.js are Copyright 2010, 2013 jQuery Foundation, Inc. and other contributors, http://jquery.com/<br>';
    content += 'Portions relating to jquery.qtip.min.js are Copyright (c) 2009 Craig Thompson http://craigsworks.com<br>';
    content += 'Portions relating to jquery.scrollTo.js are Copyright (c) 2010-2012 Benjamin Lupton b@lupton.cc<br>';
    content += 'Portions relating to jquery splitview are Copyright 2013 jQuery Foundation and other contributors http://jquery.com/<br>';
    content += 'Portions relating to jquery.timeago.js are Copyright  2008-2013 Ryan McGeary (@rmm5t)<br>';
    content += 'Portions relating to jquery.timers.js are Copyright (c) 2011 Micheal Benedict Arul<br>';
    content += 'Portions relating to jquery.tokeninput.js are Copyright (c) 2009 James Smith (http://loopj.com)<br>';
    content += 'Portions relating to jquery.truncate.js are Copyright (c) 2012-2013 Thorsten Basse and contributors<br>';
    content += 'Portions relating to jquery.ui.datepicker.js are Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)<br>';
    content += 'Portions relating to lawnchair.js are copyright (c) 2009, 2010, 2011 @brianleroux and lawnchair contributors<br>';
    content += 'Portions relating to modernizr.js are Copyright  20092013.<br>';
    content += 'Portions relating to prototype-1.6.0.3.js are  20062012 Prototype Core Team.<br>';
    content += 'Portions relating to prototype.js are Copyright (c) 2005-2010 Sam Stephenson.<br>';
    content += 'Portions relating to simpleajax.js are Copyright (c) 2012 Victor Villaverde Laan.<br>';
    content += 'Portions relating to statusbarnotification.js are Copyright (C) 2011 Dmitry Savchenko dg.freak@gmail.com Copyright (C) 2012 Max Ogden max@maxogden.com<br>';
    content += 'Portions relating to swfobject.js are Copyright (c) 2007 Geoff Stearns<br>';
    content += 'Portions relating to underscore.js are Copyright (c) 2009-2013 Jeremy Ashkenas, DocumentCloud<br>';
    content += 'Portions relating to ui.core.js are Copyright (c) 2008 Paul Bakaus (ui.jquery.com)<br>';
    content += 'Portions relating to window.js are Copyright (c) 2006 Sbastien Gruhier (http://xilinus.com, http://itseb.com)<br>';
    content += 'Portions relating to html5_init.js are Copyright 2010-2011 Research In Motion Limited<br>';
    content += 'Portions relating to html5_worker.js are Copyright (c) 2010 Research In Motion Limited.<br>';
    content += 'Portions relating to lookup.js are @copyright 2011 Mikko Ohtamaa mikko@mfabrik.com<br>';
    content += 'Portions relating to favicon.js are Copyright (c) 2008 Michael Mahemoff<br>';
    content += 'Portions relating to candy.js are Copyright (c) 2010 Center for Development of Open Technology (CDOT)<br>';
    content += 'Portions relating to strophe.js are Copyright (c) 2006-2009 Collecta, Inc.<br>';
    content += 'Portions relating to jopt-simple-3.2.jar are Copyright  2013. All Rights Reserved.<br>';
    content += 'Portions relating to slf4j-api-1.5.11.jar, slf4j-api-1.6.1.jar, slf4j-jdk14-1.5.11.jar, slf4j-simple-1.5.11.jar, and slf4j-simple-1.6.1.jar are Copyright (c) 2004-2011 QOS.ch. All rights reserved.<br>';
    content += 'Portions relating to spy-memcached-2.7.jar are Copyright (c) 2006-2009 Dustin Sallings; Copyright (c) 2009-2011 Couchbase, Inc.<br>';
    content += 'Portions relating to tr8n are Copyright (c) 2010-2012 Michael Berkovich, tr8n.net<br>';
    content += 'Portions relating to gzipencoder.swc are Copyright (c) 2009 H. Paul Robertson<br>';
    content += 'Portions relating to Jquery.elastic.js are by author Jan Jarfalk, https://github.com/mbklein/jquery-elastic/blob/master/jquery.elastic.source.js<br>';
    content += 'Portions relating to Zeroclipboard.js are Copyright (c) 2012 Jon Rohan, James M. Greene.<br>';
    content += 'Portions relating to effects.core.js, effects.js, effects.slide.js, jquery-ui.custom.min.js, jquery.autocomplete.js, jquery.countdown.js, jquery.effects.highlight.js, jquery.form.js, jquery.js, jquery.timeentry.js, ui.sortable.js, and ui.dialog.js are Copyright 2013 jQuery Foundation and other contributors http://jquery.com/<br>';
    content += 'Portions relating to Dovecot are licensed by authors listed at http://www.dovecot.org/doc/AUTHORS and http://www.dovecot.org/doc/COPYING<br>';
    content += 'Portions relating to cif parser are Copyright  2013 RCSB PDB. http://sw-tools.pdb.org/license.txt<br>';
    content += 'Portions relating to bitset.js v1.0.2 are Copyright (c) 2014, Robert Eisele. https://github.com/infusion/BitSet.js<br>';
    content += 'Portions relating to saveAs() FileSaver implementation and FileSaver.js are Copyright  2015 Eli Grey.<br>';
    content += 'Portions relating to surface construction are Copyright (c) 2009, 2013. Dong Xu and Yang Zhang. D. Xu, Y. Zhang (2009) Generating Triangulated Macromolecular Surfaces by Euclidean Distance Transform. PLoS ONE 4(12): e8140. D. Xu, H. Li, Y. Zhang (2013) Protein Depth Calculation and the Use for Improving Accuracy of Protein Fold Recognition. Journal of Computational Biology 20(10):805-816.<br>';
    content += 'Portions relating to docker are Copyright  2013-2015, Docker, Inc. https://github.com/docker/docker/blob/master/LICENSE<br>';
    content += 'Portions relating to dokku are Copyright (c) 2014, Docker, Inc. https://github.com/progrium/dokku</p>';
    content += '<p>Portions relating to md5.js are Copyright (c) 2014. emn178 https://github.com/emn178/js-md5</p>';
    content += '<p>Portions relating to RLE.js are Copyright (c) 2014. Simon https://github.com/sloosch/rle</p>';
    content += '<p>Permission is hereby granted, free of charge, to any person obtaining a copy ' +
    'of this software and associated documentation files (the Software), to deal in the Software ' +
    'without restriction, including without limitation the rights to use, copy, modify, merge, publish, ' +
    'distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the ' +
    'Software is furnished to do so, subject to the following conditions:</p>';

    content += '<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>';

    content += '<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>';
    content += '<p><strong>Version:</strong> 1.0.596</p>';
    content += '<p><strong>Browser Session:</strong> ' + this.loader.connectionID + '</p>';
    this.bodyText.innerHTML = content;
    this.el.appendChild(this.header);
    this.el.appendChild(this.subTitle);
    this.el.appendChild(this.bodyText);

    this.parentElement.appendChild(this.el);
};

Autodesk.Viewing.MolViewer.AboutView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.clickClose = function clickClose(event) {
        if(event.target === document.querySelector('#dialogLayer')) {
            self.parent.el.removeEventListener('click',self.clickClose);
            self.destroy();
        }
    };

    this.parent.el.addEventListener('click',self.clickClose);


};

Autodesk.Viewing.MolViewer.AboutView.prototype.getContent = function getContent() {
    return this.bodyText;
};

Autodesk.Viewing.MolViewer.AboutView.prototype.show = function show() {
    this.parent.show();
};

Autodesk.Viewing.MolViewer.AboutView.prototype.hide = function hide() {
    this.parent.hide();
};
;/**
 * Created by andrewkimoto on 7/26/16.
 */
Autodesk.Viewing.MolViewer.CitationView = function (args) {

    var me = Autodesk.Viewing.MolViewer.CitationView.prototype;
    this.app = args.app;
    this.viewer = args.viewer;
    this.modal = args.modal;
    this.type = 'CitationView';
    this.parent = this.app.ViewManager.getTopView('DialogView');
    this.parentElement = this.app.ViewManager.getTopView('DialogView').dialogDiv;
    if (this.parent.activeDialog) {
        this.parent.activeDialog.destroy(); //destroy active dialog if any
    }
    this.parent.activeDialog = this;
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this.height = 400;
    this.width = 600;
    this._initialize();
};

Autodesk.Viewing.MolViewer.CitationView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.CitationView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.CitationView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.CitationView.prototype.destroy = function destroy() {
    this.app.ViewManager.getTopView('DialogView').hide();
    this.parent.el.removeEventListener('click',self.clickClose);
    this.parent.activeDialog = null;
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);

};

Autodesk.Viewing.MolViewer.CitationView.prototype._initializeElements = function _initializeElements() {
    var content = '';
    var dialogView = this.app.ViewManager.getTopView('DialogView');

    if (this.modal) {
        dialogView.setModal();
    } else {
        dialogView.setModeless();
    }
    this.el = document.createElement('DIV');
    this.el.setAttribute('id','citation');
    dialogView.setDimensions(this.height,this.width);
    dialogView.setPosition(false);
    dialogView.setVerticalScroll(false);
    this.header = document.createElement('img');
    this.header.setAttribute('src','https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/about.png');
    this.bodyText = document.createElement('div');
    this.bodyText.style.width = "100%";

    content = "<h2>Please cite the Molecule Viewer:</h2>";

    content += "<p>The [output] for this paper was generated using Autodesk Molecule Viewer software, Version [0.2.1]. Copyright  2016 Autodesk Inc., San Francisco, California, USA. Available at: <a href ='http://moleculeviewer.bionano.autodesk.com'>moleculeviewer.bionano.autodesk.com</a>.</p>";

    content += "<p>Citation description:<br>Title: Autodesk Molecule Viewer<br>Author: Merry Wang, Michael Zyracki, Andrew Kimoto, Malte Tinnus, Dave Parker, Peter Jones,<br>Joseph Schaeffer, Dion Amago, Florencio Mazzoldi, Eli Groban.<br>";
    content += "Organization: Bio/Nano Group, Autodesk Research, Autodesk Inc.<br>Address: Pier 9, San Francisco, California, U.S.A.<br>Year: 2016<br>url: <a href='http://moleculeviewer.bionano.autodesk.com'>http://moleculeviewer.bionano.autodesk.com</a></p>";
    content += "<p>For our reference, please send us details of use at <a href='mailto:moleculeviewer@autodesk.com'>moleculeviewer@autodesk.com</a>.<br><br>"

    this.bodyText.innerHTML = content;
    this.el.appendChild(this.header);
    this.el.appendChild(this.bodyText);

    this.parentElement.appendChild(this.el);
};

Autodesk.Viewing.MolViewer.CitationView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.clickClose = function clickClose(event) {
        if(event.target === document.querySelector('#dialogLayer')) {
            self.parent.el.removeEventListener('click',self.clickClose);
            self.destroy();
        }
    };

    this.parent.el.addEventListener('click',self.clickClose);


};

Autodesk.Viewing.MolViewer.CitationView.prototype.getContent = function getContent() {
    return this.bodyText;
};

Autodesk.Viewing.MolViewer.CitationView.prototype.show = function show() {
    this.parent.show();
};

Autodesk.Viewing.MolViewer.CitationView.prototype.hide = function hide() {
    this.parent.hide();
};
;/**
 * Created by andrewkimoto on 10/5/16.
 */
/**
 * Created by andrewkimoto on 7/26/16.
 */
Autodesk.Viewing.MolViewer.VRView = function (args) {

    var me = Autodesk.Viewing.MolViewer.VRView.prototype;
    this.app = args.app;
    this.viewer = args.viewer;
    this.modal = args.modal;
    this.type = 'VRView';
    this.parent = this.app.ViewManager.getTopView('DialogView');
    this.parentElement = this.app.ViewManager.getTopView('DialogView').dialogDiv;
    if (this.parent.activeDialog) {
        this.parent.activeDialog.destroy(); //destroy active dialog if any
    }
    this.parent.activeDialog = this;
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this.height = 400;
    this.width = 600;
    this._initialize();
};

Autodesk.Viewing.MolViewer.VRView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.VRView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.VRView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
    me._getQrCode.call(this);
};

Autodesk.Viewing.MolViewer.VRView.prototype.destroy = function destroy() {
    this.app.ViewManager.getTopView('DialogView').hide();
    this.parent.el.removeEventListener('click',self.clickClose);
    this.parent.activeDialog = null;
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);

};

Autodesk.Viewing.MolViewer.VRView.prototype._initializeElements = function _initializeElements() {
    var subHead;
    var subText;
    var dialogView = this.app.ViewManager.getTopView('DialogView');

    if (this.modal) {
        dialogView.setModal();
    } else {
        dialogView.setModeless();
    }
    this.el = document.createElement('DIV');
    this.el.setAttribute('id','vrDialog');
    dialogView.setDimensions(this.height,this.width);
    dialogView.setPosition(false);
    dialogView.setVerticalScroll(false);
    this.header = document.createElement('div');
    this.header.setAttribute('class', 'vr-header');
    this.closeBox = document.createElement('div');
    this.closeBox.setAttribute('class','vr-close-box');
    this.headerText = document.createElement('h2');
    this.headerText.innerHTML = 'VR Mode';
    this.header.appendChild(this.headerText);
    this.header.appendChild(this.closeBox);
    this.bodyText = document.createElement('div');
    this.bodyText.setAttribute('class','vr-body');

    this.headsetDiv = document.createElement('div');
    this.headsetDiv.setAttribute('class','vr-section');
    this.headsetHeader = document.createElement('h3');
    this.headsetHeader.innerHTML = 'Desktop with VR headset';
    this.headsetText = document.createElement('p');
    this.headsetText.innerHTML = 'Connect your VR headset and start VR mode.';
    this.throbberDiv = document.createElement('div');
    this.throbberDiv.setAttribute('class','vr-throbber-div wide');
    this.throbber = document.createElement('p');
    this.throbber.setAttribute('class','throbber green');
    this.throbber.innerHTML = 'Set up VR and refresh your browser';
    // VR Extension will not load if there is no vrDisplay attached
    if(this.app.MoleculeViewer.loadedExtensions['Autodesk.Viewing.webVR']) {
       this.throbber.classList.add('hidden');
       if (this.app.MoleculeViewer.loadedExtensions['Autodesk.Viewing.webVR'].tool.isActive()) {
           // commented out until we have desktop vr working
           //this.vrEndButton.classList.remove('hidden');
           //this.headsetText.innerHTML = 'Click the <strong>End VR</strong> button to exit VR.';
       } else {
           //this.vrStartButton.classList.remove('hidden');
           this.headsetText.innerHTML = 'Click the <strong>Start VR</strong> button to start VR.';
       }
    }

    this.throbberDiv.appendChild(this.throbber);
    this.headsetDiv.appendChild(this.headsetHeader);
    this.headsetDiv.appendChild(this.headsetText);
    this.headsetDiv.appendChild(this.throbberDiv);
    this.bodyText.appendChild(this.headsetDiv);


    this.cardboardDiv = document.createElement('div');
    this.cardboardDiv.setAttribute('class','vr-section');
    this.cardboardHeader = document.createElement('h3');
    this.cardboardHeader.innerHTML = 'Mobile with Cardboard';
    this.cardboardText = document.createElement('p');
    this.cardboardText.innerHTML = 'Scan, or open this link with your mobile device.';
    this.cardboardThrobberDiv = document.createElement('div');
    this.cardboardThrobberDiv.setAttribute('class','vr-throbber-div');
    this.cardboardThrobber = document.createElement('p');
    this.cardboardThrobber.setAttribute('class','throbber');
    this.cardboardThrobber.setAttribute('id','cardboardThrobber');
    this.cardboardThrobber.innerHTML = 'Loading...';
    this.cardboardThrobberDiv.appendChild(this.cardboardThrobber);
    this.cardboardInfo = document.createElement('div');
    this.cardboardInfo.setAttribute('id','qrContainer');
    this.cardboardLinkDiv = document.createElement('div');
    this.cardboardLinkDiv.setAttribute('class','vr-link-div');
    this.cardboardLink = document.createElement('a');
    this.cardboardLink.setAttribute('class','cardboard-link');
    this.cardboardLink.setAttribute('target','_blank');
    this.cardboardLink.innerHTML = 'Viewer Link';
    this.cardboardLinkDiv.appendChild(this.cardboardLink);
    this.cardboardDiv.appendChild(this.cardboardHeader);
    this.cardboardDiv.appendChild(this.cardboardText);
    this.cardboardDiv.appendChild(this.cardboardThrobberDiv);
    this.cardboardDiv.appendChild(this.cardboardInfo);
    this.cardboardDiv.appendChild(this.cardboardLinkDiv);
    this.bodyText.appendChild(this.cardboardDiv);

    this.cardboardDiv = document.createElement('div');
    this.cardboardDiv.setAttribute('class','vr-section');

    this.el.appendChild(this.header);
    this.el.appendChild(this.bodyText);

    this.parentElement.appendChild(this.el);
};

Autodesk.Viewing.MolViewer.VRView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.clickClose = function clickClose(event) {
        if(event.target === document.querySelector('#dialogLayer') || event.target === document.querySelector('.vr-close-box')) {
            self.parent.el.removeEventListener('click',self.clickClose);
            self.destroy();
        }
    };

    this.startVR = function startVR() {
        //ViewManager.viewer.loadedExtensions['Autodesk.Viewing.webVR'].tool.activate();
        self.app.ViewManager.viewer.setActiveNavigationTool("vr");

        self.headsetText.innerHTML = 'Click the <strong>End VR</strong> button to exit VR.';
        self.vrStartButton.classList.add('hidden');
        self.vrEndButton.classList.remove('hidden');
    };

    this.endVR = function endVR() {
        self.app.ViewManager.viewer.loadedExtensions['Autodesk.Viewing.webVR'].tool.deactivate();
        self.headsetText.innerHTML = 'Click the <strong>Start VR</strong> button to start VR.';
        self.vrStartButton.classList.remove('hidden');
        self.vrEndButton.classList.add('hidden');
    };

    this.startVRBind = this.startVR.bind(this);
    this.endVRBind = this.endVR.bind(this);

    // commented out until we have desktop vr working
    //this.vrStartButton.addEventListener('click',self.startVRBind);
    //this.vrEndButton.addEventListener('click',self.endVRBind);
    this.parent.el.addEventListener('click',self.clickClose);
    this.closeBox.addEventListener('click',self.clickClose);

};

Autodesk.Viewing.MolViewer.VRView.prototype._getQrCode = function _getQrCode() {
    var image = null;
    var target = document.querySelector('#qrContainer');
    var origin = document.querySelector('#qrCode');
    if (origin) {
        image = origin.firstChild;
    }

    if(image && target) {
        image = image.cloneNode(true);
        target.appendChild(image);
        target.classList.add('opaque');
        this.cardboardLink.setAttribute('href',origin.getAttribute('data-url'));
        this.cardboardLink.classList.add('opaque');
        this.cardboardThrobber.classList.add('hidden');
    }
};

Autodesk.Viewing.MolViewer.VRView.prototype.getContent = function getContent() {
    return this.bodyText;
};

Autodesk.Viewing.MolViewer.VRView.prototype.show = function show() {
    this.parent.show();
};

Autodesk.Viewing.MolViewer.VRView.prototype.hide = function hide() {
    this.parent.hide();
};

;/**
 * Created by andrewkimoto on 11/2/16.
 */
Autodesk.Viewing.MolViewer.AutoVRView = function (args) {

    var me = Autodesk.Viewing.MolViewer.AutoVRView.prototype;
    this.app = args.app
    this.viewer = args.viewer;
    this.type = 'AutoVRView';
    this.parent = this.app.ViewManager.getTopView('DialogView');
    this.parentElement = this.app.ViewManager.getTopView('DialogView').dialogDiv;
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this.height = 250;
    this.width = 350;
    this._initialize();
};

Autodesk.Viewing.MolViewer.AutoVRView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.AutoVRView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.AutoVRView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.AutoVRView.prototype.destroy = function destroy() {
    this.app.ViewManager.getTopView('DialogView').hide();
    this.parent.el.removeEventListener('click', self.clickClose);
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);

};

Autodesk.Viewing.MolViewer.AutoVRView.prototype._initializeElements = function _initializeElements() {
    var subHead;
    var subText;
    var dialogView = this.app.ViewManager.getTopView('DialogView');
    this.el = document.createElement('DIV');
    this.el.setAttribute('id', 'autoVRDialog');
    this.parentElement.style.background = 'transparent';
    this.parentElement.style.boxShadow = '0 0 0 rgba(0,0,0,0)';
    dialogView.setDimensions(this.height, this.width);
    dialogView.setPosition(false);
    dialogView.setVerticalScroll(false);
    //this.header = document.createElement('div');
    //this.header.setAttribute('class', 'vr-header');
    //this.closeBox = document.createElement('div');
    //this.closeBox.setAttribute('class','vr-close-box');
    //this.headerText = document.createElement('h2');
    //this.headerText.innerHTML = 'Start VR';
    //this.header.appendChild(this.headerText);
    //this.header.appendChild(this.closeBox);
    this.bodyText = document.createElement('div');
    this.bodyText.setAttribute('class', 'auto-vr-body');

    this.vrButton = document.createElement('div');
    this.vrButton.classList.add('auto-vr-button');
    this.vrButton.innerHTML = 'Start VR';
    this.bodyText.appendChild(this.vrButton);

    //this.el.appendChild(this.header);
    this.el.appendChild(this.bodyText);

    this.parentElement.appendChild(this.el);
};

Autodesk.Viewing.MolViewer.AutoVRView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.clickClose = function clickClose(event) {
        if (event.target === document.querySelector('#dialogLayer') || event.target === document.querySelector('.vr-close-box')) {
            self.parent.el.removeEventListener('click', self.clickClose);
            self.destroy();
        }
    };

    this.parent.el.addEventListener('click', self.clickClose);
    this.vrButton.addEventListener('click', function () {
        self.destroy();
        this.app.ViewManager.getTopView('BrowserView').startVR();
    });
};

Autodesk.Viewing.MolViewer.AutoVRView.prototype.getContent = function getContent() {
    return this.bodyText;
};

Autodesk.Viewing.MolViewer.AutoVRView.prototype.show = function show() {
    this.parent.show();
};

Autodesk.Viewing.MolViewer.AutoVRView.prototype.hide = function hide() {
    this.parent.hide();
};

;/**
 * Created by andrewkimoto on 8/4/16.
 */

Autodesk.Viewing.MolViewer.GalleryBuilderView = function (args) {

    var me = Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype;
    this.app = args.app;
    this.viewer = args.viewer;
    this.modal = args.modal;
    this.type = 'GalleryBuilderView';
    this.parent = this.app.ViewManager.getTopView('DialogView');
    this.parentElement = this.app.ViewManager.getTopView('DialogView').dialogDiv;
    if (this.parent.activeDialog) {
        this.parent.activeDialog.destroy(); //destroy active dialog if any
    }
    this.parent.activeDialog = this;
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this.height = 400;
    this.width = 600;
    this.gallerySessions = [];
    this._initialize();
};

Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
    me.addGallerySession.call(this);
};

Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype.destroy = function destroy() {
    this.app.ViewManager.getTopView('DialogView').hide();
    this.parent.el.removeEventListener('click',self.clickClose);
    this.parent.activeDialog = null;
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);

};

Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype._initializeElements = function _initializeElements() {
    var content = '';
    var dialogView = this.app.ViewManager.getTopView('DialogView');

    if (this.modal) {
        dialogView.setModal();
    } else {
        dialogView.setModeless();
    }
    this.el = document.createElement('DIV');
    this.el.setAttribute('id','galleryBuilder');
    dialogView.setDimensions(this.height,this.width);
    dialogView.setPosition(false);
    dialogView.setVerticalScroll(false);
    this.title = document.createElement('h2');
    this.title.setAttribute('class','dialog-title');
    this.title.innerHTML = 'Gallery Builder';
    this.bodyText = document.createElement('div');
    this.bodyText.style.width = "100%";
    this.sessionContainer = document.createElement('div');
    this.sessionContainer.setAttribute('class','session-container');
    this.buttonPanel = document.createElement('div');
    this.buttonPanel.setAttribute('class','gallery-button-panel');
    this.btnAddSession = document.createElement('button');
    this.btnAddSession.setAttribute('class','dialog-button btn-gallery');
    this.btnAddSession.innerHTML = 'Add Gallery Session';
    this.btnSaveGallery = document.createElement('button');
    this.btnSaveGallery.setAttribute('class','dialog-button btn-gallery');
    this.btnSaveGallery.innerHTML = 'Save Gallery';
    this.buttonPanel.appendChild(this.btnAddSession);
    this.buttonPanel.appendChild(this.btnSaveGallery);

    content = "<p>Enter a Short Title and a Session ID for each session you wish to include in your gallery. ";
    content += "Click 'Add Gallery' Session to add more sessions.  Click 'Save Gallery' to save the gallery and generate the gallery link.</p>";
    this.bodyText.innerHTML = content;

    this.outputDiv = document.createElement('div');
    this.outputDiv.setAttribute('class','gallery-output');
    this.outputMessage = document.createElement('div');
    this.outputMessage.setAttribute('class','gallery-message');
    this.outputButtonPanel = document.createElement('div');
    this.outputButtonPanel.setAttribute('class','gallery-button-panel single');
    this.btnGalleryBack = document.createElement('button');
    this.btnGalleryBack.setAttribute('class','dialog-button btn-gallery');
    this.btnGalleryBack.innerHTML = 'Go Back';
    this.outputButtonPanel.appendChild(this.btnGalleryBack);
    this.outputDiv.appendChild(this.outputMessage);
    this.outputDiv.appendChild(this.outputButtonPanel);

    this.el.appendChild(this.title);
    this.el.appendChild(this.bodyText);
    this.el.appendChild(this.sessionContainer);
    this.el.appendChild(this.buttonPanel);
    this.el.appendChild(this.outputDiv);
    this.parentElement.appendChild(this.el);
};

Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.clickClose = function clickClose(event) {
        if(event.target === document.querySelector('#dialogLayer')) {
            self.parent.el.removeEventListener('click',self.clickClose);
            self.destroy();
        }
    };

    this.parent.el.addEventListener('click',self.clickClose);

    this.addGallerySessionBind = this.addGallerySession.bind(this);
    this.saveGalleryBind = this.saveGallery.bind(this);

    this.btnAddSession.addEventListener('click',self.addGallerySessionBind);
    this.btnSaveGallery.addEventListener('click',self.saveGalleryBind);
    this.btnGalleryBack.addEventListener('click',function(){self.outputDiv.classList.remove('visible');});
};

Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype.getContent = function getContent() {
    return this.bodyText;
};

Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype.show = function show() {
    this.parent.show();
};

Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype.hide = function hide() {
    this.parent.hide();
};

Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype.addGallerySession = function addGallerySession() {
    var galleryRow,
        galleryTitle,
        galleryTitleLabel,
        galleryTitleValue,
        galleryTitleInput,
        gallerySession,
        gallerySessionLabel,
        gallerySessionValue,
        gallerySessionInput,
        id = 'S' + THREE.Math.generateUUID(),
        len = this.gallerySessions.length + 1;

    galleryRow = document.createElement('div');
    galleryRow.setAttribute('class','gallery-row');
    galleryRow.setAttribute('id', id);
    galleryTitle = document.createElement('div');
    galleryTitle.setAttribute('class','gallery-title');
    galleryTitleLabel = document.createElement('div');
    galleryTitleLabel.setAttribute('class','gallery-title-label');
    galleryTitleLabel.innerHTML = 'Gallery Item Title ' + len;
    galleryTitleValue = document.createElement('div');
    galleryTitleValue.setAttribute('class','gallery-title-value');
    galleryTitleInput = document.createElement('input');
    galleryTitleInput.setAttribute('class','gallery-title-input');
    galleryTitleValue.appendChild(galleryTitleInput);
    galleryTitle.appendChild(galleryTitleLabel);
    galleryTitle.appendChild(galleryTitleValue);

    gallerySession = document.createElement('div');
    gallerySession.setAttribute('class','gallery-session');
    gallerySessionLabel = document.createElement('div');
    gallerySessionLabel.setAttribute('class','gallery-session-label');
    gallerySessionLabel.innerHTML = 'Gallery Item SessionId ' + len;
    gallerySessionValue = document.createElement('div');
    gallerySessionValue.setAttribute('class','gallery-session-value');
    gallerySessionInput = document.createElement('input');
    gallerySessionInput.setAttribute('class','gallery-session-input');
    gallerySessionValue.appendChild(gallerySessionInput);
    gallerySession.appendChild(gallerySessionLabel);
    gallerySession.appendChild(gallerySessionValue);
    galleryRow.appendChild(galleryTitle);
    galleryRow.appendChild(gallerySession);
    this.sessionContainer.appendChild(galleryRow);
    this.gallerySessions.push(id);
};

//generate gallery json and pass it to apiconnector
Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype.saveGallery = function saveGallery() {
    var self = this,
        gallery = {},
        galleryString,
        frame,
        i,
        sessionElement,
        url,
        output;

    gallery.frames = [];
    for (i = 0; i < this.gallerySessions.length; ++i) {
        sessionElement = document.querySelector('#' + this.gallerySessions[i]);
        frame = {};
        frame.name = sessionElement.querySelector('.gallery-title-input').value;
        frame.sessionId = sessionElement.querySelector('.gallery-session-input').value;
        if(frame.name !== '' && frame.sessionId !== '') {  //don't include empty sessions
            gallery.frames.push(frame);
        }
    }
    galleryString = JSON.stringify(gallery);
    console.log(gallery);
    console.log(galleryString);
    var promise = this.app.ApiConnector.saveGallery(gallery);
    promise.then(function(data) {
        var retVal;
        if (typeof data === 'object') {
            retVal = false;
        } else {
            retVal = location.protocol + '//' + location.host + '/gallery?gid=' + data;
        }
        self.showOutput(retVal);
    })
        .catch(function(err) {
            self.showOutput(err);
        });


};

Autodesk.Viewing.MolViewer.GalleryBuilderView.prototype.showOutput = function showOutput(output) {
    if(output) {
        this.outputMessage.innerHTML = 'Gallery URL<br><br><input style="width:calc(100% - 10px);" id="galleryOutputURL" class="" value="'+output+'">';
        this.app.container.querySelector('#galleryOutputURL').focus();
        this.app.container.querySelector('#galleryOutputURL').select();
    } else {
        this.outputMessage.innerHTML = 'Failed to save Gallery.';
    }

    this.outputDiv.classList.add('visible');
};


;Autodesk.Viewing.MolViewer.PrintView = function (args) {

    var me = Autodesk.Viewing.MolViewer.PrintView.prototype;
    this.app = args.app;
    this.viewer = args.viewer;
    this.molMan = args.app.MolMan;
    this.loader = args.app.loader;
    this.modal = args.modal;
    this.type = 'PrintView';
    this.parent = this.app.ViewManager.getTopView('DialogView');
    this.parentElement = this.app.ViewManager.getTopView('DialogView').dialogDiv;
    if (this.parent.activeDialog) {
        this.parent.activeDialog.destroy(); //destroy active dialog if any
    }
    this.parent.activeDialog = this;
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this.height = 400;
    this.width = 550;
    this.scaffolds = ['M13mp18','M13KO7','p7308','p7560','p7704','p8064','p8100','p8634'];
    this._initialize();
};

Autodesk.Viewing.MolViewer.PrintView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.PrintView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.PrintView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.PrintView.prototype.destroy = function destroy() {
    this.app.ViewManager.getTopView('DialogView').hide();
    this.parent.el.removeEventListener('click',self.clickClose);
    this.parent.activeDialog = null;
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);

};

Autodesk.Viewing.MolViewer.PrintView.prototype._initializeElements = function _initializeElements() {
    var content = '';
    var info;
    var points;
    var list;
    var bullet;
    var dialogView = this.app.ViewManager.getTopView('DialogView');

    if (this.modal) {
        dialogView.setModal();
    } else {
        dialogView.setModeless();
    }
    this.el = document.createElement('DIV');
    this.el.setAttribute('id','print3D');
    dialogView.setDimensions(this.height,this.width);
    dialogView.setPosition(false);
    dialogView.setVerticalScroll(false);

    this.title = document.createElement('h2');
    this.title.setAttribute('class','dialog-title');
    this.title.innerHTML = 'Create File for 3D Printing';

    info = document.createElement('p');
    info.setAttribute('class','dialog-subtitle');
    info.innerHTML = 'You can a create high resolution STL file or files of your current view.<br>';
    info.innerHTML += 'STL files are accepted by most online print services and at home printers.<br>';
    info.innerHTML += "Mix different representations and hide whatever you don't want to print.";
    points = document.createElement('p');
    points.setAttribute('class','dialog-subtitle');
    list = document.createElement('ul');
    bullet = document.createElement('li');
    bullet.innerHTML = 'Cutting planes and the Explode tool are ignored when creating the file.';
    list.appendChild(bullet);
    bullet = document.createElement('li');
    bullet.innerHTML = 'Different representations are separated into individual files that need to be assembled after printing.';
    list.appendChild(bullet);
    list.appendChild(bullet);
    bullet = document.createElement('li');
    bullet.innerHTML = 'Some views are delicate and difficult to print.  Learn how to create great 3D prints <a target="_blank" href="https://forum.bionano.autodesk.com/t/exporting-for-3d-print/137">here</a>.';
    list.appendChild(bullet);
    points.appendChild(list);
    this.submitButton = this.buildButton('Create File');
    this.submitButton.setAttribute('class','btn-dialog-submit');
    this.el.appendChild(this.title);
    this.el.appendChild(info);
    this.el.appendChild(points);
    this.el.appendChild(this.submitButton);
    this.parentElement.appendChild(this.el);
};

Autodesk.Viewing.MolViewer.PrintView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.clickClose = function clickClose(event) {
        if(event.target === document.querySelector('#dialogLayer')) {
            self.parent.el.removeEventListener('click',self.clickClose);
            self.destroy();
        }
    };

    this.parent.el.addEventListener('click',self.clickClose);

    this.createInputElement = function createFileElement(name,id,value) {
        var inputElement = document.querySelector('#'+id);

        if (!inputElement) {
            inputElement = document.createElement('input');
            inputElement.setAttribute('type', 'text');
            inputElement.setAttribute('class', 'file-hidden');
            inputElement.setAttribute('id', id);
            inputElement.setAttribute('name', name);
            inputElement.style.opacity = 0;
            inputElement.setAttribute('value',value);
            self.el.appendChild(inputElement);
        }
        return inputElement;
    };

    this.setInputValue = function setInputValue(id,val) {
        var input = document.querySelector('#'+id);
        if (input) {
            input.value = val;
        }
    };

    this.submitForm = function submitForm(event) {
        document.querySelector('#dialogLayer').classList.add('hidden'); //hide the dialog
        var sv = self.app.ViewManager.getTopView('StatusView');
        sv.showCustomMessage('Generating 3D Print Files...');
        function get_url_parameter(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
            var regexS = "[\\?&]"+name+"=([^&#]*)";
            var regex = new RegExp( regexS );
            var results = regex.exec( url );
            return results == null ? null : results[1];
        }

        var dataElement = this.createInputElement('dataelement','dataElement',this.printElements);

        var formData = new FormData();

        formData.append("dataelement",encodeURI(dataElement.value));
        var protocol = location.protocol;
        var printURL = '/print3d';
        var data = {};
        var url = '';
        var xhr = new XMLHttpRequest();

        xhr.onreadystatechange = function() {
            var hv = self.app.ViewManager.getTopView('HeaderView');
            if(xhr.readyState === 2) { // request accepted
                self.parent.el.removeEventListener('click',self.clickClose);
                hv.hideMenus();
                self.destroy();
            }
        };
        xhr.open('POST', printURL, true);
        xhr.setRequestHeader("Connection-ID", self.loader.getConnectionID());
        xhr.onload = function(e) {
            var sv = self.app.ViewManager.getTopView('StatusView');
            var hv = self.app.ViewManager.getTopView('HeaderView');
            var aData;
            if (this.status == 200) {
                self.printElements = null;
                data = e.currentTarget.response;
                if (data !== 'OK') {
                    sv.showError();
                }
                hv.hideMenus();
                var protocol = location.protocol;
                var url =  data.replace(/^\/tmp/,'');
                var dlIframe = document.querySelector('#dlIframe');
                var dlLink = document.createElement('a');
                dlLink.setAttribute('href', url);
                dlLink.setAttribute('target', 'dlIframe');
                document.body.appendChild(dlLink);
                dlLink.click();
                dlLink.remove();

                sv.hide();
                self.destroy();

            } else {
                sv.showError();
                hv.hideMenus();
                self.printElements = null;
                console.log('error ',self.status);
                self.destroy();
            }
        };
        xhr.send(formData);

    };

    this.submitButton.addEventListener('click', function(event) {this.submitForm(event)}.bind(this));

    this.printObject = this.molMan.molModels[this.molMan.currentMolModelID].getVisible();
    this.printObject.md5 = this.molMan.molModels[this.molMan.currentMolModelID].md5;
    this.printElements = JSON.stringify(this.printObject);
};

Autodesk.Viewing.MolViewer.PrintView.prototype.show = function show() {
    this.parent.show();
};

Autodesk.Viewing.MolViewer.PrintView.prototype.hide = function hide() {
    this.parent.hide();
};

Autodesk.Viewing.MolViewer.PrintView.prototype.buildValue = function buildValue(src) {
    var val = src[0],
        output = document.createElement('div');
    output.setAttribute('class','dialog-value');
    output.innerHTML = val;
    return output;
};

Autodesk.Viewing.MolViewer.PrintView.prototype.buildButton = function buildButton(val) {
    var output = document.createElement('div');
    output.setAttribute('class','dialog-button');
    output.innerHTML = val;
    return output;
};
;Autodesk.Viewing.MolViewer.SplashView = function (args) {

    var me = Autodesk.Viewing.MolViewer.SplashView.prototype;
    this.app = args.app;
    this.viewer = args.viewer;
    this.modal = args.modal;
    this.type = 'SplashView';
    this.parent = this.app.ViewManager.getTopView('DialogView');
    this.parentElement = this.parent.dialogDiv;
    if (this.parent.activeDialog) {
        this.parent.activeDialog.destroy(); //destroy active dialog if any
    }
    this.parent.activeDialog = this;
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this.startupData = me.startupData();
    this.version = "0.3.0";
    this._initialize();
};

Autodesk.Viewing.MolViewer.SplashView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.SplashView.prototype._initialize = function _initialize() {
    this.parentElement.style.overflowY = 'hidden';
    var me = Autodesk.Viewing.MolViewer.SplashView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.SplashView.prototype.destroy = function destroy() {
    this.app.ViewManager.getTopView('DialogView').hide();
    this.parent.activeDialog = null;
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);

};

Autodesk.Viewing.MolViewer.SplashView.prototype._initializeElements = function _initializeElements() {

    this.desktopSplashScreen = function(element) {

        this.splashTopTooltips = document.createElement('div');
        this.splashTopTooltips.className = "splash-top-tooltips";

        this.toolTips = document.createElement('div');
        this.toolTips.className = "tool-tips";
        this.toolTips.id = "tool-tips";

        this.panes = document.createElement('div');
        this.panes.className = "panes";

        for (var i = 1; i <= this.startupData.tooltip.length; i++) {
            var targetSpan = document.createElement('span');
            targetSpan.id = "target-item-" + i;
            this.panes.appendChild(targetSpan);
        }

        // Tooltip creator
        for (i = 0; i < this.startupData.tooltip.length; i++) {

            var j, k, toolTip, toolTipContainer, toolTipArrow, toolTipHeading, toolTipText, nextTooltip, button;

            toolTip = document.createElement('div');
            toolTip.className = "tool-tip item-" + (i + 1);

            toolTipContainer = document.createElement('div');
            toolTipContainer.className = 'container';
            toolTipContainer.setAttribute('style', this.startupData.tooltip[i].containerPosition);

            toolTipHeading = document.createElement('div');
            toolTipHeading.className = "heading";
            toolTipHeading.innerHTML = this.startupData.tooltip[i].heading;

            toolTipContainer.appendChild(toolTipHeading);

            toolTipText = document.createElement('div');
            toolTipText.className = "text";
            toolTipText.innerHTML = this.startupData.tooltip[i].text;

            toolTipContainer.appendChild(toolTipText);

            nextTooltip = document.createElement('a');
            nextTooltip.href = "#target-item-" + (i+2);
            nextTooltip.className = 'next-tooltip';

            if (i === this.startupData.tooltip.length - 1) {
                nextTooltip.id = "last-tooltip";
            }

            button = document.createElement('button');
            button.className = 'button  next-tooltip-css';
            button.innerHTML = 'Next';

            nextTooltip.appendChild(button);

            toolTipContainer.appendChild(nextTooltip);

            toolTip.appendChild(toolTipContainer);

            toolTipArrow = document.createElement('div');
            toolTipArrow.className = "tool-tip-arrow";
            toolTipArrow.setAttribute('style', this.startupData.tooltip[i].arrowPosition);
            toolTip.appendChild(toolTipArrow);

            this.panes.appendChild(toolTip);
        }

        this.toolTips.appendChild(this.panes);

        this.splashTopTooltips.appendChild(this.toolTips);

        element.appendChild(this.splashTopTooltips);

        this.splashBottom = document.createElement('div');
        this.splashBottom.className = "splash-bottom";

        // Column 1
        this.col1 = document.createElement('div');
        this.col1.className = "col-1";

        this.text = document.createElement('div');
        this.text.className = "text";

        this.listHeading = document.createElement('div');
        this.listHeading.className = 'list-heading';
        this.listHeading.innerHTML = 'New in version ' + this.version + ":";

        this.text.appendChild(this.listHeading);

        this.list = document.createElement('ul');

        for( i = 0; i < this.startupData.newInThisVersionList.col1.length; i++) {
            this.listItem = document.createElement('li');
            this.listItem.innerHTML = this.startupData.newInThisVersionList.col1[i];
            this.list.appendChild(this.listItem);
        }

        this.text.appendChild(this.list);

        this.col1.appendChild(this.text);

        this.splashBottom.appendChild(this.col1);

        // Column 2
        this.col2 = document.createElement('div');
        this.col2.className = "col-2";

        this.text = document.createElement('div');
        this.text.className = "text";
        this.text.style.marginTop = "15px";

        this.list = document.createElement('ul');

        for( i = 0; i < this.startupData.newInThisVersionList.col2.length; i++) {
            this.listItem = document.createElement('li');
            this.listItem.innerHTML = this.startupData.newInThisVersionList.col2[i];
            this.list.appendChild(this.listItem);
        }

        this.text.appendChild(this.list);

        this.col2.appendChild(this.text);

        this.splashBottom.appendChild(this.col2);

        // Column 3
        this.col3 = document.createElement('div');
        this.col3.className = "col-3";

        this.text = document.createElement('div');
        this.text.className = "text";
        this.text.innerHTML = "Sign up for Autodesk BioNano Research updates";

        this.col3.appendChild(this.text);

        this.emailForm = document.createElement('form');
        this.emailForm.name = "emailForm";
        this.emailForm.action = "mailto:newsletter.bionano@autodesk.com?Subject=Join Newsletter (Molecule Viewer)";
        this.emailForm.method = "post";
        this.emailForm.enctype = "text/plain";

        this.text = document.createElement('div');
        this.text.className = "text email";

        this.emailInput = document.createElement('div');
        this.emailInput.className = "email-input";

        this.input = document.createElement('input');
        this.input.placeholder = "Email Address";
        this.input.type = "email";
        this.input.name = "mail";

        this.emailInput.appendChild(this.input);

        this.submit = document.createElement('input');
        this.submit.type = "submit";

        this.emailInput.appendChild(this.submit);

        this.text.appendChild(this.emailInput);

        this.emailForm.appendChild(this.text);

        this.col3.appendChild(this.emailForm);

        this.text = document.createElement('div');
        this.text.className = "text email";
        this.text.innerHTML = "Feedback? Questions? We are all ears and would love to hear from you. ";
        this.text.innerHTML += "<a href='mailto:moleculeviewer@autodesk.com?Subject=Feedback Molecule Viewer'>Contact Us</a>";

        this.col3.appendChild(this.text);

        this.splashBottom.appendChild(this.col3);

        element.appendChild(this.splashBottom);
    };

    this.mobileSplashScreen = function(element) {
        this.splashTopTooltips = document.createElement('div');
        this.splashTopTooltips.className = "splash-top-tooltips";

        // Load mobile tooltips, otherwise tablet
        if (window.innerWidth <= Autodesk.Viewing.MolViewer.MAX_PHONE_MODE_RESOLUTION) {
            this.touchToolTips = this.startupData.mobileToolTips;
        } else {
            this.touchToolTips = this.startupData.tabletToolTips;
        }

        for(var i = 0; i < this.touchToolTips.length; i++) {
            var toolTipImage, image;

            image = document.createElement('img');
            if (i !== 0) {
                image.className = "hide";
            }

            if (i === this.touchToolTips.length - 1) {
                image.id = "last-tooltip";
            }


            image.src = this.touchToolTips[i];
            image.setAttribute('data-tooltip-id', i);

            this.splashTopTooltips.appendChild(image);
        }

        this.toolTipIndicator = document.createElement('div');
        this.toolTipIndicator.className = "tool-tip-indicator";

        for (i = 0; i < this.touchToolTips.length; i++) {
            var indicatorItem = document.createElement('div');
            indicatorItem.id = "tooltipIndicator-" + i;
            indicatorItem.className = "indicator-item";
            if (i === 0) {
                indicatorItem.className += " active";
            }

            this.toolTipIndicator.appendChild(indicatorItem);
        }

        this.splashTopTooltips.appendChild(this.toolTipIndicator);

        this.skip = document.createElement('div');
        this.skip.className = "full-width-button skip";
        this.skip.innerHTML = "Skip";

        this.splashTopTooltips.appendChild(this.skip);

        element.appendChild(this.splashTopTooltips);
    };

    var content = '';
    var dialogView = this.app.ViewManager.getTopView('DialogView');

    if (this.modal) {
        dialogView.setModal();
    } else {
        dialogView.setModeless();
    }
    this.el = document.createElement('DIV');
    this.el.setAttribute('id','splash');

    // For devices less than 768px, splash screen is forced to portrait mode
    // For devices more than 768px, splash screen is forced to landscape mode

    if (isTouchDevice()) {
        if (window.innerWidth <= Autodesk.Viewing.MolViewer.MAX_PHONE_MODE_RESOLUTION) {
            // window.orientation == 0 -> portrait
            // window.orientation != 0 -> landscape
            if ((window.orientation === 0) || (window.orientation === undefined)) {
                dialogView.setDimensions(100, 100, true, true);
            } else {
                dialogView.setDimensions(window.innerWidth, window.innerHeight, true, false);
                dialogView.setDimensions(window.innerWidth, window.innerHeight, true, false, true);
                dialogView.setPosition(true, window.orientation);
            }
            dialogView.setOrientation("portrait", window.orientation);
        } else {
            if (window.orientation !== 0) {
                dialogView.setDimensions(100, 100, true, true);
                dialogView.setDimensions(100,100, true,true, true);
            } else {
                dialogView.setDimensions(window.innerWidth, window.innerHeight, true, false);
                dialogView.setDimensions(window.innerWidth, window.innerHeight, true, false, true);
                dialogView.setPosition(true, window.orientation);
            }
            dialogView.setOrientation('landscape', window.orientation);
        }
    } else {
        dialogView.setDimensions(100, 100, true, true);
    }

    dialogView.setVerticalScroll(false);

    this.pinkLogo = document.createElement('div');
    this.pinkLogo.className = "logo pink";

    this.el.appendChild(this.pinkLogo);

    this.skip = document.createElement('div');
    this.skip.className = "skip-startup";

    this.skipImage = document.createElement('div');
    this.skipImage.className = "skip-image";

    this.skip.appendChild(this.skipImage);

    this.el.appendChild(this.skip);

    this.splashTop = document.createElement('div');
    this.splashTop.className = "splash-top";

    this.heading = document.createElement('div');
    this.heading.className = "heading";

    this.molecule = document.createElement('div');
    this.molecule.className = "molecule";

    this.heading.appendChild(this.molecule);

    this.titleText = document.createElement('div');
    this.titleText.className = "title-text";
    this.titleText.innerHTML = "<span class='pink '> Autodesk Molecule Viewer</span";

    this.heading.appendChild(this.titleText);

    this.headingText = document.createElement('div');
    this.headingText.className = "heading-text hide-on-mobile";
    this.headingText.innerHTML = "Explore, edit and share molecules and DNA origami designs.";

    this.heading.appendChild(this.headingText);

    this.splashTop.appendChild(this.heading);

    this.buttons = document.createElement('div');
    this.buttons.className = "buttons hide-on-mobile";

    this.gettingStarted  = document.createElement('a');
    this.gettingStarted.className = "getting-started";
    this.gettingStarted.href = "#";
    this.button = document.createElement('button');
    this.button.className = "get-button-css button";
    this.button.innerHTML = "Get Started";

    this.gettingStarted.appendChild(this.button);

    this.buttons.appendChild(this.gettingStarted);

    this.splashTop.appendChild(this.buttons);

    this.autodeskLogo = document.createElement('div');
    this.autodeskLogo.className = "autodesk-logo";

    this.imageDiv = document.createElement('div');
    this.imageDiv.className = "image";

    this.autodeskLogo.appendChild(this.imageDiv);

    this.splashTop.appendChild(this.autodeskLogo);

    this.el.appendChild(this.splashTop);

    if (isTouchDevice()) {
        this.mobileSplashScreen(this.el);
    } else {
        this.desktopSplashScreen(this.el);
    }

    this.parentElement.appendChild(this.el);
};

Autodesk.Viewing.MolViewer.SplashView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.destroySplashView = function destroySplashView(event) {

        event.target.parentNode.href = "#";
        self.destroy();

        // Set Cookie so that the startup experience wont show up again
        self.app.ApiConnector.setCookieItem('startUp', 'hide', new Date(Date.now() + (365*24*60*60*1000)));
    };

    // To disable iOS overflow
    this.splashTop.addEventListener('touchmove', function(event) {
        event.preventDefault();
    });

    this.splashTopTooltips.addEventListener('touchmove', function(event) {
        event.preventDefault();
    });

    this.changeOrientation = function changeOrientation() {
        var dialogView = self.app.ViewManager.getTopView('DialogView');

        if (window.innerWidth <= Autodesk.Viewing.MolViewer.MAX_PHONE_MODE_RESOLUTION) {
            if (window.orientation === 0) {
                dialogView.setDimensions(100, 100, true, true);
                dialogView.setDimensions(100,100, true,true, true);
            } else {
                dialogView.setDimensions(window.innerWidth, window.innerHeight, true, false);
                dialogView.setDimensions(window.innerWidth, window.innerHeight, true, false, true);
                dialogView.setPosition(true, window.orientation);
            }
            dialogView.setOrientation("portrait", window.orientation);

        } else {
            if (window.orientation !== 0) {
                dialogView.setDimensions(100, 100, true, true);
                dialogView.setDimensions(100,100, true,true, true);
            } else {
                dialogView.setDimensions(window.innerWidth, window.innerHeight, true, false);
                dialogView.setDimensions(window.innerWidth, window.innerHeight, true, false, true);
                dialogView.setPosition(true, window.orientation);
            }
            dialogView.setOrientation("landscape", window.orientation);
        }
    };

    // Orientation change detection only needed for touch devices
    if (isTouchDevice()) {
        if (av.isIOSDevice()) {
            window.addEventListener('orientationchange', this.changeOrientation);
        } else {
            window.addEventListener('resize', this.changeOrientation);
        }
    }

    // Launch the tooltips for mobile/tablet
    this.splashTop.addEventListener('touchstart', function launchMobileToolTips(event) {
        self.splashTop.classList.remove('show');
        self.splashTop.classList.add('hide');
        self.splashTopTooltips.classList.add('show');
        self.splashTop.removeEventListener('touchstart', launchMobileToolTips);
    });

    this.splashTopTooltips.addEventListener('touchstart', function(event) {
        document.getElementById('tooltipIndicator-' + event.target.dataset.tooltipId).classList.remove('active');
        document.getElementById('tooltipIndicator-' + (parseInt(event.target.dataset.tooltipId) + 1)).classList.add('active');

        event.target.classList.add('hide');
        event.target.nextSibling.classList.remove('hide');
        event.preventDefault();
    });

    this.skip.addEventListener('touchstart', this.destroySplashView);
    this.skip.addEventListener('click', this.destroySplashView);

    document.getElementById('last-tooltip').addEventListener('touchstart', this.destroySplashView);
    document.getElementById('last-tooltip').addEventListener('click', this.destroySplashView);

    this.gettingStarted.addEventListener('click', function(event) {
        self.splashTop.classList.add('hide');
        self.splashTop.parentNode.parentNode.classList.add("transparent");
        self.splashTopTooltips.classList.add('show');
        self.skip.classList.add('show');
    });

};

Autodesk.Viewing.MolViewer.SplashView.prototype.startupData = function startupData() {
    var data = {};
    // Adding 20 pixel cushion
    var browser = document.getElementById('browser');
    var inspector = document.getElementById('inspectorPanel');
    var browserWidth = browser ? browser.offsetWidth + 20 : 0;
    var inspectorWidth = inspector ? inspector.offsetWidth + 20 : 0;

    data.mobileToolTips  = [
        'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/tooltips/mobile-tooltip-1.png',
        'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/tooltips/mobile-tooltip-2.png',
        'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/tooltips/mobile-tooltip-3.png'
    ];

    data.tabletToolTips = [
        'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/tooltips/tablet-tooltip-1.png',
        'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/tooltips/tablet-tooltip-2.png',
        'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/tooltips/tablet-tooltip-3.png',

    ];

    // Arrow size = 120 px
    // Arrow default position: head ----tail
    data.tooltip = [
        {
            heading: "Getting Started",
            text: "Start by rotating and zooming into your 3D model. Tip: keyboard shortcuts make the job easier!",
            containerPosition: "top: calc(50vh);right: " + (inspectorWidth + 140) + "px;text-align: right;",//380, 250
            arrowPosition: "top: calc(50vh + 20px); right: " + (inspectorWidth - (120 + 10) + 140 ) + "px; transform: rotate(180deg);-webkit-transform: rotate(180deg);"
        },
        {
            heading: "Explore",
            text: "Use the data browser to learn more about the structure. Make custom selections and see it highlight on the 3D model.",
            containerPosition: "top: 100px; left: " + browserWidth + "px;",
            arrowPosition: "top: 130px; left: " + (browserWidth - (120 + 10) ) + "px;"
        },
        {
            heading: "Modify",
            text: "Apply various visual representations and colors to a selection to tell your story.",
            containerPosition: "top: 80px; right: 320px;text-align: right;",
            arrowPosition: "top: 110px; right: 190px;transform: rotate(180deg);-webkit-transform: rotate(180deg);"
        },
        {
            heading: "Annotate",
            text: "Create some notes to communicate your idea.",
            containerPosition: "top: 615px; right: 320px;text-align: right;",
            arrowPosition: "top: 645px; right: 190px;transform: rotate(180deg);-webkit-transform: rotate(180deg);"
        },
        {
            heading: "Share",
            text: "Happy with your model? Share via link or embed in your website.",
            containerPosition: "top: 80px; right: 230px;text-align: right;",
            arrowPosition: "top: 110px; right: 100px;transform: rotate(180deg);-webkit-transform: rotate(180deg);"
        }
    ];

    data.newInThisVersionList = {
        col1: [
            "Share your content with a URL",
            "Embed your model in a website",
            "Export 3D printable file",
        ],
        col2: [
            "Customize representation, color, opacity",
            "Snapshot camera and model states",
        ]
    };

    return data;
};

Autodesk.Viewing.MolViewer.SplashView.prototype.show = function show() {
    this.parent.show();
};

Autodesk.Viewing.MolViewer.SplashView.prototype.hide = function hide() {
    this.parent.hide();
};
;/**
 * Created by andrewkimoto on 6/3/16.
 */
Autodesk.Viewing.MolViewer.StateCheckView = function (args) {

    var me = Autodesk.Viewing.MolViewer.StateCheckView.prototype;
    this.app = args.app;
    this.viewer = args.viewer;
    this.modal = args.modal;
    this.type = 'StateCheckView';
    this.parent = this.app.ViewManager.getTopView('DialogView');
    this.parentElement = this.app.ViewManager.getTopView('DialogView').dialogDiv;
    if (this.parent.activeDialog) {
        this.parent.activeDialog.destroy(); //destroy active dialog if any
    }
    this.parent.activeDialog = this;
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this.height = 270;
    this.width = 450;
    this._initialize();
};

Autodesk.Viewing.MolViewer.StateCheckView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.StateCheckView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.StateCheckView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.StateCheckView.prototype.destroy = function destroy() {
    this.app.ViewManager.getTopView('DialogView').hide();
    this.parent.el.removeEventListener('click',self.clickClose);
    this.parent.activeDialog = null;
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);

};

Autodesk.Viewing.MolViewer.StateCheckView.prototype._initializeElements = function _initializeElements() {
    var content = '';

    var separator = '';
    var dialogView = this.app.ViewManager.getTopView('DialogView');

    if (this.modal) {
        dialogView.setModal();
    } else {
        dialogView.setModeless();
    }
    this.el = document.createElement('DIV');
    this.el.setAttribute('id','stateCheck');
    dialogView.setDimensions(this.height,this.width);
    dialogView.setPosition(false);
    dialogView.setVerticalScroll(false);

    this.title = document.createElement('h2');
    this.title.setAttribute('class','dialog-title');
    this.title.innerHTML = 'Save Current State';
    this.stateDiv = document.createElement('div');
    this.stateDiv.setAttribute('class','dialog-button-container');
    this.btnUpdateState = this.buildButton('Update Active Snapshot');
    this.btnUpdateState.classList.add('left');
    this.btnNewButton = this.buildButton('Save as New Snapshot');
    this.btnNewButton.classList.add('right');
    content = document.createElement('p');
    content.setAttribute('class','dialog-subtitle');
    content.innerHTML = 'The current state of the viewer is different than the current active snapshot.  Click "Save to Active" to update the active snapshot with the current state or click "Save New Snapshot" to save the current viewer state in a new snapshot.';

    this.stateDiv.appendChild(this.btnUpdateState);
    this.stateDiv.appendChild(this.btnNewButton);

    this.el.appendChild(this.title);
    this.el.appendChild(content);
    this.el.appendChild(this.stateDiv);



    this.parentElement.appendChild(this.el);
};

Autodesk.Viewing.MolViewer.StateCheckView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.clickClose = function clickClose(event) {
        if (event.target === document.querySelector('#dialogLayer')) {
            self.parent.el.removeEventListener('click', self.clickClose);
            self.destroy();
        }
    };

    this.close = function close(event) {
        self.parent.el.removeEventListener('click', self.clickClose);
        self.destroy();
    };

    this.parent.el.addEventListener('click', self.clickClose);

    this.btnUpdateState.addEventListener('click', function() {
        var stateView = self.app.ViewManager.getTopView('StateView'),
            activeButton,
            id;

        activeButton = stateView.getActiveStateButton();
        id = activeButton.id;
        activeButton.updateClick.call(activeButton);
        self.app.ApiConnector.saveSession();
        self.close();
    });

    this.btnNewButton.addEventListener('click', function() {
        var stateView = self.app.ViewManager.getTopView('StateView');
        stateView.takeSnapshot.call(stateView);
        self.app.ApiConnector.saveSession();
        self.close();
    });
};

Autodesk.Viewing.MolViewer.StateCheckView.prototype.show = function show() {
    this.parent.show();
};

Autodesk.Viewing.MolViewer.StateCheckView.prototype.hide = function hide() {
    this.parent.hide();
};

Autodesk.Viewing.MolViewer.StateCheckView.prototype.buildButton = function buildValue(val) {
    var output = document.createElement('div');
    output.setAttribute('class','dialog-button');
    output.innerHTML = val;
    return output;
};
;Autodesk.Viewing.MolViewer.UploadView = function (args) {

    var me = Autodesk.Viewing.MolViewer.UploadView.prototype;
    this.app = args.app;
    this.viewer = args.viewer;
    this.molMan = args.app.MolMan;
    this.molViewer = args.app.MolViewer;
    this.loader = args.app.loader;
    this.modal = args.modal;
    this.type = 'UploadView';
    this.parent = this.app.ViewManager.getTopView('DialogView');
    this.parentElement = this.app.ViewManager.getTopView('DialogView').dialogDiv;
    if (this.parent.activeDialog) {
        this.parent.activeDialog.destroy(); //destroy active dialog if any
    }
    this.parent.activeDialog = this;
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this.height = 300;
    this.width = 450;
    this.scaffolds = ['M13mp18','M13KO7','p7308','p7560','p7704','p8064','p8100','p8634'];
    this._initialize();
};

Autodesk.Viewing.MolViewer.UploadView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.UploadView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.UploadView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.UploadView.prototype.destroy = function destroy() {
    this.app.ViewManager.getTopView('DialogView').hide();
    this.parent.el.removeEventListener('click',self.clickClose);
    this.parent.activeDialog = null;
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);

};

Autodesk.Viewing.MolViewer.UploadView.prototype._initializeElements = function _initializeElements() {
    var content = '';
    var separator = '';
    var dialogView = this.app.ViewManager.getTopView('DialogView');

    if (this.modal) {
        dialogView.setModal();
    } else {
        dialogView.setModeless();
    }
    this.el = document.createElement('DIV');
    this.el.setAttribute('id','upload');
    dialogView.setDimensions(this.height,this.width);
    dialogView.setPosition(false);
    dialogView.setVerticalScroll(false);

    this.title = document.createElement('h2');
    this.title.setAttribute('class','dialog-title');
    this.title.innerHTML = 'Open CaDNAno File';
    this.cadnanoDiv = document.createElement('div');
    this.cadnanoDiv.setAttribute('class','dialog-control');
    this.cadnanoValue = this.buildButton('Select File');
    this.cadnanoName = document.createElement('div');
    this.cadnanoName.setAttribute('class','dialog-label');
    this.cadnanoName.setAttribute('id','cadnanoLabel');
    this.cadnanoDiv.appendChild(this.cadnanoValue);
    this.cadnanoDiv.appendChild(this.cadnanoName);

    // NOTE: we will need to bring this section back when we can allow
    // the user to choose the scaffold strand
    //this.subTitle = document.createElement('p');
    //this.subTitle.setAttribute('class','dialog-subtitle');
    //this.subTitle.innerHTML = 'Specify scaffold sequence for <strong>CaDNAno</strong> files';
    //
    //this.scaffoldDiv = document.createElement('div');
    //this.scaffoldDiv.setAttribute('class','dialog-control');
    //this.scaffoldValue = this.buildValue(this.scaffolds);
    //this.scaffoldDropdown = this.buildDropDown('scaffold',this.scaffolds);
    //this.txtScaffold = document.createElement('input');
    //this.txtScaffold.setAttribute('type','text');
    //this.txtScaffold.setAttribute('class','hidden');
    //this.txtScaffold.setAttribute('name','scaffoldName');
    //this.txtScaffold.setAttribute('value',this.scaffolds[0]);
    //this.scaffoldDiv.appendChild(this.scaffoldValue);
    //this.scaffoldDiv.appendChild(this.scaffoldDropdown);
    //this.scaffoldDiv.appendChild(this.txtScaffold);

    separator = document.createElement('p');
    separator.setAttribute('class','dialog-subtitle');
    separator.innerHTML = 'We currently support the <strong>M13mp18</strong> scaffold strand';
    this.submitButton = this.buildButton('Open');
    this.submitButton.setAttribute('class','btn-dialog-submit');
    this.el.appendChild(this.title);
    this.el.appendChild(this.cadnanoDiv);
    // scaffold strand stuff commented out for now
    //this.el.appendChild(this.subTitle);
    //this.el.appendChild(this.scaffoldDiv);
    this.el.appendChild(separator);
    this.el.appendChild(this.submitButton);



    this.parentElement.appendChild(this.el);
};

Autodesk.Viewing.MolViewer.UploadView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.clickClose = function clickClose(event) {
        if(event.target === document.querySelector('#dialogLayer')) {
            self.parent.el.removeEventListener('click',self.clickClose);
            self.destroy();
        }
    };

    this.parent.el.addEventListener('click',self.clickClose);


    this.doHideDropdowns = function doHideDropdowns(event) {
        if (!event.target.classList.contains('dialog-value')) {
            self.hideDropdowns(event);
            document.removeEventListener('click',self.doHideDropdowns);
        }
    };

    this.hideDropdowns = function hideDropdowns(event) {
        var dropDowns = self.el.querySelectorAll('.dialog-drop-down'),
            i;

        for (i = 0; i < dropDowns.length; i++) {
            dropDowns[i].classList.remove('visible');
        }
    };

    this.selectOption = function selectOption(event) {
        var optionValue = event.currentTarget.innerHTML;
        event.currentTarget.parentNode.previousSibling.innerHTML = optionValue;
        event.currentTarget.parentNode.nextSibling.setAttribute('value',optionValue);
    };

    // Scaffold strand stuff commented out until we can handle it
    //this.scaffoldValue.addEventListener('click', function(event) {
    //    self.hideDropdowns(event);
    //    self.scaffoldDropdown.classList.add('visible');
    //    document.addEventListener('click', self.doHideDropdowns);
    //});

    this.updateLabel = function updateLabel(name,id) {
        var label = document.querySelector('#' + name + 'Label');
        var  labelVal = document.querySelector('#' + id).value.split('\\')[document.querySelector('#' + id).value.split('\\').length-1];
        label.innerHTML = labelVal;
    };

    this.createFileElement = function createFileElement(name,id) {
        var fileElement = document.querySelector('#'+id);
        var event = new MouseEvent('click', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });

        if (!fileElement) {
            fileElement = document.createElement('input');
            fileElement.setAttribute('type', 'file');
            fileElement.setAttribute('class', 'file-hidden');
            fileElement.setAttribute('id', id);
            fileElement.setAttribute('name', name);
            fileElement.style.opacity = 0;
            fileElement.addEventListener('change', function() {this.updateLabel(name,id)}.bind(this));


            this.el.appendChild(fileElement);
        }
        fileElement.dispatchEvent(event);
    };

    this.cadnanoValue.addEventListener('click', function() {this.createFileElement('cadnano','fileCadnano')}.bind(this));

    this.submitForm = function submitForm(event) {
        document.querySelector('#dialogLayer').classList.add('hidden'); //hide the dialog
        var fileElement = document.querySelector('#fileCadnano');
        var formData = new FormData();
        var sv = self.app.ViewManager.getTopView('StatusView');
        sv.showTranslating();
        function get_url_parameter(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
            var regexS = "[\\?&]"+name+"=([^&#]*)";
            var regex = new RegExp( regexS );
            var results = regex.exec( url );
            return results == null ? null : results[1];
        }

        formData.append("cadnano",fileElement.files[0]);

        var protocol = location.protocol;

        var translatorURL = '/cadnano';
        var data = {};
        var url = '';
        var xhr = new XMLHttpRequest();

        xhr.open('POST', translatorURL, true);
        xhr.setRequestHeader("Connection-ID", self.loader.getConnectionID());
        xhr.onload = function(e) {
            var sv = self.app.ViewManager.getTopView('StatusView');
            var hv = self.app.ViewManager.getTopView('HeaderView');
            var aData;
            if (this.status == 200) {
                document.querySelector('#fileCadnano ').remove();  //remove element after use
                data = JSON.parse(e.currentTarget.response);
                if (data.url) {
                    if(1){
                        self.molViewer.resetViewer();
                    }
                    self.molMan.createMolModel(null,data.url,data.md5);
                } else {
                    sv.showError();
                }
                hv.hideMenus();
                self.destroy();

            } else {
                sv.showError();
                hv.hideMenus();
                console.log('error ',this.status);
                self.destroy();
            }
        };
        xhr.send(formData);

    };

    this.submitButton.addEventListener('click', function() {this.submitForm(event)}.bind(this));
};

Autodesk.Viewing.MolViewer.UploadView.prototype.show = function show() {
    this.parent.show();
};

Autodesk.Viewing.MolViewer.UploadView.prototype.hide = function hide() {
    this.parent.hide();
};

Autodesk.Viewing.MolViewer.UploadView.prototype.buildValue = function buildValue(src) {
    var val = src[0],
        output = document.createElement('div');
    output.setAttribute('class','dialog-value');
    output.innerHTML = val;
    return output;
};

Autodesk.Viewing.MolViewer.UploadView.prototype.buildButton = function buildValue(val) {
    var output = document.createElement('div');
    output.setAttribute('class','dialog-button');
    output.innerHTML = val;
    return output;
};

Autodesk.Viewing.MolViewer.UploadView.prototype.buildDropDown = function buildDropDown(prefix, src) {
    var i,
        item,
        len = src.length,
        output = document.createElement('div');
    output.setAttribute('class','dialog-drop-down');
    output.setAttribute('id',prefix + 'DropDown');


    for (i = 0; i < len; i++) {
        item = document.createElement('div');
        item.setAttribute('class','drop-down-item' + (i === 0 ? ' selected' : ''));
        item.setAttribute('id',prefix + 'DropDown_'+ src[i]);
        item.innerHTML = src[i];
        item.addEventListener('click',function(event) {this.selectOption(event);}.bind(this));
        output.appendChild(item);
    }

    return output;
};
;/**
 * Created by andrewkimoto on 10/20/16.
 */
/**
 * Created by andrewkimoto on 7/26/16.
 */
Autodesk.Viewing.MolViewer.ColorPickerView = function (args) {

    var me = Autodesk.Viewing.MolViewer.ColorPickerView.prototype;
    this.app = args.app;
    this.viewer = args.viewer;
    this.molMan = args.app.MolMan;
    this.modal = args.modal;
    this.type = 'ColorPickerView';
    this.parent = this.app.ViewManager.getTopView('DialogView');
    this.parentElement = this.app.ViewManager.getTopView('DialogView').dialogDiv;
    if (this.parent.activeDialog) {
        this.parent.activeDialog.destroy(); //destroy active dialog if any
    }
    this.parent.activeDialog = this;
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this.height = 235;
    this.width = 220;
    this.pos = {top: args.top, right: args.right, bottom: args.bottom, left: args.left};
    this.index = args.index;
    this.initialColor = args.color;
    this.rep = args.rep;
    this._initialize();
};

Autodesk.Viewing.MolViewer.ColorPickerView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.ColorPickerView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.ColorPickerView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.ColorPickerView.prototype.destroy = function destroy() {
    this.app.ViewManager.getTopView('DialogView').hide();
    this.parent.el.removeEventListener('click', self.clickClose);
    this.parent.activeDialog = null;
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);

};

Autodesk.Viewing.MolViewer.ColorPickerView.prototype._initializeElements = function _initializeElements() {
    var content = '';
    var dialogView = this.app.ViewManager.getTopView('DialogView');

    if (this.modal) {
        dialogView.setModal();
    } else {
        dialogView.setModeless();
    }
    this.el = document.createElement('DIV');
    this.el.setAttribute('id', 'colorPicker');
    this.el.setAttribute('class', 'color-picker');
    dialogView.setDimensions(this.height, this.width);
    dialogView.setCustomPosition(this.pos.top, this.pos.right, this.pos.bottom, this.pos.left);
    dialogView.setVerticalScroll(false);
    this.parentElement.style.background = '#2D3349';
    this.closeButton = document.createElement('div');
    this.closeButton.setAttribute('class', 'picker-close');
    this.el.appendChild(this.closeButton);
    this.picker = document.createElement('div');
    this.picker.setAttribute('class', 'block');
    this.picker.setAttribute('id', 'picker');
    this.pickerUI = document.createElement('div');
    this.pickerUI.setAttribute('class', 'ui-color-picker');
    this.pickerUI.setAttribute('data-topic', 'picker');
    this.pickerUI.setAttribute('data-mode', 'HSL');
    this.picker.appendChild(this.pickerUI);
    this.el.appendChild(this.picker);
    this.buttonPanel = document.createElement('div');
    this.buttonPanel.setAttribute('class', 'picker-button-panel');
    this.saveButton = document.createElement('div');
    this.saveButton.setAttribute('class', 'picker-button left');
    this.saveButton.innerHTML = 'Save';
    this.cancelButton = document.createElement('div');
    this.cancelButton.setAttribute('class', 'picker-button');
    this.cancelButton.innerHTML = 'Cancel';
    this.buttonPanel.appendChild(this.saveButton);
    this.buttonPanel.appendChild(this.cancelButton);
    this.el.appendChild(this.buttonPanel);
    this.noColor = document.createElement('div');
    this.noColor.setAttribute('class', 'picker-no-color' + (this.index ? ' hidden' : ''));
    this.noColor.innerHTML = 'Select color to override';
    this.el.appendChild(this.noColor);

    this.parentElement.appendChild(this.el);
};

Autodesk.Viewing.MolViewer.ColorPickerView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.clickClose = function clickClose(event) {
        if (event.target === document.querySelector('#dialogLayer')) {
            self.parent.el.removeEventListener('click', self.clickClose);
            self.destroy();
        }
    };

    this.cancelSelection = function cancelSelection() {
        var buttons = self.app.ViewManager.getTopView('InspectorView')[self.rep + 'CustomColors'];
        var model = self.molMan.molModels[self.molMan.currentMolModelID];
        var instances = model.activeInstances;
        var i;
        var reps;
        var bitSet;
        var hexColor;
        var instancesWithColor;
        if (self.index) {
            var button = buttons.querySelectorAll('.custom-color-button')[self.index - 1];
            button.firstChild.style.backgroundColor = self.initialColor;
            buttons.classList.remove('expanded');
            self.molMan.molModels[self.molMan.currentMolModelID].customColors[self.rep][self.index] = self.initialColor;
            hexColor = '#' + self.toHexString(self.initialColor.substr(1, 2), 2) + self.toHexString(self.initialColor.substr(3, 2), 2) + self.toHexString(self.initialColor.substr(5, 2), 2);

            instancesWithColor = self.molMan.getAtomsWithCustomColorIndex(self.rep, self.index);
            instancesWithColor = instancesWithColor.length > 0 ? instancesWithColor : null;

            self.molMan.setColorFromSelection(self.rep, 'custom', self.index, instancesWithColor);

        }


        self.parent.el.removeEventListener('click', self.clickClose);
        self.destroy();
    };

    this.saveSelection = function saveSelection() {
        var buttons = self.app.ViewManager.getTopView('InspectorView')[self.rep + 'CustomColors'];
        buttons.classList.remove('expanded');
        self.parent.el.removeEventListener('click', self.clickClose);
        self.destroy();
    };

    this.cancelButton.addEventListener('click', this.cancelSelection);
    this.closeButton.addEventListener('click', this.cancelSelection);
    this.saveButton.addEventListener('click', this.saveSelection);

};

Autodesk.Viewing.MolViewer.ColorPickerView.prototype.getContent = function getContent() {
    return this.bodyText;
};

Autodesk.Viewing.MolViewer.ColorPickerView.prototype.show = function show() {
    var r, g, b, color;
    this.parent.show();
    this.colorPickerUI = new Autodesk.Nano.UIColorPicker(this);
    this.colorPickerTool = new Autodesk.Nano.ColorPickerTool(this.colorPickerUI);
    this.colorPickerTool.init();
    if (this.initialColor) {
        r = parseInt(this.initialColor.substr(1, 2), 16);
        g = parseInt(this.initialColor.substr(3, 2), 16);
        b = parseInt(this.initialColor.substr(5, 2), 16);
        color = this.colorPickerUI.colorPickers[0].color;
        color.r = r;
        color.g = g;
        color.b = b;
        color.RGBtoHSL();
        this.colorPickerUI.setColor('picker', color);
    }

};

Autodesk.Viewing.MolViewer.ColorPickerView.prototype.hide = function hide() {
    this.parent.hide();
};

Autodesk.Viewing.MolViewer.ColorPickerView.prototype.updateRepColor = function updateRepColor(newColor) {
    var hexColor = '#' + this.toHexString(newColor.r, 2) + this.toHexString(newColor.g, 2) + this.toHexString(newColor.b, 2);
    var model = this.molMan.molModels[this.molMan.currentMolModelID];
    var instances = model.activeInstances;
    var i;
    var reps;
    var bitSet;
    var button;
    var instancesWithColor;
    if (this.index) {
        button = this.app.ViewManager.getTopView('InspectorView')[this.rep + 'CustomColors'].querySelectorAll('.custom-color-button')[this.index - 1]
        button.firstChild.style.backgroundColor = 'rgb(' + newColor.r + ',' + newColor.g + ',' + newColor.b + ')';
        model.customColors[this.rep][this.index] = hexColor;
        instancesWithColor = this.molMan.getAtomsWithCustomColorIndex(this.rep, this.index);
        instancesWithColor = instancesWithColor.length > 0 ? instancesWithColor : null;

        this.molMan.setColorFromSelection(this.rep, 'custom', this.index, instancesWithColor);
        this.app.MoleculeViewer.impl.invalidate(false, true, true);
    }

};

Autodesk.Viewing.MolViewer.ColorPickerView.prototype.toHexString = function toHexString(dec, len) {
    var hex = dec.toString(16);
    if (hex.length < len) {
        while (hex.length < len) {
            hex = '0' + hex;
        }
    }
    return hex;
};

Autodesk.Viewing.MolViewer.ColorPickerView.prototype.getColor = function getColor() {
    if (this.index) {
        return this.molMan.molModels[this.molMan.currentMolModelID].customColors[this.rep][this.index];
    } else {
        return false;
    }
};

Autodesk.Viewing.MolViewer.ColorPickerView.prototype.updateColorIndex = function updateColorIndex(index) {
    this.index = index;
    if (index) {
        this.noColor.classList.add('hidden');
    } else {
        this.noColor.classList.remove('hidden');
    }

    var color = this.getColor();
    var r, g, b;
    if (color) {
        this.initialColor = color;
        r = parseInt(this.initialColor.substr(1, 2), 16);
        g = parseInt(this.initialColor.substr(3, 2), 16);
        b = parseInt(this.initialColor.substr(5, 2), 16);
        color = this.colorPickerUI.colorPickers[0].color;
        color.r = r;
        color.g = g;
        color.b = b;
        color.RGBtoHSL();
        this.colorPickerUI.setColor('picker', color);
    }

};;/**
 * Created by andrewkimoto on 4/13/15.
 */

Autodesk.Viewing.MolViewer.HeaderView = function(args) {
    var me = Autodesk.Viewing.MolViewer.HeaderView.prototype;
    Autodesk.Nano.TopView.prototype._initializeElements.call(this);
    //menu update event
    Autodesk.Viewing.MENU_SELECTION_UPDATED = 'menuSelectionUpdated';
    this.app = args.app;
    this.viewer = args.viewer;
    this.molMan = args.app.MolMan;
    this.molViewer = args.app.MolViewer;
    this.loader = args.app.Loader;
    this.apiConnector = args.app.ApiConnector;
    this.svfName = args.svfName;
    this.visible = true;
    this.type = 'HeaderView';
    this.animateDirection = 'left';
    this.displayType = 'flex';
    this.webkitDisplayType = '-webkit-flex';
    this.flexDirection = 'row';
    this.blinkCount = 0;
    //TODO move menuData to a json file that we GET
    this.menuData = {
        file: {
            header: {
                text: "File",
                mobileText: "Open",
                id: "topMenuFILE",
                topMenu: true
            },
            width: '290px',
            items: {
                load: {
                    text: "",
                    icon: "",
                    id: "menuLoadPDB",
                    check: function(appID) {return false;},
                    custom: true,
                    customCode: function(item,that) {
                        item.classList.remove('mol-menu-item');
                        item.classList.add('mol-menu-item-pdb');
                        var content = document.createElement('div');
                        var textBox = document.createElement('input');
                        var clearBox = document.createElement('div');
                        var loader = document.createElement('div');
                        var loaderImage = document.createElement('img');
                        var backButton = document.createElement('div');
                        var arrowImage = document.createElement('div');
                        var response;
                        backButton.className = "back-button";
                        arrowImage.className = "arrow-image reverse-browser";
                        backButton.appendChild(arrowImage);
                        item.appendChild(backButton);
                        content.setAttribute('class','mol-menu-input pdb-item');
                        content.innerHTML = 'Import Model from PDB';
                        textBox.setAttribute('type','text');
                        textBox.setAttribute('autocomplete', 'off');
                        textBox.setAttribute('autocorrect', 'off');
                        textBox.setAttribute('autocapitalize', 'off');
                        textBox.setAttribute('spellcheck', 'false');
                        textBox.setAttribute('class','pdb-input');
                        textBox.value = 'Enter PDB ID (e.g. 1C7D)';
                        clearBox.setAttribute('class','pdb-clear');
                        clearBox.addEventListener('click', function(event) {
                            this.app.container.querySelector('.pdb-input').value = '';
                            event.preventDefault();
                        }.bind(that));
                        loader.setAttribute('class','pdb-loader hidden');
                        loaderImage.setAttribute('class','pdb-loader-image');
                        loaderImage.setAttribute('src','https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/loader.gif');
                        loader.appendChild(loaderImage);
                        content.appendChild(textBox);
                        content.appendChild(clearBox);
                        content.appendChild(loader);
                        item.appendChild(content);
                        var keyListener = function(event) {
                            var self = this;
                            var pdbInput = self.app.container.querySelector('.pdb-input');
                            var sv = this.app.ViewManager.getTopView('StatusView');
                            if (pdbInput.classList.contains('error')) {
                                pdbInput.classList.remove('error');
                                pdbInput.value='';
                            }
                            sv.hide(); // hide error bar
                            if(event.keyCode !== 13) {
                                return false;
                            }
                            pdbInput.blur();
                            event.target.value = event.target.value.trim().toUpperCase();
                            var url = '/pdbcheck/' + event.target.value;
                            var xhr = new XMLHttpRequest();
                            xhr.open('GET', url, true);
                            xhr.setRequestHeader("Connection-ID", self.loader.getConnectionID());
                            xhr.onload = function(e) {
                                if (this.status == 200) {
                                    var response = e.currentTarget.responseXML;
                                    var hv = self.app.ViewManager.getTopView('HeaderView');
                                    console.log('valid pdb id');
                                    self.app.ViewManager.getTopView('BrowserView').updateTitleFromString(event.target.value);
                                    self.app.ViewManager.getTopView('HeaderView').toggleMobileMenu();
                                    if(1){
                                        self.molViewer.resetViewer.call(self.molViewer);
                                    }
                                    hv.requestPDB(event.target.value);
                                } else if (this.status == 516) {
                                    self.app.container.querySelector('.pdb-input').value = 'Enter a valid PDB ID (e.g. 1C7D)'; //TODO write errors to ui
                                    self.app.container.querySelector('.pdb-input').classList.add('error');
                                    console.log('invalid pdb id');
                                } else {
                                    self.app.container.querySelector('.pdb-input').value = 'Server error'; //TODO write errors to ui
                                    self.app.container.querySelector('.pdb-input').classList.add('error');
                                    console.log('server error when attempting to validate PDB ID.');
                                }
                            };
                            xhr.send();
                        };
                        textBox.addEventListener('keyup',keyListener.bind(that));

                        textBox.addEventListener('click', function() {
                            var pdbInput = this.app.container.querySelector('.pdb-input');
                            pdbInput.classList.remove('error');
                            if(pdbInput.value.substr(0,6) === 'Enter ') {
                                pdbInput.value = '';
                            }
                        }.bind(that));

                        textBox.addEventListener('blur', function() {
                            var pdbInput = this.app.container.querySelector('.pdb-input');
                            if(pdbInput.value ==='') {
                                pdbInput.value = 'Enter PDB ID (e.g. 1C7D)';
                            }
                        }.bind(that));
                    }
                },
                uploadTitle: {
                    text: "Open",
                    icon: "",
                    id: "menuUPloadTitle",
                    classList: [
                        "hide-on-mobile"
                    ],
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        var childDivs = that.app.container.querySelectorAll('.mol-menu-item-child');
                        for(var i = 0; i < childDivs.length; i++) {
                            if(childDivs[i].id === "menuUPloadTitle-child") {
                                childDivs[i].classList.toggle('show');
                                continue;
                            }
                            if(childDivs[i].classList.contains('show')) {
                                childDivs[i].classList.remove('show');
                            }
                        }

                    },
                    children: true,
                    childrenData: {
                        items: {
                            uploadCIF: {
                                text: "Open mmCIF / PDB File",
                                icon: "",
                                id: "uploadmmCIF",
                                check: function() {return false;},
                                action: function(event) {
                                    var hv = this.app.ViewManager.getTopView('HeaderView');
                                    hv.createCIFLoader();
                                }
                            },
                            uploadCadnano: {
                                text: "Open Cadnano File",
                                icon: "",
                                id: "uploadCadnano",
                                check: function() {return false;},
                                action: function(event) {
                                    var that = this;
                                    that.app.ViewManager.createTopView('UploadView');
                                    that.app.ViewManager.getTopView('HeaderView').blink(event);
                                    window.setTimeout(function() {
                                        that.app.ViewManager.getTopView('UploadView').show();
                                    },200);

                                }
                            }
                        }
                    }
                },
                downloadTitle: {
                    text: "Export",
                    icon: "",
                    id: "menuDloadTitle",
                    classList: [
                        "hide-on-mobile"
                    ],
                    check: function () {
                        return false;
                    },
                    action: function (event) {
                        var that = this;
                        var childDivs = that.app.container.querySelectorAll('.mol-menu-item-child');
                        for (var i = 0; i < childDivs.length; i++) {
                            if (childDivs[i].id === "menuDloadTitle-child") {
                                childDivs[i].classList.toggle('show');
                                continue;
                            }
                            if (childDivs[i].classList.contains('show')) {
                                childDivs[i].classList.remove('show');
                            }
                        }

                    },
                    children: true,
                    childrenData: {
                        items: {
                            download: {
                                text: "Export as mmCIF",
                                icon: "",
                                id: "downloadmmCIF",
                                check: function () {
                                    return false;
                                },
                                // We have to create a link and have that target an iframe in order for download to work
                                // in safari.  A hack but the only cross-browser technique I could find. -ajk
                                action: function(event) {
                                    var that = this;
                                    that.app.ViewManager.getTopView('HeaderView').blink(event);
                                    window.setTimeout(function() {
                                        var md5 = that.molMan.molModels[that.molMan.currentMolModelID].md5;
                                        var socketID = THREE.Math.generateUUID();
                                        var protocol = location.protocol;
                                        var url = '';
                                        that.apiConnector.getCifUrl(md5, socketID, 'HeaderView.downloadCIF.action')
                                            .then(function (data) {
                                                url = data;
                                                var dlIframe = that.app.container.querySelector('#dlIframe');
                                                var dlLink = document.createElement('a');
                                                dlLink.setAttribute('href', url);
                                                dlLink.setAttribute('target', 'dlIframe');
                                                document.body.appendChild(dlLink);
                                                dlLink.click();
                                                dlLink.remove();
                                            })
                                            .catch(function (err) {
                                                console.log('something went wrong when retrieving the url from the results.json');
                                            });
                                    },200);
                                }
                            }
                        }
                    }
                },
                Print3D: {
                    text: "Create 3D Print Files",
                    icon: "",
                    id: "Print3D",
                    classList: [
                        "hide-on-mobile"
                    ],
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.createTopView('PrintView');
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            that.app.ViewManager.getTopView('PrintView').show();
                        },200);

                    }
                },

                ssTitle: {
                    text: "Create Screenshot",
                    icon: "",
                    id: "menuScreenShotTitle",
                    classList: [
                        "hide-on-mobile"
                    ],
                    check: function() {return false;},
                    action: function(event) {
                        var self = this;
                        var childDivs = self.app.container.querySelectorAll('.mol-menu-item-child');
                        for(var i = 0; i < childDivs.length; i++) {
                            if(childDivs[i].id === "menuScreenShotTitle-child") {
                                childDivs[i].classList.toggle('show');
                                continue;
                            }
                            if(childDivs[i].classList.contains('show')) {
                                childDivs[i].classList.remove('show');
                            }
                        }
                    },
                    children: true,
                    childrenData: {
                        items: {
                            screenShotS: {
                                text: "640 x 480",
                                icon: "",
                                id: "menuScreenShot640x480",
                                noSafari: true,
                                check: function() {return false;},
                                action: function() {
                                    var that = this;
                                    that.viewer.getScreenShot(640,480, function(e) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open('GET', e, true);
                                        xhr.setRequestHeader("Connection-ID", that.loader.getConnectionID());
                                        xhr.responseType = 'blob';
                                        xhr.onload = function(e) {
                                            if (this.status == 200) {
                                                var myBlob = this.response;
                                                var hv = that.app.ViewManager.getTopView('HeaderView');
                                                var svfName = hv.svfName;
                                                saveAs(myBlob, svfName + '_640x480.png'); // myBlob is now the blob that the object URL pointed to.
                                            }
                                        };
                                        xhr.send();
                                    });
                                    that.app.ViewManager.getTopView('HeaderView').blink(event);
                                }
                            },
                            screenShotM: {
                                text: "1024 x 768",
                                icon: "",
                                id: "menuScreenShot1024x768",
                                noSafari: true,
                                check: function() {return false;},
                                action: function() {
                                    var that = this;
                                    that.viewer.getScreenShot(1024,768, function(e) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open('GET', e, true);
                                        xhr.setRequestHeader("Connection-ID", that.loader.getConnectionID());
                                        xhr.responseType = 'blob';
                                        xhr.onload = function(e) {
                                            if (this.status == 200) {
                                                var myBlob = this.response;
                                                var hv = that.app.ViewManager.getTopView('HeaderView');
                                                var svfName = hv.svfName;
                                                saveAs(myBlob, svfName + '_1024x768.png');// myBlob is now the blob that the object URL pointed to.
                                            }
                                        };
                                        xhr.send();
                                    });
                                    that.app.ViewManager.getTopView('HeaderView').blink(event);
                                }
                            },
                            screenShotL: {
                                text: "1600 x 1200",
                                icon: "",
                                id: "menuScreenShot1600x1200",
                                noSafari: true,
                                check: function() {return false;},
                                action: function() {
                                    var that = this;
                                    that.viewer.getScreenShot(1600,1200, function(e) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open('GET', e, true);
                                        xhr.setRequestHeader("Connection-ID", that.loader.getConnectionID());
                                        xhr.responseType = 'blob';
                                        xhr.onload = function(e) {
                                            if (this.status == 200) {
                                                var myBlob = this.response;
                                                var hv = that.app.ViewManager.getTopView('HeaderView');
                                                var svfName = hv.svfName;
                                                saveAs(myBlob, svfName + '_1600x1200.png');// myBlob is now the blob that the object URL pointed to.
                                            }
                                        };
                                        xhr.send();
                                    });
                                    that.app.ViewManager.getTopView('HeaderView').blink(event);
                                }
                            },
                            screenShotXL: {
                                text: "4000 x 3000",
                                icon: "",
                                id: "menuScreenShot4000x3000",
                                noSafari: true,
                                check: function() {return false;},
                                action: function() {
                                    var that = this;
                                    that.viewer.getScreenShot(4000,3000, function(e) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open('GET', e, true);
                                        xhr.setRequestHeader("Connection-ID", that.loader.getConnectionID());
                                        xhr.responseType = 'blob';
                                        xhr.onload = function(e) {
                                            if (this.status == 200) {
                                                var myBlob = this.response;
                                                var hv = that.app.ViewManager.getTopView('HeaderView');
                                                var svfName = hv.svfName;
                                                saveAs(myBlob, svfName + '_4000x3000.png');// myBlob is now the blob that the object URL pointed to.
                                            }
                                        };
                                        xhr.send();
                                    });
                                    that.app.ViewManager.getTopView('HeaderView').blink(event);
                                }
                            }
                        }
                    }
                },
                createGallery: {
                    text: "Create Gallery",
                    icon: "",
                    id: "createGallery",
                    classList: [
                        "hide-on-mobile"
                    ],
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.createTopView('GalleryBuilderView');
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            that.app.ViewManager.getTopView('GalleryBuilderView').show();
                        },200);

                    }
                },
                openProteinWebsite: {
                    id: "openProteinWebsite",
                    classList: [
                        "only-on-mobile"
                    ],
                    check: function() {return false;},
                    custom: true,
                    customCode: function(item) {
                        var molItemContainer = document.createElement('div');
                        var molItemText = document.createElement('div');
                        molItemContainer.className = "mol-item-container";
                        molItemText.className = "mol-item-text";
                        molItemText.innerHTML = "Open Protein Database website";
                        molItemContainer.appendChild(molItemText);

                        molItemContainer.addEventListener('click', function(event) {
                            window.setTimeout(function() {
                                var docs = window.open('http://www.rcsb.org/');
                            },200);
                        });

                        item.appendChild(molItemContainer);
                    }
                }
            }
        },
        view: {
            header: {
                text: "Settings",
                id: "topMenuSETTINGS",
                topMenu: true,
                classList: [
                    "hide-on-mobile"
                ]
            },

            items: {
                showBrowser: {
                    text: "Show Browser",
                    icon: "molviewer/res/images/icons/checkmark.svg",
                    id: "menuShowBrowser",
                    check: function (appID) {
                        if (document.querySelector('#browser-' + appID).style.display === 'none') {
                            return false;
                        } else {
                            return true;
                        }
                    },
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            that.app.ViewManager.toggleBrowser();
                            that.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
                            },200);

                    }
                },
                showInspector: {
                    text: "Show Inspector",
                    icon: "molviewer/res/images/icons/checkmark.svg",
                    id: "menuShowInspector",
                    check: function (appID) {
                        if (document.querySelector('#inspectorPanel-' + appID) && document.querySelector('#inspectorPanel-' + appID).classList.contains('hide')) {
                            return false;
                        } else {
                            return true;
                        }
                    },
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            that.app.ViewManager.toggleInspector();
                            that.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
                            },200);


                    }
                },

                homeView: {
                    text: "Reset View",
                    divider: true,
                    icon: "",
                    id: "menuResetView",
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            that.app.ViewManager.getTopView('HeaderView').viewer.navigation.setRequestHomeView(true);
                            //self.viewer.utilities.fitToView(true);
                            that.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
                            },200);

                    }
                },

                resetModel: {
                    text: "Reset Model",
                    icon: "",
                    id: "menuResetModel",
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        var viewer = that.app.MoleculeViewer;
                        if (viewer.model && !viewer.model.is2d()) {
                            viewer.explode(0);
                            if (viewer.explodeSlider) {
                                viewer.explodeSlider.value = 0;
                            }
                        }
                        //viewer.showAll();
                        that.molMan.clearSelection();
                        viewer.navigation.setRequestHomeView(true);
                       //NO viewer.utilities.fitToView(true);

                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            that.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
                            that.app.ViewManager.getTopView('InspectorView').resetReps();
                        },200);
                    }
                },
                zoomView: {
                    text: "Zoom Selected",
                    divider: true,
                    icon: "",
                    id: "menuZoomSelected",
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            that.viewer.utilities.fitToView();
                        },200);
                    }
                },
                backgroundColor: {
                    text: "Background",
                    divider: true,
                    icon: "molviewer/res/images/icons/checkmark.svg",
                    id: "backgroundColor",
                    check: function() {return false;},
                    action: function(event) {
                        var childDiv = document.getElementById('backgroundColor').nextElementSibling,
                            children = childDiv.children;
                        childDiv.classList.toggle('show');
                        for( var i = 0; i < children.length; i++) {
                            if (children[i].classList.contains('colorSelected')) {
                                children[i].firstChild.style.opacity = 1;
                            }
                        }
                    },
                    children: true,
                    childrenData: {
                        items: {
                            light: {
                                text: "Light",
                                id: "backgroundColorLight",
                                icon: "molviewer/res/images/icons/checkmark.svg",
                                check: function() {return false;},
                                action: function(event) {
                                    var hv = this.app.ViewManager.getTopView('HeaderView');
                                    hv.changeBackgroundColor('backgroundColorLight');
                                }
                            },
                            medium: {
                                text: "Medium",
                                id: "backgroundColorMedium",
                                classList: [
                                    "colorSelected"
                                ],
                                icon: "molviewer/res/images/icons/checkmark.svg",
                                check: function() {return false;},
                                action: function(event) {
                                    var that = this;
                                    var hv = that.app.ViewManager.getTopView('HeaderView');
                                    hv.changeBackgroundColor('backgroundColorMedium');
                                }
                            },
                            dark: {
                                text: "Dark",
                                id: "backgroundColorDark",
                                icon: "molviewer/res/images/icons/checkmark.svg",
                                check: function() {return false;},
                                action: function(event) {
                                    var that = this;
                                    var hv = that.app.ViewManager.getTopView('HeaderView');
                                    hv.changeBackgroundColor('backgroundColorDark');
                                }
                            },
                            water: {
                                text: "Water",
                                id: "backgroundColorWater",
                                icon: "molviewer/res/images/icons/checkmark.svg",
                                check: function() {return false;},
                                action: function(event) {
                                    var that = this;
                                    var hv = that.app.ViewManager.getTopView('HeaderView');
                                    hv.changeBackgroundColor('backgroundColorWater');
                                }
                            }
                        }
                    }
                }
            }
        },

        vr: {
            header: {
                text: "VR Mode",
                id: "topMenuVR",
                topMenu: true,
                classList: [
                    "hide-on-mobile"
                ],
                action: function(event) {
                    var that = this;
                    that.app.ViewManager.createTopView('VRView');
                    window.setTimeout(function() {
                        that.app.ViewManager.getTopView('VRView').show();
                    },200);

                }
            },

            items: {}
        },



        help: {
            header: {
                text: "Help",
                id: "topMenuHELP",
                topMenu: true,
                classList: [
                    "hide-on-mobile"
                ]
            },

            items: {
                docs: {
                    text: "Read the User Guide",
                    icon: "",
                    id: "menuDocumentation",
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            var docs = window.open('https://forum.bionano.autodesk.com/c/Molecule-Viewer/User-Guide');
                            },200);
                    }
                },
                tutorial: {
                    text: "Show Startup Tutorial",
                    icon: "",
                    id: "tutorial",
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            that.app.ViewManager.createTopView('SplashView');
                            that.app.ViewManager.getTopView('SplashView').show();
                        }, 200);
                    }
                },
                forum: {
                    text: "Visit The Forum",
                    divider: true,
                    icon: "",
                    id: "menuDocumentation",
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            var docs = window.open('https://forum.bionano.autodesk.com/c/Molecule-Viewer');
                        },200);
                    }
                },
                contact: {
                    text: "Contact us",
                    icon: "",
                    id: "menuContact",
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        window.location.href = "mailto:moleculeviewer@autodesk.com";
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                    }
                },
                about: {
                    text: "About Molecule Viewer",
                    divider: true,
                    icon: "",
                    id: "menuAbout",
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.createTopView('AboutView');
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            that.app.ViewManager.getTopView('AboutView').show();
                            },200);

                    }
                },
                citation: {
                    text: "Citation",
                    icon: "",
                    id: "citationDialog",
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.createTopView('CitationView');
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            that.app.ViewManager.getTopView('CitationView').show();
                        },200);

                    }
                },
                termsOfUse: {
                    text: "Terms of Use",
                    icon: "",
                    id: "termsOfUse",
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            var docs = window.open('https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/docs/Pre-Release_Product_Testing_Agreement.pdf');
                            },200);
                    }
                },
                privacyPolicy: {
                    text: "Privacy Policy",
                    icon: "",
                    id: "privacyPolicy",
                    check: function() {return false;},
                    action: function(event) {
                        var that = this;
                        that.app.ViewManager.getTopView('HeaderView').blink(event);
                        window.setTimeout(function() {
                            var docs = window.open('http://www.autodesk.com/company/legal-notices-trademarks/privacy-statement');
                            },200);
                    }
                }
            }
        },
        share: {
            header: {
                text: "Share",
                id: "mobileShare",
                topMenu: true,
                classList: [
                    "only-on-mobile"
                ],
                action: function(event) {
                    var that = this;
                    var viewerLink = that.app.ViewManager.getTopView('ShareView').createViewerLink();
                    window.location.href = "mailto:?Subject=Shared%20model%20from%20the%20Autodesk%20Molecule%20Viewer&body=" +
                                           "Take%20a%20look!%20A%20visualization%20of%20a%20molecular%20structure%20has%20been%20shared%20with%20you.%0D%0A" +
                                           "Click%20the%20link%20below%20to%20explore%20it%20in%20the%20new%20Autodesk%20Molecule%20Viewer.%0D%0A"+
                                           "Autodesk%20Molecule%20Viewer%20is%20a%20free%20and%20powerful%203D%20web-based%20tool%20to%20help%20you%20visualize,%20explore,%20and%20share%20molecular%20and%20nanoscale%20structures.%0D%0A%0D%0A" +
                                           encodeURIComponent(viewerLink);
                }
            }
        },
        browser: {
            header: {
                text: "Browse",
                id: "mobileBrowser",
                topMenu: true,
                classList: [
                    "only-on-mobile"
                ]
            }
        },
        mobilehelp: {
            header: {
                text: "Help",
                id: "mobileHelp",
                topMenu: true,
                classList: [
                    "only-on-mobile"
                ]
            },
            items: {
                helpTitle: {
                    id: "",
                    check: function() {return false;},
                    custom: true,
                    customCode: function(item) {
                        var title = document.createElement('div');
                        var backButton = document.createElement('div');
                        var arrowImage = document.createElement('div');
                        var titleText = document.createElement('span');

                        title.className = "browser-title sub-item-title";
                        backButton.className = "back-button browse";
                        arrowImage.className = "arrow-image reverse-browser mobile-browser-menu";
                        backButton.appendChild(arrowImage);
                        title.appendChild(backButton);
                        titleText.innerHTML = "Help";
                        title.appendChild(titleText);

                        item.appendChild(title);
                    }
                },
                helpContent: {
                    id: "",
                    check: function() {return false;},
                    custom: true,
                    classList: [
                        "header-on-top"
                    ],
                    customCode: function(item) {
                        var helpContent = '';
                        var bodyContainer = document.createElement('div');
                        bodyContainer.className = "body-container";
                        helpContent += "<p><strong>Navigating the model</strong></p>";
                        helpContent += "<p>Explore your model using rotating (touch and slide), panning (two finger touch and slide) and zooming (pinch inward and outward) using your touch screen device.</p>";

                        helpContent += "<p><strong>Customizing molecules</strong></p>";
                        helpContent += "<p>Open the right side menu to change representations and color schemes for the highlighted components of your model. If nothing is highlighted, modifications will apply to the whole model.</p>";

                        helpContent += "<div class='image-contain'><img src='https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/helpImages/1.png'></div>";

                        helpContent += "<p>Tab on the left side of buttons to activate, or deactivate representations.</p>";

                        helpContent += "<div class='image-contain'><img src='https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/helpImages/2.png'></div>";

                        helpContent += "<p>Tab on the right side of buttons to reveal available color schemes. Keep the color scheme buttons pressed to preview your modifications.</p>";

                        helpContent += "<div class='image-contain'><img src='https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/helpImages/3.png'></div>";

                        helpContent += "<p>Explode entities of the model by dragging the slider from one side to the other.</p>";

                        helpContent += "<div class='image-contain'><img src='https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/helpImages/4.png'></div>";

                        helpContent += "<p><strong>Exploring the molecular structure</strong></p>";
                        helpContent += "<p>Open the left side menu, then select Browse to traverse through levels of protein data.</p>";

                        helpContent += "<div class='image-contain'><img src='https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/helpImages/5.png'></div>";

                        helpContent += "<p>Tab the left side of buttons to highlight single or multiple components in the browser. Tab the arrows on the right to traverse deeper into the data. Apply Done when satisfied, and see the 3D model appropriately selected.</p>";
                        helpContent += "<p><strong>Loading a new molecule</strong></p>";
                        helpContent += "<p>Open the left side menu, then select Open to enter a PDB ID of interest.</p>";

                        helpContent += "<div class='image-contain'><img src='https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/images/helpImages/6.png'></div>";

                        helpContent += "<p><strong>Sharing molecules</strong></p>";
                        helpContent += "<p>Open the left side menu, then select Share to open your email client. People opening the included link will see the model with all applied customizations.</p>";

                        bodyContainer.innerHTML = helpContent;

                        item.appendChild(bodyContainer);
                    }
                }
            }
        },
        mobileAbout: {
            header: {
                text: "About",
                id: "mobileAbout",
                topMenu: true,
                classList: [
                    "only-on-mobile"
                ],
                action: function(event) {
                    var that = this;
                    that.app.ViewManager.createTopView('AboutView');
                    var aboutContent = document.getElementById('aboutContent');
                    while(aboutContent.firstChild) {
                        aboutContent.removeChild(aboutContent.firstChild);
                    }
                    aboutContent.appendChild(that.app.ViewManager.getTopView('AboutView').getContent());
                }
            },
            items: {
                aboutTitle: {
                    id: "",
                    check: function() {return false;},
                    custom: true,
                    customCode: function(item) {
                        var title = document.createElement('div');
                        var backButton = document.createElement('div');
                        var arrowImage = document.createElement('div');
                        var titleText = document.createElement('span');

                        title.className = "browser-title sub-item-title";
                        backButton.className = "back-button browse";
                        arrowImage.className = "arrow-image reverse-browser mobile-browser-menu";
                        backButton.appendChild(arrowImage);
                        title.appendChild(backButton);
                        titleText.innerHTML = "About";
                        title.appendChild(titleText);

                        item.appendChild(title);
                    }
                },
                aboutContent : {
                    id : "aboutContent",
                    check: function() {return true;},
                    custom: true,
                    classList: [
                        "header-on-top"
                    ],
                    customCode: function(item) {
                    }
                }
            }
        }
    };
    this.menus = [];
    this.parentElement = document.querySelector('#header-' + this.app.appID);
    this._initialize();

};

Autodesk.Viewing.MolViewer.HeaderView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.HeaderView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.HeaderView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.HeaderView.prototype._initializeElements = function _initializeElements() {
    this.el.style.display = this.displayType;
    this.el.style.flexDirection = this.flexDirection;
    this.el.style.WebkitFlexDirection = this.flexDirection;
    this.el.setAttribute('id','HeaderView');

    this.mobileMenu = document.createElement('div');
    this.mobileMenu.className = "mobile-menu";

    this.mobileMenuImage = document.createElement('div');
    this.mobileMenuImage.className = "mobile-menu-image";

    this.mobileMenu.appendChild(this.mobileMenuImage);

    this.el.appendChild(this.mobileMenu);

    this.mobileTitle = document.createElement('div');
    this.mobileTitle.className = "mobile-title";
    this.mobileTitle.innerHTML = this.svfName;
    this.el.appendChild(this.mobileTitle);

    this.logo = document.createElement('div');
    this.logo.setAttribute('class','logo');
    this.el.appendChild(this.logo);

    this.searchBox = document.createElement('INPUT');
    this.searchBox.setAttribute('type','text');
    this.searchBox.setAttribute('class','search-box');
    this.searchBox.setAttribute('placeholder','Search');
    this.searchBox.addEventListener('keyup',function(event) {
        if (event.keyCode === 13) {
            var input = event.srcElement.value.replace(/\'/g,'"');
            self.molMan.selectInstance(self.molMan.molModels[self.molMan.currentMolModelID].instance,JSON.parse(input));
        }
    });

    this.advancedSearchText = document.createElement('div');
    this.advancedSearchText.innerHTML = 'Advanced Search';
    this.advancedSearchText.setAttribute('class','advanced-search-text');

    this.searchBoxContainer = document.createElement('div');
    this.searchBoxContainer.setAttribute('class','search-box-container');
    this.searchBoxContainer.appendChild(this.advancedSearchText);
    this.searchBoxContainer.appendChild(this.searchBox);
    //TODO this to be restored when we bring back search box post-mvp
    //this.el.appendChild(this.searchBoxContainer);

    //top menus
    this.menuContainer = document.createElement('div');
    this.menuContainer.setAttribute('class','mol-menu-container');
    this.createMenu(this.menuContainer);
    this.el.appendChild(this.menuContainer);

    this.parentElement.appendChild(this.el);
};


Autodesk.Viewing.MolViewer.HeaderView.prototype._initializeEvents = function _initializeEvents() {
    var self = this;

    this.selectionSetCB = function selectionSetCB(event) {
        var md = self.molMan.molModels[self.molMan.currentMolModelID].molMetadata;
        //var vm2d = Autodesk.Viewing.MolViewer.ViewManager2D._instance;
        var vm2d = self.app.ViewManager;
        var selection = event.selection;
        var chainArray = md.findItems('chainID',selection.chain);
        var residueArray = md.findItems('residueID',event.selection.residue);
        var atomArray = vm2d.getBitSetSelected(event.selection.atomID);

        var searchJSON = '{';
        searchJSON += chainArray.length > 0 ? "'chain': [" + "'" + chainArray.join("','") + "'" + "]" : "";
        searchJSON += residueArray.length > 0 ? searchJSON.length > 1 ? ',' : '' + "'residueID': [" + "'" + residueArray.join("','") + "'" + "]" : '';
        searchJSON += atomArray.length > 0 ? searchJSON.length > 1 ? ',' : '' + "'atomID': [" + "'" + atomArray.join("','") + "'" + "]" : '';
        searchJSON = searchJSON.length > 1 ? searchJSON + '}' : '';
        self.setSearchBox(searchJSON);
    };


    //TODO this event listener will be restored when we bring in the search box post-mvp
    //this.viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT, this.selectionSetCB);

    this.showMenu = function showMenu(event) {

        var menuID = event.currentTarget.id,
            menuItems = event.currentTarget.nextSibling;
        var i;
        for (i = 0; i < self.menus.length; i++) {
            if (self.menus[i].firstChild.id === menuID) {

                if (self.menus[i].firstChild.id === "mobileBrowser") {
                    document.getElementById('browser-' + self.app.appID).classList.toggle('active');
                } else if (self.menus[i].firstChild.id === "mobileShare") {
                    // Do nothing
                    continue;
                } else {
                    self.menus[i].querySelector('.mol-menu-header-mark').classList.toggle('selected');
                    self.menus[i].querySelector('.mol-menu-items').classList.toggle('show');
                }
                self.app.container.querySelector('.mol-menu-container').classList.add('full-width');
            } else {
                self.menus[i].querySelector('.mol-menu-header-mark').classList.remove('selected');
                self.menus[i].querySelector('.mol-menu-items').classList.remove('show');
            }
        }
    };


    this.hideMenus = function hideMenus() {
        var i,
            j,
            subMenus;

        for (i = 0; i < self.menus.length; i++) {
            self.menus[i].querySelector('.mol-menu-header-mark').classList.remove('selected');
            self.menus[i].querySelector('.mol-menu-items').classList.remove('show');
            if(self.menus[i].querySelectorAll('.mol-menu-item-child')) {
                var subMenus = self.menus[i].querySelectorAll('.mol-menu-item-child');
                for (j = 0; j < subMenus.length; ++j) {
                    subMenus[j].classList.remove('show');
                }
            }
        }
        self.app.container.querySelector('.mol-menu-container').classList.remove('full-width');
    };

    this.showSkyBox = function showSkyBox(show) {
        self.viewer.impl.setUpSkyBox(show);
    };

    this.changeBackgroundColor = function changeBackgroundColor(colorID) {
        var backgroundColorDiv = self.app.container.querySelector('#backgroundColor'),
            children = backgroundColorDiv.nextElementSibling.children,
            toolbar = self.app.container.querySelector('#guiviewer3d-toolbar'),
            captions = self.app.container.querySelectorAll('.caption'),
            i,
            lightBackground = false;

        var updateCaptions = function updateCaptions(captions,light) {
            var j;
            for (j = 0; j < captions.length; ++j) {
                if (light) {
                    captions[j].classList.add('light-background');
                } else {
                    captions[j].classList.remove('light-background');
                }
            }
        };

        if (colorID === "backgroundColorMedium") {
            self.showSkyBox(false);
            toolbar.classList.remove('light-background');
            self.viewer.setBackgroundColor.apply(self.viewer,Autodesk.Viewing.Private.LightPresets[Autodesk.Viewing.Private.DefaultLightPreset].bgColorGradient);
        } else if (colorID === "backgroundColorLight") {
            self.showSkyBox(false);
            toolbar.classList.add('light-background');
            lightBackground = true;
            self.viewer.setBackgroundColor(255, 255, 255, 255, 255, 255);
        } else if (colorID === "backgroundColorDark") {
            self.showSkyBox(false);
            toolbar.classList.remove('light-background');
            self.viewer.setBackgroundColor(0, 0, 0, 0, 0, 0);
        } else if (colorID === "backgroundColorWater") {
            self.viewer.setBackgroundColor.apply(self.viewer,Autodesk.Viewing.Private.LightPresets[Autodesk.Viewing.Private.DefaultLightPreset].bgColorGradient);
            self.showSkyBox(true);
            toolbar.classList.remove('light-background');
            window.setTimeout(function() {self.viewer.impl.invalidate(false,true,true);},50);
        }

        updateCaptions(captions,lightBackground);

        backgroundColorDiv.nextElementSibling.classList.toggle('show');
        self.app.ViewManager.getTopView('HeaderView').hideMenus();
        for (i = 0; i < children.length; i++) {
            if (children[i].id === colorID) {
                children[i].className += " colorSelected";
            } else {
                children[i].classList.remove('colorSelected');
                children[i].firstChild.style.opacity = 0;
            }
        }
    };

    this.setMenuStatus = function setMenuStatus() {
        var i,
            j,
            items,
            icon;
        for (i = 0; i < self.menus.length; i++) {
            items = self.menus[i].querySelectorAll('.mol-menu-item');
            for (j = 0; j < items.length; j++) {
                icon = items[j].querySelector('.mol-menu-item-icon');
                if (items[j].checkStatus) {
                    if (!items[j].checkStatus(this.app.appID)) {

                        icon.style.opacity = '0';
                    } else {
                        icon.style.opacity = '1';
                    }
                }
            }
        }
    };

    this.viewer.addEventListener(Autodesk.Viewing.MENU_SELECTION_UPDATED, this.setMenuStatus);

    this.modelStartLoaded = function modelStartLoaded(event){
        var hv = self.app.ViewManager.getTopView('HeaderView');
        hv.hideMenus();
    };

    this.modelEndLoaded = function modelEndLoaded(event){
        var hv = self.app.ViewManager.getTopView('HeaderView');
        hv.hideMenus();
    };

    this.modelErrorLoaded = function modelErrorLoaded(event){
        var hv = self.app.ViewManager.getTopView('HeaderView');
        hv.hideMenus();
    };

    this.viewer.addEventListener(Autodesk.Nano.MODEL_START_LOADED_EVENT, this.modelStartLoaded);
    this.viewer.addEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT, this.modelEndLoaded);
    this.viewer.addEventListener(Autodesk.Nano.MODEL_LOAD_ERROR_EVENT, this.modelErrorLoaded);
    this.viewer.addEventListener(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED, this.modelStartLoaded);



    this.requestPDB = function requestPDB(id) {

        self.molMan.createMolModel(id);
    };


    this.createCIFLoader = function createCIFLoader() {
        var fileElement = self.app.container.querySelector('#fileCIF');
        var event = new MouseEvent('click', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });

        if (!fileElement) {
            fileElement = document.createElement('input');
            fileElement.setAttribute('type', 'file');
            fileElement.setAttribute('class', 'file-hidden');
            fileElement.setAttribute('id', 'fileCIF');
            fileElement.setAttribute('accept','.cif,.pdb');
            fileElement.setAttribute('name', 'cif');
            //fileElement.setAttribute('accept','.cif,.pdb');  //once we have pdb, uncomment this
            fileElement.style.opacity = 0;
            fileElement.addEventListener('change', self.uploadCIF);
            self.app.container.appendChild(fileElement);
        }
        fileElement.dispatchEvent(event);
    };

    this.uploadCIF = function uploadCIF() {
        var fileElement = self.app.container.querySelector('#fileCIF');
        var formData = new FormData();
        var sv = self.app.ViewManager.getTopView('StatusView');
        sv.showTranslating();
        function get_url_parameter(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
            var regexS = "[\\?&]"+name+"=([^&#]*)";
            var regex = new RegExp( regexS );
            var results = regex.exec( url );
            return results === null ? null : results[1];
        }

        formData.append("cif",fileElement.files[0]);

        var protocol = location.protocol;

        var translatorURL = '/upload_cif';
        var data = {};
        var url = '';
        var xhr = new XMLHttpRequest();

        xhr.open('POST', translatorURL, true);
        xhr.setRequestHeader("Connection-ID", self.loader.getConnectionID());
        xhr.onload = function(e) {
            var sv = self.app.ViewManager.getTopView('StatusView');
            var hv = self.app.ViewManager.getTopView('HeaderView');
            var aData;
            if (this.status == 200) {
                self.app.container.querySelector('#fileCIF').remove();  //remove element after use
                data = JSON.parse(e.currentTarget.response);
                if (data.md5) {
                    self.molViewer.resetViewer(); //eventually we will just remove the model here.
                    self.molMan.createMolModel(null,data.url,data.md5);
                } else {
                    sv.showError();
                }
                hv.hideMenus();

            } else {
                sv.showError();
                hv.hideMenus();
                console.log('error ',this.status);
            }
        };
        xhr.send(formData);
    };


    this.blink = function blink(event) {
        var srcElement = event.target;
        if (srcElement.className === 'mol-menu-text') {
            srcElement = srcElement.parentNode;
        }
        if (srcElement.style.backgroundColor === 'rgb(89, 129, 255)') {
            srcElement.style.backgroundColor = 'transparent';
            srcElement.style.color = '#000000';
        } else {
            srcElement.style.backgroundColor = '#5981ff';
            srcElement.style.color = '#ffffff';
        }
        self.blinkCount += 1;
        if (self.blinkCount >= 4) {
            self.blinkCount = 0;
            srcElement.style.backgroundColor = '';
            srcElement.style.color = '';
            self.hideMenus();
        } else {
            window.setTimeout(self.blink,80,event);
        }

    };


    this.closeMenus = function closeMenus(event) {

        var eventClassList = event.target.classList[0];

        if (!isTouchDevice() || window.innerWidth >= Autodesk.Viewing.MolViewer.MAX_TABLET_MODE_RESOLUTION) {
            var classList = [ "mol-menu-header-text", "mol-menu-item", "mol-menu-text", "mol-menu-header",
                              "mol-menu-item-icon", "pdb-clear", "pdb-input" ];
            var hideMenu = true;
            if (typeof eventClassList !== "undefined") {
                for (var i = 0; i < classList.length; i++) {
                    if (eventClassList.indexOf(classList[i]) !== -1) {
                        hideMenu = false;
                        break;
                    }
                }
            }
        } else {
            var classList = ["mobile-header-menu", "back-button", "arrow-image"];
            var hideMenu = false;
            if (typeof eventClassList !== "undefined") {
                for (var i = 0; i < classList.length; i++) {
                    if (eventClassList.indexOf(classList[i]) > -1) {
                        hideMenu = true;
                        break;
                    }
                }
            }
        }

        if (hideMenu) {
            self.app.ViewManager.getTopView('HeaderView').hideMenus();
        }

    };

    document.addEventListener('click', this.closeMenus);

    this.handleKeypress = function handleKeypress(event) {
        var keyCode = event.keyCode;
        var icon;

        // hotkeys are disabled when in 'simple' display mode (for sharing, etc.)
        if(event.target === document.querySelector('body') && self.app.ViewManager.checkKeyCode(keyCode)) {
            if (keyCode === 73 || keyCode === 105) { // i
                if(self.app.container.querySelector('#menuShowInspector').checkStatus) {
                    icon = self.app.container.querySelector('#menuShowInspector').querySelector('.mol-menu-item-icon');
                    if(self.app.container.querySelector('#menuShowInspector').checkStatus()) {
                        icon.style.opacity = 0;
                    } else {
                        icon.style.opacity = 1;
                    }
                }
                this.app.ViewManager.toggleInspector();
            } else if (keyCode === 66 || keyCode === 98) { // b
                if(self.app.container.querySelector('#menuShowBrowser').checkStatus) {
                    icon = self.app.container.querySelector('#menuShowBrowser').querySelector('.mol-menu-item-icon');
                    if(self.app.container.querySelector('#menuShowBrowser').checkStatus()) {
                        icon.style.opacity = 0;
                    } else {
                        icon.style.opacity = 1;
                    }
                }
                this.app.ViewManager.toggleBrowser();
            } else if (keyCode === 86 || keyCode === 118) { // v
                self.viewer.navigation.setRequestHomeView(true);
                self.viewer.utilities.fitToView(true);
            } else if (keyCode === 77 || keyCode === 109) { // m
                self.viewer.navigation.setRequestHomeView(true);
                this.app.ViewManager.getTopView('InspectorView').resetReps();
                self.viewer.utilities.fitToView(true);
            } else if (keyCode === 87 || keyCode === 119) { // w
                self.molMan.selectionFilter = 'chain';
                self.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
            } else if (keyCode === 82 || keyCode === 114) { // r
                self.molMan.selectionFilter = 'atomID';
                self.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
            } else if (keyCode === 69 || keyCode === 101) { // a
                self.molMan.selectionFilter = 'residueID';
                self.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
            }
            else if (keyCode === 81 || keyCode === 103) { // q
                self.molMan.selectionFilter = 'instance';
                self.viewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
            }
        }
    };

    this.toggleMobileMenu = function toggleMobileMenu(event) {
        document.getElementById('inspectorOpenButton').classList.toggle('hide');
        self.mobileMenu.classList.toggle('open');
        self.menuContainer.classList.toggle('active');
        self.app.container.querySelector('.mol-menu-container').classList.remove('full-width');
        document.getElementById('browser-' + self.app.appID).classList.remove('active');
    };

    this.mobileMenu.addEventListener('touchstart', touchStartToClick);

    this.toggleMobileMenus = function toggleMobileMenus(event) {
        this.app.ViewManager.getTopView('HeaderView').toggleMobileMenu();
        this.app.ViewManager.getTopView('InspectorView').toggleInspector('off');
    };

    this.mobileMenu.addEventListener('click', this.toggleMobileMenus);
    document.getElementById('mobile-close-button-browser').addEventListener('touchstart', this.toggleMobileMenus);

    document.addEventListener('keyup',this.handleKeypress);

    //Handles message events and logs the error.  This could be
    //expanded in the future to update the status bar
    this.receiveErrorMessage = function(e) {
        console.log('message is ', e.data);
    };

    //This can be used if we decide to use postMessage() to send messages from
    //the iframe that contains file download error reporting.  The html sent
    //back from the server will need to fire a postMessage() on load.
    //window.addEventListener('message', this.receiveErrorMessage);
};



Autodesk.Viewing.MolViewer.HeaderView.prototype.setSearchBox = function setSearchBox(value) {
    this.searchBox.value = value;
};


Autodesk.Viewing.MolViewer.HeaderView.prototype.createMenu = function createMenu(container) {
    var items,
        self = this,
        app = this.app,
        item,
        menus = this.menuData,
        menu,
        menuDiv,
        menuHeader,
        menuHeaderText,
        menuHeaderMark,
        menuHeaderArrow,
        arrowImage,
        menuItems,
        menuItem,
        menuItemIcon,
        menuItemText,
        menuItemChildMark,
        childrenParent,
        closeButton,
        closeImg,
        that = this,
        isSafari = navigator.userAgent.toLowerCase().match(/safari/) && !navigator.userAgent.toLowerCase().match(/chrome/) ? true : false;

    self.createMenus = function(menuInfo, item, that) {
        var menuItem, menuItemIcon, menuItemText;
        if (menuInfo.items.hasOwnProperty(item)) {
            menuItem = document.createElement('div');
            menuItem.setAttribute('class', 'mol-menu-item' + (menuInfo.items[item].divider ? ' menu-divider' : ''));
            menuItem.setAttribute('id', menuInfo.items[item].id);

            if (menuInfo.items[item].classList && menuInfo.items[item].classList.length > 0) {
                for( var className in menuInfo.items[item].classList) {
                    menuItem.className += " " + menuInfo.items[item].classList[className];
                }
            }

            //for customized menu like pdb loader
            if (menuInfo.items[item].custom) {
                menuInfo.items[item].customCode(menuItem,that);
            } else {
                menuItem.checkStatus = menuInfo.items[item].check;
                menuItemIcon = document.createElement('div');
                menuItemIcon.setAttribute('class', 'mol-menu-item-icon');
                menuItemIcon.style.background = 'url("' + menuInfo.items[item].icon + '") no-repeat top left';
                if (!menuItem.checkStatus(app.appID)) {
                    menuItemIcon.style.opacity = '0';
                } else {
                    menuItemIcon.style.opacity = '1';
                }
                menuItemText = document.createElement('div');
                menuItemText.setAttribute('class', 'mol-menu-text');
                menuItemText.innerHTML = menuInfo.items[item].text;

                menuItem.appendChild(menuItemIcon);
                menuItem.appendChild(menuItemText);

                if (menuInfo.items[item].children) {
                    menuItemChildMark = document.createElement('div');
                    menuItemChildMark.className = "mol-menu-item-child-icon";
                    menuItem.appendChild(menuItemChildMark);

                    // menuItem.addEventListener('mouseover', function() {})
                }

                if (isSafari && menuInfo.items[item].noSafari) {
                    menuItem.classList.add('disabled');
                } else {
                    menuItem.addEventListener('click', menuInfo.items[item].action.bind(self));
                }
            }
            return menuItem;
        }
    };

    closeButton = document.createElement('div');
    closeButton.id = 'mobile-close-button-browser';
    closeButton.className = "close-button browse";

    closeImg = document.createElement('div');
    closeImg.className = "close-img";
    closeButton.appendChild(closeImg);

    container.appendChild(closeButton);

    for (menu in menus) {
        if (menus.hasOwnProperty(menu)) {
            if (menu === 'app') {
                continue;
            }
            if(menus[menu].header.topMenu) {

                menuDiv = document.createElement('div');
                menuDiv.setAttribute('class', 'mol-menu closed');
                menuHeader = document.createElement('div');
                menuHeader.setAttribute('class', 'mol-menu-header');

                if (menus[menu].header.classList && menus[menu].header.classList.length > 0) {
                    for( var className in menus[menu].header.classList) {
                        menuHeader.className += " " + menus[menu].header.classList[className];
                    }
                }

                if (menus[menu].header.action) {
                    menuHeader.addEventListener('click', menus[menu].header.action.bind(this));
                }

                menuHeader.setAttribute('id', menus[menu].header.id);
                menuHeader.addEventListener('touchstart', touchStartToClick);
                if (menuHeader.action) {
                    menuHeader.addEventListener('click', menuHeader.action);
                } else {
                    menuHeader.addEventListener('click', function (event) {
                        that.showMenu(event);
                    });
                }

                menuHeaderText = document.createElement('div');
                menuHeaderText.setAttribute('class', 'mol-menu-header-text');
                if (isTouchDevice()) {
                    menuHeaderText.innerHTML = menus[menu].header.mobileText || menus[menu].header.text;
                } else {
                    menuHeaderText.innerHTML = menus[menu].header.text;
                }
                menuHeaderMark = document.createElement('div');
                menuHeaderMark.setAttribute('class', 'mol-menu-header-mark');
                menuHeaderArrow = document.createElement('div');
                menuHeaderArrow.className = "menu-header-arrow";
                arrowImage = document.createElement('div');
                arrowImage.className = "arrow-image mobile-header-menu";
                menuHeaderArrow.appendChild(arrowImage);
                menuHeader.appendChild(menuHeaderText);
                menuHeader.appendChild(menuHeaderMark);
                menuHeader.appendChild(menuHeaderArrow);
                menuDiv.appendChild(menuHeader);
                menuItems = document.createElement('div');
                menuItems.setAttribute('class', 'mol-menu-items');
                if (menus[menu].width) {
                    menuItems.style.width = menus[menu].width;
                }

                for (item in menus[menu].items) {
                    menuItems.appendChild(self.createMenus(menus[menu], item, self));
                    if (menus[menu].items[item].children) {
                        childrenParent = document.createElement('div');
                        childrenParent.className = "mol-menu-item-child";
                        childrenParent.id = menus[menu].items[item].id + "-child";
                        for (child in menus[menu].items[item].childrenData.items) {
                            childrenParent.appendChild(self.createMenus(menus[menu].items[item].childrenData, child, self));
                        }
                        menuItems.appendChild(childrenParent);
                    }
                }
                menuDiv.appendChild(menuItems);
            }
        }
        this.menus.push(menuDiv);
        container.appendChild(menuDiv);
    }

};

Autodesk.Viewing.MolViewer.HeaderView.prototype.updateSvfName = function updateSvfName(svfName) {
    this.svfName = svfName;
    this.mobileTitle.innerHTML = svfName;
};
;/**
 * Created by andrewkimoto on 4/13/15.
 */

Autodesk.Viewing.MolViewer.InspectorView = function(args) {
    var me = Autodesk.Viewing.MolViewer.InspectorView.prototype;

    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/)
            && !navigator.userAgent.toLowerCase().match(/chrome/) ? true : false;
    this.app = args.app;
    this.molMan = args.app.MolMan;
    this.viewer = args.viewer;
    this.svfName = args.svfName;
    this.visible = true;
    this.type = 'InspectorView';
    this.animateDirection = 'left';
    this.displayType = this.isSafari ? '-webkit-flex' : 'flex';
    this.flexDirection = 'column';
    this.resizeMin = 220;
    this.parentElement = this.app.container.querySelector('#contents-' + this.app.appID);
    this.dropDownColors = {
        ribbon: ['Entity', 'Chain', 'Residue', 'Secondary', 'Bfactor', 'Index', 'Custom'],
        stick: ['Entity', 'Chain', 'Residue', 'Secondary', 'Bfactor', 'Index', 'Atom', 'Custom'],
        surface: ['Entity', 'Chain', 'Residue', 'Secondary', 'Bfactor', 'Index', 'Atom', 'Custom'],
        CPK: ['Entity','Chain', 'Residue', 'Secondary', 'Bfactor','Index','Atom', 'Custom'],
        selected: ['Entity','Chain', 'Residue', 'Secondary', 'Bfactor','Index','Atom']
    };
    this.customColorArrays = {ribbon: [], stick: [], surface: [], CPK: []};
    this.reps = ['ribbon','stick','surface','CPK'];
    this.sections = [['section-y','Y','Top - Bottom'],['section-x','X','Left - Right'],['section-z','Z','Back - Front','section-box','BOX','Box']];

    this.ribbonState = 0;
    this.stickState = 0;
    this.surfaceState = 0;
    this.CPKState = 0;
    this.selectedState = 0;

    this.ribbonColor = 'Chain';
    this.stickColor = 'Chain';
    this.surfaceColor = 'Chain';
    this.CPKColor = 'Chain';
    this.selectedColor = 'Chain';

    this._initialize();
};

Autodesk.Viewing.MolViewer.InspectorView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.InspectorView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.InspectorView.prototype;
    me._initializeElements.call(this);
    me._initializeToolSets.call(this);
    me._initializeEvents.call(this);
};

Autodesk.Viewing.MolViewer.InspectorView.prototype._initializeElements = function _initializeElements() {
    var dot,
        icon,
        switchMark,
        switchText,
        spacer,
        divider;

    this.openInspectorButton = document.createElement('div');
    this.openInspectorButton.className = "open-button inspector right";
    this.openInspectorButton.id = "inspectorOpenButton";
    this.openInspectorImage = document.createElement('div');
    this.openInspectorImage.className = "arrow-image inspector-image reverse";
    this.openInspectorButton.appendChild(this.openInspectorImage);

    this.parentElement.insertBefore(this.openInspectorButton, document.querySelector('#inspectorPanel-' +this.app.appID));

    this.el = document.createElement('DIV');
    this.el.setAttribute('id','inspector');

    this.scrollContainer = document.createElement('div');
    this.scrollContainer.className = "scroll-container";

    this.closeButton = document.createElement('div');
    this.closeButton.className = "close-button";

    this.closeImg = document.createElement('div');
    this.closeImg.className = "close-img";
    this.closeButton.appendChild(this.closeImg);

    this.inspectorHeader = document.createElement('div');
    this.inspectorHeader.setAttribute('id','inspectorHeader');

    this.inspectorBody = document.createElement('div');
    this.inspectorBody.setAttribute('id','inspectorBody');
    this.pdbTitle = document.createElement('div');
    this.pdbTitle.setAttribute('class','model-title-inspector');
    this.pdbTitle.setAttribute('style','display: none;');
    this.pdbTitle.innerHTML = this.svfName;
    this.inspectorHeader.appendChild(this.pdbTitle);
    this.panelSwitch = document.createElement('div');
    this.panelSwitch.setAttribute('class','panel-switch-container');
    this.modifySwitch = document.createElement('div');
    this.modifySwitch.setAttribute('class','panel-switch active');
    switchText = document.createElement('div');
    switchText.setAttribute('class','panel-switch-text');
    switchText.innerHTML = 'Modify';
    switchMark = document.createElement('div');
    switchMark.setAttribute('class','panel-switch-mark');
    this.modifySwitch.appendChild(switchText);
    this.modifySwitch.appendChild(switchMark);
    this.shareSwitch = document.createElement('div');
    this.shareSwitch.setAttribute('class','panel-switch');
    switchText = document.createElement('div');
    switchText.setAttribute('class','panel-switch-text');
    switchText.innerHTML = 'Share';
    switchMark = document.createElement('div');
    switchMark.setAttribute('class','panel-switch-mark');
    this.shareSwitch.appendChild(switchText);
    this.shareSwitch.appendChild(switchMark);
    this.shareSwitch.addEventListener('click',this.shareSwitchCB.bind(this));
    this.panelSwitch.appendChild(this.modifySwitch);
    this.panelSwitch.appendChild(this.shareSwitch);
    this.inspectorHeader.appendChild(this.panelSwitch);

    this.divider = document.createElement('div');
    this.divider.className = "inspector-divider";
    this.inspectorBody.appendChild(this.divider);

    //ribbon
    this.ribbonDiv = document.createElement('div');
    this.ribbonDiv.setAttribute('class','inspector-div');
    this.ribbonRow = document.createElement('div');
    this.ribbonRow.setAttribute('class', 'inspector-row' + (this.ribbonState === 2 ? ' selected' : ''));

    this.ribbonCheck = document.createElement('div');
    this.ribbonCheck.setAttribute('class','inspector-check head' + (this.ribbonState === 2 ? ' on' : this.ribbonState === 0 ? ' off' : 'part'));

    this.ribbonCheck.setAttribute('id','ribbonCheck');
    this.ribbonTitle = document.createElement('div');
    this.ribbonTitle.setAttribute('class','inspector-label');
    this.ribbonTitle.innerHTML = 'Ribbon';
    this.ribbonEmptyLine = document.createElement('div');
    this.ribbonEmptyLine.setAttribute('class','inspector-control head');

    this.mobileRibbonCheck = document.createElement('div');
    this.mobileRibbonCheck.className = "inspector-mobile-check";

    this.dividerImage = document.createElement('div');
    this.dividerImage.className = 'divider-image';

    this.arrowImage = document.createElement('div');
    this.arrowImage.className = "arrow-image mobile active";

    this.mobileRibbonCheck.appendChild(this.dividerImage);
    this.mobileRibbonCheck.appendChild(this.arrowImage);

    this.ribbonRow.appendChild(this.ribbonCheck);
    this.ribbonRow.appendChild(this.ribbonTitle);
    this.ribbonRow.appendChild(this.ribbonEmptyLine);
    this.ribbonRow.appendChild(this.mobileRibbonCheck);
    this.ribbonDiv.appendChild(this.ribbonRow);

    this.ribbonColorRow = document.createElement('div');
    this.ribbonColorRow.setAttribute('class', 'inspector-row dropdown');
    if(this.ribbonState === 0) {
        this.ribbonColorRow.style.display = 'none';
    }
    this.ribbonSpacer = document.createElement('div');
    this.ribbonSpacer.setAttribute('class','inspector-check blank');
    this.ribbonTitle = document.createElement('div');
    this.ribbonTitle.setAttribute('class','inspector-label color');
    this.ribbonTitle.innerHTML = 'Color';
    this.ribbonColorDiv = document.createElement('div');
    this.ribbonColorDiv.setAttribute('class','inspector-control');
    this.ribbonValue = this.buildColorValue('ribbon');
    this.ribbonDropdown = this.buildColorDropDown('ribbon',this.ribbonColor);
    this.ribbonColorDiv.appendChild(this.ribbonValue);
    this.ribbonColorDiv.appendChild(this.ribbonDropdown);

    this.ribbonColorRow.appendChild(this.ribbonSpacer);
    this.ribbonColorRow.appendChild(this.ribbonTitle);
    this.ribbonColorRow.appendChild(this.ribbonColorDiv);
    this.ribbonDiv.appendChild(this.ribbonColorRow);

    this.inspectorBody.appendChild(this.ribbonDiv);


    //ball and stick
    this.stickDiv = document.createElement('div');
    this.stickDiv.setAttribute('class','inspector-div');
    this.stickRow = document.createElement('div');
    this.stickRow.setAttribute('class', 'inspector-row');

    this.stickCheck = document.createElement('div');
    this.stickCheck.setAttribute('class','inspector-check head off');
    this.stickCheck.setAttribute('id','stickCheck');
    this.stickTitle = document.createElement('div');
    this.stickTitle.setAttribute('class','inspector-label');
    this.stickTitle.innerHTML = 'Ball &amp; Stick';
    this.stickEmptyLine = document.createElement('div');
    this.stickEmptyLine.setAttribute('class','inspector-control head');

    this.mobileStickCheck = document.createElement('div');
    this.mobileStickCheck.className = "inspector-mobile-check";

    this.dividerImage = document.createElement('div');
    this.dividerImage.className = 'divider-image';

    this.arrowImage = document.createElement('div');
    this.arrowImage.className = "arrow-image mobile";

    this.mobileStickCheck.appendChild(this.dividerImage);
    this.mobileStickCheck.appendChild(this.arrowImage);

    this.stickRow.appendChild(this.stickCheck);
    this.stickRow.appendChild(this.stickTitle);
    this.stickRow.appendChild(this.stickEmptyLine);
    this.stickRow.appendChild(this.mobileStickCheck);
    this.stickDiv.appendChild(this.stickRow);
    this.stickColorRow = document.createElement('div');
    this.stickColorRow.setAttribute('class', 'inspector-row dropdown');
    if(this.stickState === 0) {
        this.stickColorRow.style.display = 'none';
    }
    this.stickSpacer = document.createElement('div');
    this.stickSpacer.setAttribute('class','inspector-check blank');
    this.stickTitle = document.createElement('div');
    this.stickTitle.setAttribute('class','inspector-label color');
    this.stickTitle.innerHTML = 'Color';
    this.stickColorDiv = document.createElement('div');
    this.stickColorDiv.setAttribute('class','inspector-control');

    this.stickValue = this.buildColorValue('stick');
    this.stickDropdown = this.buildColorDropDown('stick',this.stickColor);
    this.stickColorDiv.appendChild(this.stickValue);
    this.stickColorDiv.appendChild(this.stickDropdown);

    this.stickColorRow.appendChild(this.stickSpacer);
    this.stickColorRow.appendChild(this.stickTitle);
    this.stickColorRow.appendChild(this.stickColorDiv);
    this.stickDiv.appendChild(this.stickColorRow);


    this.inspectorBody.appendChild(this.stickDiv);


    //surface
    this.surfaceDiv = document.createElement('div');
    this.surfaceDiv.setAttribute('class','inspector-div');
    this.surfaceRow = document.createElement('div');
    this.surfaceRow.setAttribute('class', 'inspector-row');

    this.surfaceCheck = document.createElement('div');
    this.surfaceCheck.setAttribute('class','inspector-check head off');
    this.surfaceCheck.setAttribute('id','surfaceCheck');
    this.surfaceTitle = document.createElement('div');
    this.surfaceTitle.setAttribute('class','inspector-label');
    this.surfaceTitle.innerHTML = 'Surface';
    this.surfaceEmptyLine = document.createElement('div');
    this.surfaceEmptyLine.setAttribute('class','inspector-control head');

    this.mobileSurfaceCheck = document.createElement('div');
    this.mobileSurfaceCheck.className = "inspector-mobile-check";

    this.dividerImage = document.createElement('div');
    this.dividerImage.className = 'divider-image';

    this.arrowImage = document.createElement('div');
    this.arrowImage.className = "arrow-image mobile";

    this.mobileSurfaceCheck.appendChild(this.dividerImage);
    this.mobileSurfaceCheck.appendChild(this.arrowImage);

    this.surfaceRow.appendChild(this.surfaceCheck);
    this.surfaceRow.appendChild(this.surfaceTitle);
    this.surfaceRow.appendChild(this.surfaceEmptyLine);
    this.surfaceRow.appendChild(this.mobileSurfaceCheck);
    this.surfaceDiv.appendChild(this.surfaceRow);

    this.surfaceColorRow = document.createElement('div');
    this.surfaceColorRow.setAttribute('class', 'inspector-row dropdown');
    if(this.surfaceState === 0) {
        this.surfaceColorRow.style.display = 'none';
    }
    this.surfaceSpacer = document.createElement('div');
    this.surfaceSpacer.setAttribute('class','inspector-check blank');
    this.surfaceTitle = document.createElement('div');
    this.surfaceTitle.setAttribute('class','inspector-label color');
    this.surfaceTitle.innerHTML = 'Color';
    this.surfaceColorDiv = document.createElement('div');
    this.surfaceColorDiv.setAttribute('class','inspector-control');

    this.surfaceValue = this.buildColorValue('surface');
    this.surfaceDropdown = this.buildColorDropDown('surface',this.surfaceColor);
    this.surfaceColorDiv.appendChild(this.surfaceValue);
    this.surfaceColorDiv.appendChild(this.surfaceDropdown);
    this.surfaceColorRow.appendChild(this.surfaceSpacer);
    this.surfaceColorRow.appendChild(this.surfaceTitle);
    this.surfaceColorRow.appendChild(this.surfaceColorDiv);
    this.surfaceDiv.appendChild(this.surfaceColorRow);


    this.inspectorBody.appendChild(this.surfaceDiv);

    //CPK
    this.CPKDiv = document.createElement('div');
    this.CPKDiv.setAttribute('class','inspector-div');
    this.CPKRow = document.createElement('div');
    this.CPKRow.setAttribute('class', 'inspector-row');

    this.CPKCheck = document.createElement('div');
    this.CPKCheck.setAttribute('class','inspector-check head off');
    this.CPKCheck.setAttribute('id','CPKCheck');
    this.CPKTitle = document.createElement('div');
    this.CPKTitle.setAttribute('class','inspector-label');
    this.CPKTitle.innerHTML = 'CPK';
    this.CPKEmptyLine = document.createElement('div');
    this.CPKEmptyLine.setAttribute('class','inspector-control head');

    this.mobileCPKCheck = document.createElement('div');
    this.mobileCPKCheck.className = "inspector-mobile-check";

    this.dividerImage = document.createElement('div');
    this.dividerImage.className = 'divider-image';

    this.arrowImage = document.createElement('div');
    this.arrowImage.className = "arrow-image mobile";

    this.mobileCPKCheck.appendChild(this.dividerImage);
    this.mobileCPKCheck.appendChild(this.arrowImage);

    this.CPKRow.appendChild(this.CPKCheck);
    this.CPKRow.appendChild(this.CPKTitle);
    this.CPKRow.appendChild(this.CPKEmptyLine);
    this.CPKRow.appendChild(this.mobileCPKCheck);
    this.CPKDiv.appendChild(this.CPKRow);

    this.CPKColorRow = document.createElement('div');
    this.CPKColorRow.setAttribute('class', 'inspector-row dropdown');
    if(this.CPKState === 0) {
        this.CPKColorRow.style.display = 'none';
    }
    this.CPKSpacer = document.createElement('div');
    this.CPKSpacer.setAttribute('class','inspector-check blank');
    this.CPKTitle = document.createElement('div');
    this.CPKTitle.setAttribute('class','inspector-label color');
    this.CPKTitle.innerHTML = 'Color';
    this.CPKColorDiv = document.createElement('div');
    this.CPKColorDiv.setAttribute('class','inspector-control');

    this.CPKValue = this.buildColorValue('CPK');
    this.CPKDropdown = this.buildColorDropDown('CPK',this.CPKColor);
    this.CPKColorDiv.appendChild(this.CPKValue);
    this.CPKColorDiv.appendChild(this.CPKDropdown);
    this.CPKColorRow.appendChild(this.CPKSpacer);
    this.CPKColorRow.appendChild(this.CPKTitle);
    this.CPKColorRow.appendChild(this.CPKColorDiv);
    this.CPKDiv.appendChild(this.CPKColorRow);


    this.inspectorBody.appendChild(this.CPKDiv);

    this.inspectorSelected = document.createElement('div');
    this.inspectorSelected.setAttribute('id','inspectorSelected');
    this.titleWrapper = document.createElement('div');
    this.titleWrapper.setAttribute('class','title-wrapper');
    this.modelSubTitle1 = document.createElement('span');
    this.modelSubTitle1.setAttribute('class','model-subtitle dark');
    this.modelSubTitle2 = document.createElement('span');
    this.modelSubTitle2.setAttribute('class','model-subtitle dark');
    this.modelTitle = document.createElement('span');
    this.modelTitle.setAttribute('class','model-title dark');

    this.titleWrapper.appendChild(this.modelSubTitle1);
    this.titleWrapper.appendChild(this.modelSubTitle2);
    this.titleWrapper.appendChild(this.modelTitle);
    this.inspectorSelected.appendChild(this.titleWrapper);
    this.inspectorBody.appendChild(this.inspectorSelected);


    //selected items
    this.selectedDiv = document.createElement('div');
    this.selectedDiv.setAttribute('class','inspector-div top-border hidden');
    this.inspectorRow = document.createElement('div');
    this.inspectorRow.setAttribute('class','inspector-row');
    this.selectedSpacer = document.createElement('div');
    this.selectedSpacer.setAttribute('class','inspector-check blank');
    this.selectedTitle = document.createElement('div');
    this.selectedTitle.setAttribute('class','inspector-label color');
    this.selectedTitle.innerHTML = 'Color';
    this.selectedColorDiv = document.createElement('div');
    this.selectedColorDiv.setAttribute('class','inspector-control');

    this.selectedValue = this.buildColorValue('selected');
    this.selectedDropdown = this.buildColorDropDown('selected',this.selectedColor);
    this.selectedColorDiv.appendChild(this.selectedValue);
    this.selectedColorDiv.appendChild(this.selectedDropdown);
    this.inspectorRow.appendChild(this.selectedSpacer);
    this.inspectorRow.appendChild(this.selectedTitle);
    this.inspectorRow.appendChild(this.selectedColorDiv);
    this.selectedDiv.appendChild(this.inspectorRow);

    this.inspectorBody.appendChild(this.selectedDiv);

    this.divider = document.createElement('div');
    this.divider.className = "inspector-divider";

    this.inspectorBody.appendChild(this.divider);

    this.scrollContainer.appendChild(this.closeButton);
    this.scrollContainer.appendChild(this.inspectorHeader);
    this.scrollContainer.appendChild(this.inspectorBody);
    this.el.appendChild(this.scrollContainer);

    document.querySelector('#inspectorPanel-' + this.app.appID).appendChild(this.el);
};


Autodesk.Viewing.MolViewer.InspectorView.prototype._initializeEvents = function _initializeEvents() {
    var self = this,
        args = {},
        ribbonItems = [],
        stickItems = [],
        CPKItems = [],
        surfaceItems = [],
        sectionItems = [],
        selectedItems = [],
        i,
        j;

    this.buildScrollbar = function buildScrollbar(e) {
        if(!e || e.modelType === 'mol') {
            self.scrollbar = new Autodesk.Nano.ScrollView(self, self.el, self.scrollContainer, 0);
        }
    };

    this.setMobileState = function setMobileState(state) {
        var i,
            inspectorRow,
            dropDowns,
            inspectorDivs = self.app.container.querySelectorAll('.inspector-div'),
            checkDiv = self.app.container.querySelector('#' + state + 'Check');
        for ( i = 0; i < inspectorDivs.length; i++) {
            inspectorRow = inspectorDivs[i].firstChild;
            //dropDowns = inspectorDivs[i].lastChild;
            dropDowns = inspectorDivs[i].childNodes[1];
            if (inspectorRow.firstChild.id === checkDiv.id) {
                inspectorRow.lastChild.lastChild.classList.toggle('active');
                if (dropDowns.style.display === "none") {
                    dropDowns.style.display = self.isSafari ? '-webkit-flex' : 'flex';
                } else {
                    dropDowns.style.display = "none";
                }
            } else {
                dropDowns.style.display = "none";
                inspectorRow.lastChild.lastChild.classList.remove('active');
            }
        }
    };

    this.setRibbonState = function setRibbonState() {
        var visibility = self.ribbonState !== 2;
        self.molMan.setVisibleFromSelection('ribbon',visibility);
    };

    this.setStickState = function setStickState() {
        var visibility = self.stickState !== 2;
        self.molMan.setVisibleFromSelection('stick',visibility);
    };


    this.setCPKState = function setCPKState() {
        var visibility = self.CPKState !== 2;
        self.molMan.setVisibleFromSelection('CPK',visibility);
    };

    this.setSurfaceState = function setSurfaceState() {
        var visibility = self.surfaceState !== 2;
        self.molMan.setVisibleFromSelection('surface',visibility);
    };

    this.setCheckState = function setCheckState(event) {
        var state = event.rep + 'State';
        var element = self.app.container.querySelector('#' + event.rep + 'Check');
        if(event.visibility === 0) { //no rep visible in selection
            element.classList.add('off');
            element.classList.remove('on');
            element.classList.remove('part');
            element.parentNode.nextSibling.style.display = 'none';
            if (element.parentNode.nextSibling.nextSibling) {
                element.parentNode.nextSibling.nextSibling.style.display = 'none';
                if (event.rep === 'surface' && element.parentNode.nextSibling.nextSibling.nextSibling) {
                    element.parentNode.nextSibling.nextSibling.nextSibling.style.display = 'none';
                }
            }


            element.parentNode.classList.remove('selected');
            self[state] = 0;
        } else if (event.visibility === 1) { // partial rep visible in selection
            element.classList.remove('off');
            element.classList.remove('on');
            element.classList.add('part');
            if (!isTouchDevice() || window.innerWidth >= Autodesk.Viewing.MolViewer.MAX_TABLET_MODE_RESOLUTION) {
                element.parentNode.nextSibling.style.display = self.isSafari ? '-webkit-flex' : 'flex';
                if (element.parentNode.nextSibling.nextSibling) {
                    element.parentNode.nextSibling.nextSibling.style.display = self.isSafari ? '-webkit-flex' : 'flex';
                    if (event.rep === 'surface' && element.parentNode.nextSibling.nextSibling.nextSibling) {
                        element.parentNode.nextSibling.nextSibling.nextSibling.style.display = self.isSafari ? '-webkit-flex' : 'flex';
                    }
                }

            }
            element.parentNode.classList.add('selected');
            self[state] = 1;
        } else { // 100% rep visible in selection
            element.classList.add('on');
            element.classList.remove('off');
            element.classList.remove('part');
            if (!isTouchDevice() || window.innerWidth >= Autodesk.Viewing.MolViewer.MAX_TABLET_MODE_RESOLUTION) {
                element.parentNode.nextSibling.style.display = self.isSafari ? '-webkit-flex' : 'flex';
                if (element.parentNode.nextSibling.nextSibling) {
                    element.parentNode.nextSibling.nextSibling.style.display = self.isSafari ? '-webkit-flex' : 'flex';
                    if (event.rep === 'surface' && element.parentNode.nextSibling.nextSibling.nextSibling) {
                        element.parentNode.nextSibling.nextSibling.nextSibling.style.display = self.isSafari ? '-webkit-flex' : 'flex';
                    }
                }

            }
            element.parentNode.classList.add('selected');
            self[state] = 2;
        }
    };

    this.ribbonValue.addEventListener('click', function() {
        self.hideInspectorDropdowns();
        self.ribbonDropdown.classList.add('visible');
        document.addEventListener('click', self.doHideInspectorDropdowns);
    });

    this.stickValue.addEventListener('click', function(event) {
        self.hideInspectorDropdowns(event);
        self.stickDropdown.classList.add('visible');
        document.addEventListener('click', self.doHideInspectorDropdowns);
    });

    this.surfaceValue.addEventListener('click', function() {
        self.hideInspectorDropdowns();
        self.surfaceDropdown.classList.add('visible');
        document.addEventListener('click', self.doHideInspectorDropdowns);
    });

    this.CPKValue.addEventListener('click', function() {
        self.hideInspectorDropdowns();
        self.CPKDropdown.classList.add('visible');
        document.addEventListener('click', self.doHideInspectorDropdowns);
    });

    this.deselectCustomColorButtons = function deselectCustomColorButtons(target) {
        var buttons = target.querySelectorAll('.custom-color-button');
        for (i = 0; i < buttons.length; ++i) {
            buttons[i].classList.remove('selected');
        }
    };

    this.getSelectedColorIndex = function getSelectedColorIndex(node) {
        var buttons = node.querySelectorAll('.custom-color-button');
        var i;
        var index = null;
        for (i = 0; i < buttons.length; ++i) {
            if (buttons[i].classList.contains('selected')) {
                index = parseInt(buttons[i].getAttribute('data-color-index'), 10);
                break;
            }
        }
        return index;
    };

    this.customColorHandler = function customColorHandler(event) {
        var targetParent = event.target.parentNode;
        var rep = targetParent.getAttribute('data-rep');
        var top = targetParent.offsetTop + targetParent.clientHeight + 75;
        var i;
        var picker;
        var index = parseInt(event.target.getAttribute('data-color-index'), 10);

        if (!index) { //the plus button has no data-color-index
            index = this.getSelectedColorIndex(targetParent);
            if (self.app.ViewManager.getTopView('ColorPickerView')) {
                picker = self.app.ViewManager.getTopView('ColorPickerView');
                if (picker.rep === rep) {
                    self.app.ViewManager.getTopView('ColorPickerView').updateColorIndex(index);
                } else { // save current changes and open new color picker view if for a different rep
                    picker.saveSelection();
                    self.openColorDialog(rep, index, top);
                }
            } else {
                self.openColorDialog(rep, index, top);
            }
            return;
        } else {
            if (self.app.ViewManager.getTopView('ColorPickerView')) {
                self.app.ViewManager.getTopView('ColorPickerView').updateColorIndex(index);
            }
        }


        self.deselectCustomColorButtons(targetParent);
        event.target.classList.add('selected');

        self.molMan.setColorFromSelection(rep, 'custom', index);
        self.app.MoleculeViewer.impl.invalidate(true);

    };

    this.customColorHandlerBind = this.customColorHandler.bind(this);


    this.selectedValue.addEventListener('click', function() {
        self.hideInspectorDropdowns();
        self.selectedDropdown.classList.add('visible');
        document.addEventListener('click', self.doHideInspectorDropdowns);
    });

    this.doHideInspectorDropdowns = function doHideInspectorDropdowns(event) {
        if (!event.target.classList.contains('drop-down')) {
            self.hideInspectorDropdowns(event);
            document.removeEventListener('click',self.doHideInspectorDropdowns);
        }
    };

    this.hideInspectorDropdowns = function hideInspectorDropdowns(event) {
        var dropDowns = self.el.querySelectorAll('.inspector-drop-down'),
            i;

        for (i = 0; i < dropDowns.length; i++) {
            dropDowns[i].classList.remove('visible');
        }
    };

    this.selectInspectorOption = function selectInspectorOption(targetString,inspectorOptions) {
        var j;
        for (j = 0; j < inspectorOptions.length; j++) {
            if (targetString === inspectorOptions[j].innerHTML.toLowerCase()) {
                inspectorOptions[j].classList.add('selected');
            } else {
                inspectorOptions[j].classList.remove('selected');
            }
        }
    };

    if (isTouchDevice()) {
        inspectorPanel.addEventListener('touchmove', function(event) {
            if (!event.target.classList.contains('inspector-slider')) {
                event.preventDefault();
            }
        });
    }



    this.ribbonDropdown.addEventListener('touchstart', function(event) {
        self.hideInspector(event.target);
    });

    this.ribbonDropdown.addEventListener('click', function(event) {
        self.molMan.setColorFromSelection('ribbon',event.target.innerHTML.toLowerCase()); //temporary until we can turn off parts of reps
        self.ribbonDropdown.classList.remove('visible');
    });

    this.ribbonDropdown.addEventListener('touchend', function(event) {
        self.showInspector(event.target);
    });

    this.stickDropdown.addEventListener('touchstart', function(event) {
        self.hideInspector(event.target);
    });

    this.stickDropdown.addEventListener('click', function(event) {
        self.molMan.setColorFromSelection('stick',event.target.innerHTML.toLowerCase()); //temporary until we can turn off parts of reps
        self.stickDropdown.classList.remove('visible');
    });

    this.stickDropdown.addEventListener('touchend', function(event) {
        self.showInspector(event.target);
    });

    this.surfaceDropdown.addEventListener('touchstart', function(event) {
        self.hideInspector(event.target);
    });

    this.surfaceDropdown.addEventListener('click', function(event) {
        self.molMan.setColorFromSelection('surface',event.target.innerHTML.toLowerCase()); //temporary until we can turn off parts of reps
        self.surfaceDropdown.classList.remove('visible');
    });

    this.surfaceDropdown.addEventListener('touchend', function(event) {
        self.showInspector(event.target);
    });

    this.CPKDropdown.addEventListener('touchstart', function(event) {
        self.hideInspector(event.target);
    });

    this.CPKDropdown.addEventListener('click', function(event) {
        self.molMan.setColorFromSelection('CPK',event.target.innerHTML.toLowerCase()); //temporary until we can turn off parts of reps
        self.CPKDropdown.classList.remove('visible');
    });

    this.CPKDropdown.addEventListener('touchend', function(event) {
        self.showInspector(event.target);
    });

    selectedItems = this.selectedDropdown.querySelectorAll('.inspector-drop-down-item');
    for (i = 0; i < selectedItems.length; i++) {
        selectedItems[i].addEventListener('click', function(event) {
            var type;
            for (type in self.dropDownColors) {
                if(self.dropDownColors.hasOwnProperty(type)) {
                    self.molMan.setColorFromSelection(type,event.target.innerHTML.toLowerCase());
                }
            }
            self.selectedDropdown.classList.remove('visible');
        });
    }

    this.toggleInspector = function toggleInspector(forceState) {
        self.app.ViewManager.toggleInspector(forceState);
        self.app.MoleculeViewer.fireEvent({type: Autodesk.Viewing.MENU_SELECTION_UPDATED});
    };

    this.ribbonCheck.addEventListener('touchstart', touchStartToClick);
    this.stickCheck.addEventListener('touchstart', touchStartToClick);
    this.surfaceCheck.addEventListener('touchstart', touchStartToClick);
    this.CPKCheck.addEventListener('touchstart', touchStartToClick);

    this.ribbonCheck.addEventListener('click',this.setRibbonState);
    this.stickCheck.addEventListener('click',this.setStickState);
    this.CPKCheck.addEventListener('click',this.setCPKState);
    this.surfaceCheck.addEventListener('click',this.setSurfaceState);

    this.mobileRibbonCheck.addEventListener('touchstart', touchStartToClick);
    this.mobileStickCheck.addEventListener('touchstart', touchStartToClick);
    this.mobileSurfaceCheck.addEventListener('touchstart', touchStartToClick);
    this.mobileCPKCheck.addEventListener('touchstart', touchStartToClick);

    this.mobileRibbonCheck.addEventListener('click', function () {
        self.setMobileState("ribbon");
    });

    this.mobileStickCheck.addEventListener('click', function() {
        self.setMobileState("stick");
    });

    this.mobileSurfaceCheck.addEventListener('click', function() {
        self.setMobileState("surface");
    });

    this.mobileCPKCheck.addEventListener('click', function() {
        self.setMobileState("CPK");
    });

    this.closeButton.addEventListener('touchstart', touchStartToClick);
    this.openInspectorButton.addEventListener('touchstart', touchStartToClick);
    this.closeButton.addEventListener('click', this.toggleInspector);
    this.openInspectorButton.addEventListener('click', this.toggleInspector);

    this.getSelections = function getSelection(event) {
        var results = [],
            type = null,
            atomID,
            atomName,
            residueID,
            residueName,
            selection = event.selection,
            chainLen = selection ? selection.chain.length : 0,
            residueLen = selection ? selection.residue.length : 0,
            atomIDLen =  selection ? self.app.ViewManager.getBitSetSelected(selection.atomID).length : 0,
            selectedLen =  selection ? self.app.ViewManager.getBitSetSelected(selection.atoms).length : 0;
        if (chainLen + residueLen + atomIDLen > 1) {
            results.push('Multiple');
        } else if (chainLen === 1) {
            results.push('Chain ' + MetaData.chains[selection.chain[0][0]]);
        } else if (residueLen === 1) {
            residueID = selection.residue[0][0];
            results.push('Chain ' + MetaData.chains[residueID] + '&nbsp;&rang;&nbsp;');
            residueName = self.app.ViewManager.fullnames[ MetaData.residues[residueID]];
            if(!residueName) {
                residueName = MetaData.residues[residueID];
            }
            results.push(residueName + ' ' + MetaData.metaArray[residueID][1]);

        } else if (atomIDLen === 1) {
            atomID = self.app.ViewManager.getBitSetSelected(selection.atomID);
            results.push('Chain ' + MetaData.chains[atomID] + '&nbsp;&rang;&nbsp;');
            residueName = self.app.ViewManager.fullnames[ MetaData.residues[atomID]];
            if(!residueName) {
                residueName = MetaData.residues[atomID];
            }
            results.push(residueName + ' ' + MetaData.metaArray[atomID][1] + '&nbsp;&rang;&nbsp;');
            atomName = MetaData.atomNames[MetaData.metaArray[atomID][3]];
            if(!atomName) {
                atomName = MetaData.metaArray[atomID][3];
            }
            results.push(atomName);
        } else {
            results.push('');
        }

        if(selectedLen > 0) {
            self.selectedDiv.classList.remove('hidden');
        } else {
            self.selectedDiv.classList.add('hidden');
        }

        self.updateInspectorTitle(results);
        self.resetChecks();

    };

    this.getRepColors = function getRepColors(event) {
        if (!event.rep) {
            return false;
        }
        var i,
            modelID = self.molMan.currentMolModelID,
            atomBitSet = (event.atomBitSet),
            colorings = [event.colorType],
            options;

        if (!colorings || colorings.length <= 1) {
            options = self[event.rep + 'Dropdown'].querySelectorAll('.inspector-drop-down-item');
            self.selectInspectorOption(colorings[0],options);
            self[event.rep+'Value'].innerHTML = colorings[0].charAt(0).toUpperCase() + colorings[0].substr(1);
        } else {
            console.error('multiple coloring types');
        }
    };

    this.updateRepColors = function updateRepColors(event) {
        var i,
            j,
            modelID = self.molMan.currentMolModelID,
            atomBitSet = self.molMan.molModels[modelID].instance.selection.atoms,
            atoms = self.app.ViewManager.getBitSetSelected(atomBitSet),
            colorings = true,
            colors = {},
            index = null,
            options;

        for (i = 0; i < self.reps.length; i++) {
            colorings = self.getUniqueColorings(self.getColorTypes(modelID,self.reps[i]));
            options = self[self.reps[i] + 'Dropdown'].querySelectorAll('.inspector-drop-down-item');

            if (!colorings || colorings.length <= 1) {

                self.selectInspectorOption(colorings[0],options);
                self[self.reps[i] + 'Value'].innerHTML = colorings[0].charAt(0).toUpperCase() + colorings[0].substr(1);
            } else {
                for (j = 0; j < options.length; j++) {
                    options[j].classList.remove('selected');
                }
                self[self.reps[i] + 'Value'].innerHTML = '<div class="drop-down-dash">&mdash;</div>';
            }
            // update selected custom colors based on selection
            colors = self.molMan.getCustomColorIndexFromSelection(self.reps[i]);
            var colorDiv = self.app.container.querySelector('#' + self.reps[i] + 'CustomColors');
            var multi = false;
            if (Object.keys(colors).length > 1) {
                multi = true;
            }
            if (colorDiv) {
                var customColors = colorDiv.querySelectorAll('.custom-color-button');

                for (j = 0; j < customColors.length; ++j) {
                    if (colors[customColors[j].getAttribute('data-color-index')] && !multi) {
                        customColors[j].classList.add('selected');
                        index = parseInt(colors[customColors[j].getAttribute('data-color-index')], 10);
                    } else {
                        customColors[j].classList.remove('selected');
                    }
                }
                if (self.app.ViewManager.getTopView('ColorPickerView')) {
                    self.app.ViewManager.getTopView('ColorPickerView').updateColorIndex(index);
                }
            }
        }

    };

    this.updateTitle = function updateTitle(e) {
        if(!e || e.modelType === 'mol') {
            self.pdbTitle.innerHTML = e.model.title; //self.svfName;
        }
    };

    this.openColorDialog = function openColorDialog(rep, index, top) {
        var color = '#808080';
        if (index) {
            color = self.molMan.molModels[self.molMan.currentMolModelID].customColors[rep][index];
        }

        var args = {
            top: top,
            right: 20,
            bottom: null,
            left: null,
            index: index,
            color: color,
            rep: rep
        };
        this[rep + 'CustomColors'].classList.add('expanded');
        self.app.ViewManager.createTopView('ColorPickerView', args);
        self.app.ViewManager.getTopView('ColorPickerView').show();

    };

    this.resetChecks = function resetChecks(e) {
        var i;
        if((!e || !e.modelType) || e.modelType ==='mol') {
            for (i = 0; i < self.reps.length; i++) {
                self.resetCheck(self.reps[i]);
            }
        }
    };

    this.resetCheck = function resetCheck(rep) {
        var all,
            any,
            state;
        all = self.molMan.getVisibleFromSelection(rep,true);
        any = self.molMan.getVisibleFromSelection(rep);
        state = any && all ? 2 : any ? 1 : 0;
        self[rep + 'State'] = state;
        self.setCheckState({rep: rep, visibility: state});
    };

    //handles opacity set outside the UI
    this.setOpacityCB = function setOpacityCB() {
        var opacity = self.molMan.getOpacityFromSelection('surface');
        var decOpacity = (isNaN(opacity) ? 0 : opacity * (1/255));
        self.opacityToolSlider.sliderElement.value = decOpacity + '';
    };


    this.buildCustomColorButtonsByRepBind = this.buildCustomColorButtonsByRep.bind(this);

    this._bindEvents = function _bindEvents() {
        self.viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT,self.getSelections);
        self.viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT,self.updateRepColors);
        self.viewer.addEventListener(Autodesk.Viewing.COLOR_CHANGED_EVENT,self.getRepColors);
        self.viewer.addEventListener(Autodesk.Viewing.VISIBILITY_CHANGED_EVENT, self.setCheckState);
        self.viewer.addEventListener(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED, self._unbindEvents);
        self.viewer.addEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, self.updateTitle);
        self.viewer.addEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT, self.resetChecks);
        self.viewer.addEventListener(Autodesk.Viewing.REP_SET_EVENT, self.resetChecks);
        self.viewer.addEventListener(Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT, self.resetChecks);
        self.viewer.addEventListener(Autodesk.Nano.SESSION_SAVED_EVENT, self.buildCustomColorButtonsByRepBind);
        self.viewer.addEventListener(Autodesk.Nano.OPACITY_SET_EVENT, self.setOpacityCB);
        self.viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT,self.setOpacityCB);


        // Scrollbars are not created if app is loaded without a model so
        // if there is no scrollbar we add the event listener  that will
        // create the scrollbar instead of updating the viewer object.
        if (self.scrollbar) {
            self.scrollbar.updateViewer(self.viewer);
        } else {
            self.viewer.addEventListener(Autodesk.Nano.MODEL_START_LOADED_EVENT, self.buildScrollbar);
        }

    };

    this._unbindEvents = function _unbindEvents() {
        self.viewer.removeEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT,self.getSelections);
        self.viewer.removeEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT,self.updateRepColors);
        self.viewer.removeEventListener(Autodesk.Viewing.COLOR_CHANGED_EVENT,self.getRepColors);
        self.viewer.removeEventListener(Autodesk.Viewing.VISIBILITY_CHANGED_EVENT, self.setCheckState);
        self.viewer.removeEventListener(Autodesk.Nano.MODEL_START_LOADED_EVENT, self.buildScrollbar);
        self.viewer.removeEventListener(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED, self._unbindEvents);
        self.viewer.removeEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, self.updateTitle);
        self.viewer.removeEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT, self.resetChecks);
        self.viewer.removeEventListener(Autodesk.Viewing.REP_SET_EVENT, self.resetChecks);
        self.viewer.removeEventListener(Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT, self.resetChecks);
        self.viewer.removeEventListener(Autodesk.Nano.SESSION_SAVED_EVENT, self.buildCustomColorButtonsByRepBind);
        self.viewer.removeEventListener(Autodesk.Nano.OPACITY_SET_EVENT, self.setOpacityCB);
        self.viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT,self.setOpacityCB);
    };

    this.viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT,this.getSelections);
    this.viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT,this.updateRepColors);
    this.viewer.addEventListener(Autodesk.Viewing.COLOR_CHANGED_EVENT,this.getRepColors);
    this.viewer.addEventListener(Autodesk.Viewing.VISIBILITY_CHANGED_EVENT, this.setCheckState);
    this.viewer.addEventListener(Autodesk.Nano.MODEL_START_LOADED_EVENT, this.buildScrollbar);
    this.viewer.addEventListener(Autodesk.Viewing.BEFORE_VIEWER_UNINITIALIZED, this._unbindEvents);
    this.viewer.addEventListener(Autodesk.Nano.METADATA_LOADED_EVENT, this.updateTitle);
    this.viewer.addEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT, this.resetChecks);
    this.viewer.addEventListener(Autodesk.Viewing.REP_SET_EVENT, this.resetChecks);
    this.viewer.addEventListener(Autodesk.Viewing.MODEL_STATE_RESTORED_EVENT, this.resetChecks);
    this.viewer.addEventListener(Autodesk.Nano.SESSION_SAVED_EVENT, this.buildCustomColorButtonsByRepBind);
    this.viewer.addEventListener(Autodesk.Nano.OPACITY_SET_EVENT, this.setOpacityCB);
    this.viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT,this.setOpacityCB); //update opacity slider

};

Autodesk.Viewing.MolViewer.InspectorView.prototype._initializeToolSets = function _initializeToolSets() {
    var self = this;
    this.toolSet = new Autodesk.Viewing.UI.ToolSet( 'inspectorToolSet' );
    this.inspectorBody.appendChild(this.toolSet.container);

    this.surfaceToolSet = new Autodesk.Viewing.UI.ToolSet( 'surfaceToolSet' ); //for surface opacity slider
    this.surfaceDiv.appendChild(this.surfaceToolSet.container);

    var options = {
        class: 'inspector-slider',
        icon0: 'opacity-0',
        icon1: 'opacity-1',
        min: 0.0,
        max: 1.0,
        step: 0.01,
        val: 0.0
    };
    // Create a slider for the explode tool.
    this.opacityToolSlider = new Autodesk.Viewing.UI.Slider('sliderOpacity',options);
    this.opacityToolSlider.setState = function setActive(isActive) {
        if(isActive === 0) {
            this.container.classList.add('active');
        } else {
            this.container.classList.remove('active');
        }
    };

    this.opacityToolSlider.setOpacity = function setOpacity(opacity) {
        var fromCustom = true;
        self.molMan.setOpacityFromSelection(0,'surface',opacity,fromCustom);
    };

    this.opacityToolSlider.onInput = function (event) {
        // setting this with large assemblies is not a good experience (significant lag on control)
        this.setOpacity(parseFloat(event.target.value));
        // Slider fade effect for mobile devices
        self.molMan.hideSelectionState();

        if (self.molMan.selectionTimeout) {
            window.clearTimeout(self.molMan.selectionTimeout);
            delete self.molMan.selectionTimeout;
        }
        self.molMan.selectionTimeout = window.setTimeout(function () {
            self.molMan.showSelectionState();
        }, 3000);

        if ((!isTouchDevice() || window.innerWidth <= Autodesk.Viewing.MolViewer.MAX_PHONE_MODE_RESOLUTION) && !av.isMobileDevice()) {
            self.app.ViewManager.getTopView('InspectorView').hideInspector(event.target.parentNode);
        }
    };

    this.opacityToolSlider.onChange = function (event) {
        this.setOpacity(parseFloat(event.target.value));
        // Slider fade effect for mobile devices
        if ((!isTouchDevice() || window.innerWidth <= Autodesk.Viewing.MolViewer.MAX_PHONE_MODE_RESOLUTION) && !av.isMobileDevice()) {
            self.app.ViewManager.getTopView('InspectorView').showInspector(event.target.parentNode);
        }
    };

    this.surfaceToolSet.addControl(this.opacityToolSlider, {index:0});
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.getToolSet = function getToolSet() {
    return this.toolSet;
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.hideInspector = function hideInspector(element) {
    document.getElementById("inspectorPanel-" + this.app.appID).classList.add("transparent");
    element.classList.add("show");
    touchStartToClick(event);
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.showInspector = function showInspector(element) {
    document.getElementById("inspectorPanel-" + this.app.appID).classList.remove("transparent");
    element.classList.remove("show");
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.buildColorValue = function buildColorValue(type) {
    var i,
        value = this.dropDownColors[type][0],
        output = document.createElement('div');
    output.setAttribute('class','inspector-value drop-down');
    output.innerHTML = value.charAt(0).toUpperCase() + value.substr(1);
    return output;
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.shareSwitchCB = function shareSwitchCB() {
    var sv = this.app.ViewManager.getTopView('ShareView');
    sv.show();
    sv.scrollbar.updateScrollbar();
    this.hide();
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.buildColorDropDown = function buildColorDropDown(type,defaultValue) {
    var i,
        item,
        values = this.dropDownColors[type],
        len = values.length,
        output = document.createElement('div');
    output.setAttribute('class','inspector-drop-down drop-down');
    output.setAttribute('id',type + 'DropDown');


    for (i = 0; i < len; i++) {
        item = document.createElement('div');
        item.setAttribute('class','drop-down inspector-drop-down-item' + (values[i] === defaultValue ? ' selected' : ''));
        item.setAttribute('id',type + 'DropDown_'+ values[i]);
        item.innerHTML = values[i];
        output.appendChild(item);
    }

    return output;
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.buildSectionDropDown = function buildSectionDropDown(defaultValue) {
    var i,
        item,
        values = this.sections,
        len = values.length,
        output = document.createElement('div');
    output.setAttribute('class','drop-down inspector-drop-down');
    output.setAttribute('id', 'sectionDropDown');


    for (i = 0; i < len; i++) {
        item = document.createElement('div');
        item.setAttribute('class','drop-down inspector-drop-down-item ' + values[i][0] + (values[i][1] === defaultValue ? ' selected' : ''));
        item.setAttribute('data-value',values[i][1]);
        item.setAttribute('id','sectionDropDown_'+ values[i][1]);
        item.innerHTML = values[i][2];
        output.appendChild(item);
    }
    return output;
};


Autodesk.Viewing.MolViewer.InspectorView.prototype.updateInspectorTitle = function updateInspectorTitle(info) {
    var title1 ='',
        title2 ='',
        title3 ='';

    if(info.length === 1) {
        title3 = info[0];
    } else if (info.length === 2) {
        title2 = info[0];
        title3 = info[1];
    } else {
        title1 = info[0];
        title2 = info[1];
        title3 = info[2];
    }

    this.modelSubTitle1.innerHTML = title1;
    this.modelSubTitle2.innerHTML = title2;
    this.modelTitle.innerHTML = title3;

};


Autodesk.Viewing.MolViewer.InspectorView.prototype.getColorTypes = function getColorTypes(modelID, rep) {
    return this.molMan.getColorFromSelection(rep);
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.getUniqueColorings = function getUniqueColorings(colorings) {
    if (!colorings) {
        return false;
    }

    var retObj = colorings,
        retArray = [], key;
    for (key in retObj) {
        if (retObj.hasOwnProperty(key)) {
            retArray.push(retObj[key]);
        }
    }
    return retArray;
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.updateSvfName = function updateSvfName(svfName) {
    this.svfName = svfName;
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.resetReps = function resetReps() {
    //mz fixed but this really should be doing the default reset model since that throws an event
    //which will then be handled by the molecules, the views, the extensions.
    //as it is now we need to put everything in here which is not scalable.
    //eg currently it doesn't remove annotations or measurements.
    //when fixed remove this function
    for(var i = 0; i < this.molMan.molModels.length; ++i){
        this.molMan.molModels[i].switchToAssembly(null);
    }
    this.molMan.setDefaultReps(true);
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.buildCustomColorButtons = function buildCustomColorButtons(rep) {

    var buttonDiv,
        self = this,
        i,
        j,
        unChecked;

    var buildButton = function (div, rep, index) {
        var button,
            buttonDot;
        button = document.createElement('div');
        button.setAttribute('class','custom-color-button');
        button.setAttribute('data-color-index', index);
        buttonDot = document.createElement('div');
        buttonDot.setAttribute('class','custom-color-dot');
        if (index === 8) { // black button needs border to be seen
            buttonDot.classList.add('bordered');
        }
        buttonDot.style.backgroundColor = self.customColorArrays[rep][index];
        button.appendChild(buttonDot);
        div.appendChild(button);
    };

    var buildPlusButton = function (div, rep) {
        var button = document.createElement('div');
        button.setAttribute('class', 'more-colors');
        button.setAttribute('data-rep', rep);
        div.appendChild(button);
    };

    this.customColorArrays = self.molMan.molModels[self.molMan.currentMolModelID].customColors;

    unChecked = this[rep + 'Check'].classList.contains('off');
    buttonDiv = document.createElement('div');
    buttonDiv.setAttribute('id', rep + 'CustomColors');
    buttonDiv.setAttribute('class', 'custom-color-buttons');
    buttonDiv.setAttribute('data-rep', rep);
    if (unChecked) {
        buttonDiv.style.display = 'none';
    }
    for (i = 1; i < this.customColorArrays[rep].length; ++i) {
        if (i === 9) {
            buildPlusButton(buttonDiv, rep);
        }
        buildButton(buttonDiv, rep, i);
    }
    this[rep + 'CustomColors'] = buttonDiv;
    this[rep + 'Div'].appendChild(buttonDiv);
    this[rep + 'CustomColors'].addEventListener('click', this.customColorHandlerBind);
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.removeCustomColorButtons = function removeCustomColorButtons(rep) {
    var buttonDiv = this[rep + 'CustomColors'];
    buttonDiv.removeEventListener('click', this.customColorHandlerBind);
    this[rep + 'Div'].removeChild(buttonDiv);
    delete this[rep + 'CustomColors'];
};

Autodesk.Viewing.MolViewer.InspectorView.prototype.buildCustomColorButtonsByRep = function buildCustomColorButtonsByRep(event) {
    var i;
    for (i = 0; i < this.reps.length; ++i) {

        if (this[this.reps[i] + 'CustomColors']) {
            this.removeCustomColorButtons(this.reps[i]);
        }

        this.buildCustomColorButtons(this.reps[i]);
    }
};


;/**
 * Created by andrewkimoto on 12/4/15.
 */
(function() {

    Autodesk.Viewing.MolViewer.AtomList = function(parentView,ItemObj,instance) {
        this.parentView = parentView;
        this.app = parentView.app;
        this.molMan = this.app.MolMan;
        this.viewManager = this.app.ViewManager;
        Autodesk.Nano.ItemList.prototype.initialize.call(this,instance,ItemObj);
    };

    Autodesk.Viewing.MolViewer.AtomList.prototype = Object.create(Autodesk.Nano.ItemList.prototype);


    Autodesk.Viewing.MolViewer.AtomList.prototype.buildItems = function buildItems(parentElement) {
        var image,
            name,
            number,
            chain,
            atom,
            atoms,
            residue,
            parentResidue = this.parentView.upstreamElement.id.replace(/residue/,''),
            pr,
            i,
            j,
            md = this.molMan.molModels[this.molMan.currentMolModelID].molMetadata,
            residues = [],
            atomData;

        if(!this.getClickedItem()) {
            this.setClickedItem(0);
        }

        parentElement.innerHTML = null;
        parentElement.setAttribute('data-instance', this.getInstance().id);
        pr = parentResidue.match(/.+\-$/) ? parentResidue + '.' : parentResidue;
        atoms = md.findAtoms(pr,'residueID');
        residue = md.metaData[atoms[0]].residue.trim();
        //get selected residue info
        name = document.createElement('div');
        name.setAttribute('class','browser-flex-row title');
        name.innerHTML = (this.app.ViewManager.shortNames[residue] ? this.app.ViewManager.shortNames[residue] : residue) + ' ' + md.metaData[atoms[0]].resNumber.replace(/\./,'');
        parentElement.appendChild(name);
        chain = document.createElement('div');
        chain.setAttribute('class','browser-flex-row title');
        chain.innerHTML = 'Chain ' + md.metaData[atoms[0]].chainID;
        parentElement.appendChild(chain);

        for (i = 0; i < atoms.length; i++) {
            atom = this.getItem().buildItem(null,atoms[i]);
            parentElement.appendChild(atom);
            this.getItems().push(atom);
        }

        atom.classList.add('last');


        this.app.MoleculeViewer.fireEvent({type: Autodesk.Viewing.BROWSER_RESIZED_EVENT});
    };

    Autodesk.Viewing.MolViewer.AtomList.prototype.getSelectedItem = function getSelectedItem(element,regexItem) {
        return element.getAttribute('id');
    };

    Autodesk.Viewing.MolViewer.AtomList.prototype.getItemsFromSelection = function getItemsFromSelection() {
        return null;
    };

    Autodesk.Viewing.MolViewer.AtomList.prototype.findItems = function findItems(eventResidues) {
        return this.app.ViewManager.getBitSetSelected(this.getInstance().selection.atomID);
    };

    Autodesk.Viewing.MolViewer.AtomList.prototype.getDomItems = function getDomItems(eventResidues) {
        return this.parentView.el.querySelectorAll('.atom');
    };

    Autodesk.Viewing.MolViewer.AtomList.prototype.getParentItems = function getParentItems() {
        return this.app.ViewManager.getBitSetSelected(this.getInstance().selection.atomID);
    };

    Autodesk.Viewing.MolViewer.AtomList.prototype.addSelectedClass = function addSelectedClass(domItem,item,i,rs) {
        var atom = parseInt(domItem.getAttribute('id'),10);
        if (atom === item) {
            domItem.classList.add('selected');
            this.setClickedItem(!this.getClickedItem() ? i : this.getClickedItem());
            rs = true;
        }
        return rs;
    };

})();
;/**
 * Created by andrewkimoto on 12/4/15.
 */
(function() {

    Autodesk.Viewing.MolViewer.ChainList = function(parentView,ItemObj,instance) {
        this.parentView = parentView;
        this.app = parentView.app;
        this.molMan = parentView.app.MolMan;
        this.viewManager = this.app.ViewManager;
        Autodesk.Nano.ItemList.prototype.initialize.call(this,instance,ItemObj);
    };

    Autodesk.Viewing.MolViewer.ChainList.prototype = Object.create(Autodesk.Nano.ItemList.prototype);


    Autodesk.Viewing.MolViewer.ChainList.prototype.buildItems = function buildItems(parentElement) {
        var i,
            j,
            row,
            chain,
            button,
            entity,
            rootTitle,
            description,
            md = this.molMan.molModels[this.molMan.currentMolModelID].molMetadata;

        parentElement.innerHTML = null;
        this.items = this.getInstance().getChainIDs(); // get chains from instance entities
        //initialize shiftClickedChain property to 0 so that an initial shift click will select
        //all items from the top
        if (!this.getClickedItem()) {
            this.setClickedItem(0);
        }

        rootTitle = document.createElement('div');
        rootTitle.setAttribute('class','browser-flex-row title');
        rootTitle.innerHTML = this.getInstanceName();
        parentElement.appendChild(rootTitle);

        for (j = 0; j <this.getInstance().entityIDs.length; j++) {
            entity = this.molMan.molModels[this.molMan.currentMolModelID].entities[this.getInstance().entityIDs[j]];


            description = document.createElement('div');
            description.setAttribute('class','browser-flex-row subtitle');
            description.setAttribute('data-entity',j + '');
            description.innerHTML = entity.description;
            parentElement.appendChild(description);

            for (i = 0; i < entity.chainIDs.length; i++) {
                row = this.getItem().buildItem(j,entity.chainIDs[i]);
                parentElement.appendChild(row);
                this.getItems().push(row);
            }
            row.classList.add('bottom');
        }

        this.molMan.viewer.fireEvent({type: Autodesk.Viewing.BROWSER_RESIZED_EVENT});
    };

    Autodesk.Viewing.MolViewer.ChainList.prototype.getItemsFromSelection = function getItemsFromSelection() {
        return this.getInstance().selection.chain;
    };

    Autodesk.Viewing.MolViewer.ChainList.prototype.findItems = function findItems(eventChains) {
        return eventChains.length > 0 ? this.molMan.molModels[this.molMan.currentMolModelID].molMetadata.findItems('chainID',eventChains) : [];
    };

    Autodesk.Viewing.MolViewer.ChainList.prototype.getDomItems = function getDomItems(eventResidues) {
        return this.parentView.el.querySelectorAll('.' + this.getItem().getItemClass());
    };

    Autodesk.Viewing.MolViewer.ChainList.prototype.deselectSubTitles = function deselectSubTitles(){
        var subTitles = this.parentView.el.querySelectorAll('div[data-entity]'),
            i;

        for (i = 0; i < subTitles.length; i++) {
            subTitles[i].classList.remove('selected');
        }
    };

    Autodesk.Viewing.MolViewer.ChainList.prototype.getParentItems = function getParentItems() {
        return this.molMan.molModels[this.molMan.currentMolModelID].molMetadata.findItems('chainID', this.app.ViewManager.getBitSetSelected(this.getInstance().selection.atoms));
    };

    Autodesk.Viewing.MolViewer.ChainList.prototype.addSelectedClass = function addSelectedClass(domItem,item,i,rs) {
        if (domItem.textContent === 'Chain '+ item) {
            domItem.classList.add('selected');
            this.parentView.el.querySelector('div[data-entity="'+domItem.getAttribute('data-entity-parent')+'"]').classList.add('selected');
            this.clickedItem = !this.clickedItem ? i : this.clickedItem;
            rs = true;
        }
        return rs;
    };

    Autodesk.Viewing.MolViewer.ChainList.prototype.addParentClass = function addParentClass(parentItem,rs) {
        if (this.parentView.el.querySelector('#chain' + parentItem) && !this.parentView.el.querySelector('#chain' + parentItem).parentNode.classList.contains('parent') && !this.parentView.el.querySelector('#chain' + parentItem).parentNode.classList.contains('selected')) {
            this.parentView.el.querySelector('#chain' + parentItem).parentNode.classList.add('parent');
            rs = true;
        }
        return rs;
    };

})();
;/**
 * Created by andrewkimoto on 12/4/15.
 */
(function() {

    Autodesk.Viewing.MolViewer.InstanceList = function(parentView, ItemObj, instance) {
        this.parentView = parentView;
        this.app = parentView.app;
        this.molMan = parentView.app.MolMan;
        this.viewManager = this.app.ViewManager;
        Autodesk.Nano.ItemList.prototype.initialize.call(this,{selection: {selectedInstance:true}},ItemObj);
    };

    Autodesk.Viewing.MolViewer.InstanceList.prototype = Object.create(Autodesk.Nano.ItemList.prototype);


    Autodesk.Viewing.MolViewer.InstanceList.prototype.buildItems = function buildItems(parentElement) {
        var i,
            row,
            instance,
            button,
            children;

        parentElement.innerHTML = null;
        if(!this.molMan.molModels[this.molMan.currentMolModelID]) {
            this.instances = ["1"];
        } else {
            this.instances = this.molMan.molModels[this.molMan.currentMolModelID].activeInstances.map(function(obj) {return ''+obj.id});
        }

        //initialize shiftClickedInstance property to 0 so that an initial shift click will select
        //all items from the top
        if (!this.getClickedItem()) {
            this.setClickedItem(0);
        }
        this.instanceRow = document.createElement('div');

        for (i = 0; i < this.instances.length; i++) {
            row = this.getItem().buildItem(this.instances[i], i+1, this);
            parentElement.appendChild(row);
            this.getItems().push(row);
        }
        this.molMan.viewer.fireEvent({type: Autodesk.Viewing.BROWSER_RESIZED_EVENT});

        //destroy all child views
        this.app.ViewManager.destroyView(this.parentView,false,false);
    };

    Autodesk.Viewing.MolViewer.InstanceList.prototype.getSelectedInstances = function getSelectedInstances() {
        var instances = this.molMan.molModels[this.molMan.currentMolModelID].activeInstances,
            i,
            selectedInstances = [];
        for (i = 0; i < instances.length; i++) {
            if (instances[i].selection.instanceSelected) {
                selectedInstances.push(instances[i].id + '');
            }
        }
        return selectedInstances;
    };




    Autodesk.Viewing.MolViewer.InstanceList.prototype.getItemsFromSelection = function getItemsFromSelection() {
        var activeInstances = this.molMan.molModels[this.molMan.currentMolModelID].activeInstances,
            results = [],
            i;
        for (i = 0; i < activeInstances.length; i++) {
            if(activeInstances[i].selection.instanceSelected) {
                results.push('' + activeInstances[i].id);
            }
        }
        return results;
    };

    Autodesk.Viewing.MolViewer.InstanceList.prototype.findItems = function findItems(eventInstances) {
        return eventInstances; //in this list this is a no-op since getItemsFromSelection returns array of instance ids instead of array of atoms;
    };

    Autodesk.Viewing.MolViewer.InstanceList.prototype.getDomItems = function getDomItems(eventResidues) {
        return this.app.container.querySelectorAll('.instance');
    };

    Autodesk.Viewing.MolViewer.InstanceList.prototype.getParentItems = function getParentItems() {
        var instance,
            results = [];
        for (instance in this.molMan.selectedInstances) {
            if(this.molMan.selectedInstances.hasOwnProperty(instance)) {
                results.push(instance);
            }
        }
        return results;
    };

    Autodesk.Viewing.MolViewer.InstanceList.prototype.addSelectedClass = function addSelectedClass(domItem,item,i,rs) {
        if (domItem.id === 'instanceRow-'+ item) {
            domItem.classList.add('selected');
            this.setClickedItem(!this.getClickedItem() ? i : this.getClickedItem());
        }
        return rs;
    };

    Autodesk.Viewing.MolViewer.InstanceList.prototype.addParentClass = function addParentClass(parentItem,rs) {
        var element;
        if(this.molMan.selectedInstances[parentItem]) {
            element = this.parentView.el.querySelector('#instance'+parentItem);
            if (element && !element.parentNode.classList.contains('parent') && !element.parentNode.classList.contains('selected')) {
                element.parentNode.classList.add('parent');
            }
        }
        return rs;
    };

})();
;/**
 * Created by andrewkimoto on 12/4/15.
 */
(function() {

    Autodesk.Viewing.MolViewer.ResidueList = function(parentView,ItemObj,instance) {
        this.parentView = parentView;
        this.app = parentView.app;
        this.molMan = parentView.app.MolMan;
        this.viewManager = this.app.ViewManager;
        Autodesk.Nano.ItemList.prototype.initialize.call(this,instance,ItemObj);
    };

    Autodesk.Viewing.MolViewer.ResidueList.prototype = Object.create(Autodesk.Nano.ItemList.prototype);


    Autodesk.Viewing.MolViewer.ResidueList.prototype.buildItems = function buildItems(parentElement) {
        //if(!event.instances) {
        //    return;
        //}
        //this.instance = event.instances[0].instance;
        var i,
            j,
            row,
            len,
            item,
            contents,
            contents1,
            container,
            button,
            parentChain = this.parentView.upstreamElement.id.replace(/chain/,''),
            chain,
            residues = [],
            uniqueResidues = [],
            chainAtoms = [],
            md = this.molMan.molModels[this.molMan.currentMolModelID].molMetadata;

        parentElement.innerHTML = null;

        //initialize shiftClickedChain property to 0 so that an initial shift click will select
        //all items from the top
        if(!this.getClickedItem()) {
            this.setClickedItem(0);
        }

        chainAtoms = md.findAtoms(parentChain,'chain');
        residues = (chainAtoms.map(function(obj){return [obj,md.metaArray[obj][1],md.metaArray[obj][2]];}));
        uniqueResidues = (md.getUniqueItemsWithDisplay(residues,1,2));


        this.items = uniqueResidues;

        len = uniqueResidues.length;
        chain = document.createElement('div');
        chain.setAttribute('class','browser-flex-row title');
        chain.innerHTML = this.getInstanceName() + '<span style="opacity:0.5;">&nbsp;&nbsp;Chain ' + md.metaData[residues[0][0]].chainID + "</span>";
        parentElement.appendChild(chain);
        row = document.createElement('div');
        row.setAttribute('class','browser-flex-row');
        for (i = 0; i < len; i++) {
            item = this.getItem().buildItem(md.metaData[residues[0][0]].chainID,uniqueResidues[i][1],uniqueResidues[i][0]);
            row.appendChild(item);
            this.getItems().push(item);
        }
        parentElement.appendChild(row);
        this.molMan.viewer.fireEvent({type: Autodesk.Viewing.BROWSER_RESIZED_EVENT});
    };

    Autodesk.Viewing.MolViewer.ResidueList.prototype.getSelectedItemFromEvent = function getSelectedItemFromEvent(event,regexItem) {
        return this.getSelectedItem(event.currentTarget,null);
    };

    //the default just calls the getSelectedItem method with element and regexItem
    Autodesk.Viewing.MolViewer.ResidueList.prototype.getSelectedItemFromSelection = function getSelectedItemFromSelection(element,regexItem) {
        return this.getSelectedItem(element.childNodes[0],null);
    };

    Autodesk.Viewing.MolViewer.ResidueList.prototype.getSelectedItem = function getSelectedItem(element,regexItem) {
        return element.getAttribute('data-chain') + '-' + element.childNodes[1].textContent;
    };


    Autodesk.Viewing.MolViewer.ResidueList.prototype.getItemsFromSelection = function getItemsFromSelection() {
        return this.getInstance().selection.residue;
    };

    Autodesk.Viewing.MolViewer.ResidueList.prototype.findItems = function findItems(eventResidues) {
        return this.molMan.molModels[this.molMan.currentMolModelID].molMetadata.findItems('residueID',eventResidues);
    };

    Autodesk.Viewing.MolViewer.ResidueList.prototype.getDomItems = function getDomItems(eventResidues) {
        return this.parentView.el.querySelectorAll('.residue');
    };

    Autodesk.Viewing.MolViewer.ResidueList.prototype.getParentItems = function getParentItems() {
        return this.molMan.molModels[this.molMan.currentMolModelID].molMetadata.findItems('residueID',this.app.ViewManager.getBitSetSelected(this.getInstance().selection.atomID));
    };

    Autodesk.Viewing.MolViewer.ResidueList.prototype.addSelectedClass = function addSelectedClass(domItem,item,i,rs) {
        if (domItem.childNodes[0].getAttribute('data-chain') + '-' + domItem.childNodes[0].childNodes[1].textContent === item) {
            domItem.classList.add('selected');
            this.setClickedItem(!this.getClickedItem() ? i : this.getClickedItem());
            rs = true;
        }
        return rs;
    };

    Autodesk.Viewing.MolViewer.ResidueList.prototype.addParentClass = function addParentClass(parentItem,rs) {
        var pr = parentItem.replace(/\./,'');
        var element = this.parentView.el.querySelector('#residue' + pr);
        if (element && !element.parentNode.classList.contains('parent') && !element.parentNode.classList.contains('selected')) {
            element.parentNode.classList.add('parent');
            rs = true;
        }
        return rs;
    };

})();
;/**
 * Created by andrewkimoto on 12/4/15.
 */
(function() {

    Autodesk.Viewing.MolViewer.AtomItem = function(itemList, molMan, viewer) {
        var _itemList = itemList;
        var _itemClass =  'residue';
        var _itemName = 'Chain';

        this.molMan = molMan;
        this.viewer = viewer;

        this.getItemList = function getItemList() {
            return _itemList;
        };

        this.getItemClass = function getItemClass() {
            return _itemClass;
        };

        this.getItemName = function getItemName() {
            return _itemName;
        };
    };

    Autodesk.Viewing.MolViewer.AtomItem.prototype = Object.create(Autodesk.Nano.Item.prototype);

    //This is the efault method to be overridden by objects down the prototype chain
    //This method is designed to return an un-attached DOM object
    Autodesk.Viewing.MolViewer.AtomItem.prototype.buildItem = function buildItem(parentNo,itemText) {
        var self = this,
            atom,
            i,
            md = self.molMan.molModels[self.molMan.currentMolModelID].molMetadata;
        atom = document.createElement('div');
        atom.setAttribute('class', 'browser-flex-row atom');
        atom.setAttribute('id', itemText);
        atom.innerHTML = md.atomInfo[itemText];
        atom.addEventListener('click', function (event) {
            self.getItemList().selectItems(event,self);
        });
        atom.addEventListener('dblclick',function(event) {self.molMan.viewer.utilities.fitToView();});
        return atom;
    };

})();;/**
 * Created by andrewkimoto on 12/4/15.
 */
(function() {

    Autodesk.Viewing.MolViewer.ChainItem = function(itemList, molMan, viewer) {
        var _itemList = itemList;
        var _itemClass =  'chain';
        var _itemName = 'Chain';

        this.molMan = molMan;
        this.viewer = viewer;

        this.getItemList = function getItemList() {
            return _itemList;
        };

        this.getItemClass = function getItemClass() {
            return _itemClass;
        };

        this.getItemName = function getItemName() {
            return _itemName;
        };

    };

    Autodesk.Viewing.MolViewer.ChainItem.prototype = Object.create(Autodesk.Nano.Item.prototype);

    //This is the efault method to be overridden by objects down the prototype chain
    //This method is designed to return an un-attached DOM object
    Autodesk.Viewing.MolViewer.ChainItem.prototype.buildItem = function buildItem(parentNo,itemText) {
        var row,
            self = this,
            chain,
            button,
            i;
        row = document.createElement('div');
        row.setAttribute('class','browser-row chain');
        row.setAttribute('data-entity-parent', parentNo + '');
        chain = document.createElement('div');
        chain.setAttribute('class','browser-row-contents');
        button = document.createElement('button');
        button.setAttribute('class','browser-row-button');
        button.setAttribute('id','chain'+ itemText);
        chain.innerHTML='Chain ' + itemText;

        button.addEventListener('click', function(event) {
            var view;
            if (isTouchDevice()) {
                if (window.innerWidth < 1280) {
                    view = self.getItemList().parentView.openView(self.getItemList().parentView,event);
                    self.getItemList().parentView.toggleDownstreamPanel(self.getItemList().parentView.parentView, view.id);
                } else {
                    self.getItemList().parentView.toggleChildView(self.getItemList().parentView,event);
                }
            } else {
                self.getItemList().parentView.toggleChildView(self.getItemList().parentView,event);
            }
        });
        row.addEventListener('dblclick',function(event) {self.molMan.viewer.utilities.fitToView();});
        row.addEventListener('click', function(event) {if(!event.target.classList.contains('browser-row-button')) {self.getItemList().selectItems(event,self);}});
        row.appendChild(chain);
        row.appendChild(button);
        return row;
    };

})();;/**
 * Created by andrewkimoto on 12/4/15.
 */
(function() {
    var _itemList,
        _itemClass,
        _itemName;

    Autodesk.Viewing.MolViewer.InstanceItem = function(itemList, molMan, viewer) {
        _itemList = itemList;
        _itemClass =  'instance';
        _itemName = 'Instance';

        this.molMan = molMan;
        this.viewer = viewer;

    };

    Autodesk.Viewing.MolViewer.InstanceItem.prototype = Object.create(Autodesk.Nano.Item.prototype);

    //This is the efault method to be overridden by objects down the prototype chain
    //This method is designed to return an un-attached DOM object
    Autodesk.Viewing.MolViewer.InstanceItem.prototype.buildItem = function buildItem(itemID, itemText) {
        var self = this;
        var row,
            instance,
            button,
            i;
        row = document.createElement('div');
        row.setAttribute('class','browser-row instance');
        row.setAttribute('id','instanceRow-' + itemID);
        instance = document.createElement('div');
        instance.setAttribute('class','browser-row-contents');
        button = document.createElement('button');
        button.setAttribute('class','browser-row-button');
        button.setAttribute('id','instance'+ itemID);
        instance.innerHTML='Instance ' + itemText;
        row.appendChild(instance);
        row.appendChild(button);

        row.addEventListener('click', function(event) {if(!event.target.classList.contains('browser-row-button')) {_itemList.selectItems(event,self,true);}});
        instance.addEventListener('dblclick',function(event) {self.viewer.utilities.fitToView();});
        button.addEventListener('click', function(event) {
            var view;
            if (isTouchDevice()) {
                if (window.innerWidth < 1280) {
                    view = self.getItemList().parentView.openView(self.getItemList().parentView,event);
                    self.getItemList().parentView.toggleDownstreamPanel(self.getItemList().parentView.parentView, view.id);
                } else {
                    self.getItemList().parentView.toggleChildView(self.getItemList().parentView,event);
                }
            } else {
                self.getItemList().parentView.toggleChildView(self.getItemList().parentView,event);
            }
        });
        return row;
    };

    Autodesk.Viewing.MolViewer.InstanceItem.prototype.getItemList = function getItemList() {
        return _itemList;
    };

    Autodesk.Viewing.MolViewer.InstanceItem.prototype.getItemClass = function getItemClass() {
        return _itemClass;
    };

    Autodesk.Viewing.MolViewer.InstanceItem.prototype.getItemName = function getItemName() {
        return _itemName;
    };

})();;/**
 * Created by andrewkimoto on 12/4/15.
 */
(function() {

    Autodesk.Viewing.MolViewer.ResidueItem = function(itemList, molMan, viewer) {
        var _itemList = itemList;
        var _itemClass =  'residue';
        var _itemName = 'Chain';

        this.molMan = molMan;
        this.viewer = viewer;

        this.getItemList = function getItemList() {
            return _itemList;
        };

        this.getItemClass = function getItemClass() {
            return _itemClass;
        };

        this.getItemName = function getItemName() {
            return _itemName;
        };

    };

    Autodesk.Viewing.MolViewer.ResidueItem.prototype = Object.create(Autodesk.Nano.Item.prototype);

    //This is the efault method to be overridden by objects down the prototype chain
    //This method is designed to return an un-attached DOM object
    Autodesk.Viewing.MolViewer.ResidueItem.prototype.buildItem = function buildItem(parentNo,itemText,itemText1) {
        var self = this,
            chain,
            button,
            container,
            item,
            contents,
            contents1,
            i,
            md = self.molMan.molModels[self.molMan.currentMolModelID].molMetadata;
        container = document.createElement('div');
        container.setAttribute('class','browser-flex-container');
        item = document.createElement('div');
        item.setAttribute('class','flex-item residue');
        container.setAttribute('data-chain',parentNo);
        contents = document.createElement('div');
        contents.setAttribute('class','flex-value');
        contents.innerHTML = itemText;
        container.appendChild(contents);
        contents1 = document.createElement('div');
        contents1.setAttribute('class','flex-label');
        contents1.innerHTML = itemText1;
        container.appendChild(contents1);
        item.appendChild(container);
        button = document.createElement('button');
        button.setAttribute('class','browser-item-button');
        button.setAttribute('id','residue'+ parentNo + '-' + itemText1.replace(/\./,''));
        button.addEventListener('click', function(event) {
            var view;
            if (isTouchDevice()) {
                if (window.innerWidth < 1280) {
                    view = self.getItemList().parentView.openView(self.getItemList().parentView,event);
                    self.getItemList().parentView.toggleDownstreamPanel(self.getItemList().parentView.parentView, view.id);
                } else {
                    self.getItemList().parentView.toggleChildView(self.getItemList().parentView,event);
                }
            } else {
                self.getItemList().parentView.toggleChildView(self.getItemList().parentView,event);
            }
        });
        item.appendChild(button);
        container.addEventListener('click', function(event) {if(!event.target.classList.contains('browser-item-button')) {self.getItemList().selectItems(event,self);}});
        container.addEventListener('dblclick',function(event) {console.log('self is ',self);self.molMan.viewer.utilities.fitToView();});
        return item;
    };

})();;/**
 * Created by andrewkimoto on 4/13/15.
 */

Autodesk.Viewing.MolViewer.ShareView = function(args) {
    var me = Autodesk.Viewing.MolViewer.ShareView.prototype;

    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/) && !navigator.userAgent.toLowerCase().match(/chrome/) ? true : false;
    this.app = args.app;
    this.viewer = args.viewer;
    this.nanoViewer = this.app.MolViewer;
    this.nanoManager = this.app.MolMan;
    this.svfName = args.svfName;
    this.visible = true;
    this.type = 'ShareView';
    this.animateDirection = 'left';
    this.displayType = this.isSafari ? '-webkit-flex' : 'flex';
    this.flexDirection = 'column';
    this.resizeMin = 220;
    this.parentElement = document.querySelector('#InspectorPanel-' + this.app.appID);
    this.dimensions = ['400 x 300 px', '600 x 450 px', '800 x 600 px', '100% x 100%'];
    //parameters used to build the embedded or shared view
    this.shareParams = {
        name: 'My Shared Molecule',
        description: 'Lorem ipsum dolor sit amet.',
        viewerOnly: true,
        viewCube: false,
        splashScreen: false,
        tutorial: true,
        svfPath: '',
        height: '450px',
        width: '600px'
    };

    Autodesk.Nano.ShareView.prototype._initialize.call(this);
};

Autodesk.Viewing.MolViewer.ShareView.prototype = Object.create(Autodesk.Nano.ShareView.prototype);;Autodesk.Viewing.MolViewer = Autodesk.Viewing.MolViewer || {};

Autodesk.Viewing.MolViewer.StatusView = function (args) {

    var me = Autodesk.Viewing.MolViewer.StatusView.prototype;
    this.app = args.app;
    this.viewer = args.viewer;
    this.molMan = args.app.MolMan;
    this.loader = args.app.Loader;
    this.parentElement = this.app.container.querySelector(args.parentElement);
    this.isSafari = navigator.userAgent.toLowerCase().match(/safari/);
    this.type = 'StatusView';
    this._initialize();
};

Autodesk.Viewing.MolViewer.StatusView.prototype = Object.create(Autodesk.Nano.TopView.prototype);

Autodesk.Viewing.MolViewer.StatusView.prototype._initialize = function _initialize() {
    var me = Autodesk.Viewing.MolViewer.StatusView.prototype;
    me._initializeElements.call(this);
    me._initializeEvents.call(this);
    this.showTranslating(); // show translating state on initial load
};

Autodesk.Viewing.MolViewer.StatusView.prototype.destructor = function destructor() {
    this.el.innerHTML = '';
    this.el.remove();
    this.app.ViewManager.destroyTopView(this);
    this.closeBox.removeEventListener('click',this.hide);
};

Autodesk.Viewing.MolViewer.StatusView.prototype._initializeElements = function _initializeElements() {
    this.el = document.createElement('DIV');
    this.el.setAttribute('id','statusBar');
    this.el.setAttribute('class','hidden');
    this.progressBar = document.createElement('div');
    this.progressBar.setAttribute('class','progress-bar');
    this.statusText = document.createElement('div');
    this.statusText.setAttribute('class','status-text');
    this.closeBox = document.createElement('div');
    this.closeBox.setAttribute('class','close-box');
    this.el.appendChild(this.progressBar);
    this.el.appendChild(this.statusText);
    this.el.appendChild(this.closeBox);
    this.parentElement.appendChild(this.el);

    this.widthScale = this.progressBar.clientWidth;
};

Autodesk.Viewing.MolViewer.StatusView.prototype._initializeEvents = function _initializeEvents() {

    var self = this;

    this.closeBox.addEventListener('click',this.hide.bind(this));

    this.setIsLoading = function setIsLoading() {
        self.loader.isLoading = true;
    };

    this.setPercent = function setPercent(e) {
        var barWidth,
            pct;

        if(!e.percent) {
            return;
        }

        pct = e.percent;

        if (pct == self.lastValue)
            return;

        self.lastValue = pct;

        if (pct >= 99)
            self.hide();
        else {
            if(self.statusText.innerHTML !== 'Loading...') {
                self.showLoading();
            }
            self.widthScale = self.el.clientWidth;
            barWidth = (self.widthScale * pct) * 0.01;
            self.progressBar.style.width = barWidth + "px";
        }
    };

    this.viewer.addEventListener(Autodesk.Viewing.MOLVIEWER_PROGRESS_EVENT, self.setPercent);

    if (typeof this.molMan === 'object') { //this is molecule viewer
        this.viewer.addEventListener(Autodesk.Nano.MODEL_START_LOADED_EVENT, self.setIsLoading);
    }

    this.viewer.addEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT, self.hide.bind(self));
    this.viewer.addEventListener(Autodesk.Nano.STATUS_UPDATE, self.setStatus.bind(self));

    this._bindEvents = function _bindEvents() {
        self.viewer.addEventListener(Autodesk.Viewing.MOLVIEWER_PROGRESS_EVENT, self.setPercent);
        self.viewer.addEventListener(Autodesk.Nano.MODEL_END_LOADED_EVENT, self.hide.bind(self));
        self.viewer.addEventListener(Autodesk.Nano.STATUS_UPDATE, self.setStatus.bind(self));
    };
};

Autodesk.Viewing.MolViewer.StatusView.prototype.setStatus = function setStatus(event) {
    var method = event.method;
    var message = event.message;
    this[method](event.message);
};

Autodesk.Viewing.MolViewer.StatusView.prototype.hide = function close() {
    if (0 && this.loader.isLoading) { //mz not used
        this.showCustomMessage('Finishing up...');
        return;
    }
    this.el.classList.remove('error');
    this.el.classList.add('hidden');
    this.statusText.innerHTML = '';
    this.progressBar.style.width = '0px';
};

Autodesk.Viewing.MolViewer.StatusView.prototype.showError = function open() {
    this.el.classList.add('error');
    this.statusText.innerHTML = 'There has been an error translating your pdb file.  Please try a different file.';
    this.el.classList.remove('hidden');
};

Autodesk.Viewing.MolViewer.StatusView.prototype.showCustomError = function showCustomError(message) {
    this.el.classList.add('error');
    this.statusText.innerHTML = message;
    this.el.classList.remove('hidden');
};

Autodesk.Viewing.MolViewer.StatusView.prototype.showLoading = function showLoading() {
    this.el.classList.remove('error');
    this.statusText.innerHTML = 'Loading...';
    this.el.classList.remove('hidden');
};

Autodesk.Viewing.MolViewer.StatusView.prototype.showTranslating = function showTranslating() {
    this.el.classList.remove('error');
    this.statusText.innerHTML = 'Translating...';
    this.el.classList.remove('hidden');
};

Autodesk.Viewing.MolViewer.StatusView.prototype.showCustomMessage = function showCustomMessage(message) {
    this.el.classList.remove('error');
    this.statusText.innerHTML = message;
    this.el.classList.remove('hidden');
};;/**
 * Created by andrewkimoto on 8/27/15.
 */


Autodesk.Viewing.MolViewerLoader = function(app) {
    avp.DEBUG_SHADERS = true;  //to make sure we are good
    this.app = app;
};

Autodesk.Viewing.MolViewerLoader.prototype = Object.create(Autodesk.Nano.Loader.prototype);

Autodesk.Viewing.MolViewerLoader.prototype.loadViewData = function loadViewData(options) {
    var _that = this;
    var viewFile = 'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/config/mol-topviews.json';
    if (options.topViews) {
        viewFile = 'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/config/' + options.topViews + (!options.topViews.match(/\.json$/) ? '.json' : '');
    }

    var promise = _that.app.ApiConnector.loadViewData(options,viewFile)
        .then(function(data){
            Autodesk.Viewing.topViewData = JSON.parse(data);
            _that.initializeViewer(options);

            if (isTouchDevice()) {
                document.body.className += "mobile";
                document.getElementById('guiviewer3d-toolbar').classList.add('hide-on-mobile');
            }

        },function(data){
            console.error('failed',data);
        })
        .catch(function(error) {
            console.error('there was an error in LoadViewData',error);
        });
};

Autodesk.Viewing.MolViewerLoader.prototype.loadInitialViews = function loadInitialViews() {
    if(this.app.ViewManager.getRootView()) {
             this.app.ViewManager.addView(this.app.ViewManager.getRootView(),{app: this.app, viewer: this.app.MoleculeViewer, upstreamView: null, upstreamElement: null},true);
    }
};

// either uses an existing cookie or builds a new cookie by getting the
// url of the default 1C7D model from the server
Autodesk.Viewing.MolViewerLoader.prototype.initializeCookie = function InitializeCookie() {
    window.ApiConnector = new Autodesk.Nano.ApiConnector();
    var sessionID = Autodesk.Viewing.Private.getParameterByName('session');
    var loadEmpty = avp.getParameterByName("empty") === 'true' ? true : false;

    // set the connectionID for use with all api calls the ensure constant load balancer server.
    this.setConnectionID();

    if(!sessionID){
        if(!loadEmpty) {
            sessionID = this.getCookieItem('sessionCookie');
            if(sessionID===null || sessionID === undefined){
                sessionID = 'default';
            }
        }else{
            sessionID = null; //if load empty AND no session, if session always do it
        }
    }
    if(sessionID === "0"){ //special case to clear and load empty
        this.sessionID = null;
    }else {
        this.sessionID = sessionID;
    }

    this.loadViewData(this.getOptionsFromQueryString());

};

Autodesk.Viewing.MolViewerLoader.prototype.getUrlFromPdbId = function getUrlFromPdbId(id, socketID) {
    var that = this;
    return new Promise(function(resolve,reject) {
        var results = that.app.ApiConnector.getPdbUrl(id, socketID);
        results
            .then(function(data){
                if (data) {
                    resolve(data);
                } else {
                    reject(data);
                }
            })
            .catch(function(err){
                console.log('Error getting PDB URL from server: ',err);
            });
    });
};

Autodesk.Viewing.MolViewerLoader.prototype.getOptionsFromQueryString = function getOptionsFromQueryString(svfURL,options) {
    var config3d = {};
    var configViews = {};
    var pdbId ='';
    var autocamDuration = 2.0;
    var autocamDestinationPercent = 2.0;
    var protocol = location.protocol;
    var hostProtocol = (avp.getParameterByName('host') === 'dev' ? 'http://' + location.hostname + ':4000' : '');
    var showViewCube = avp.getParameterByName('viewcube')!== 'false';
    var hideBrowser = avp.getParameterByName('hB');
    var hideInspector = avp.getParameterByName('hI');
    var disableBrowser = avp.getParameterByName('dB');
    var disableInspector = avp.getParameterByName('dI');
    var noPan = avp.getParameterByName('nP');
    var explodeScale = avp.getParameterByName('explodeScale');
    var mode = avp.getParameterByName('mode');
    var topViews = Autodesk.Viewing.isMobileDevice() ? 'presentation' : avp.getParameterByName('tV');
    var hideHeader = topViews === 'presentation' ? 'true' : avp.getParameterByName('hH');
    var noSplash = avp.getParameterByName('nosplash') === 'true' || topViews === 'presentation';
    var autoVR = avp.getParameterByName('vr') === 'true' && topViews === 'presentation' ? true : false;
    var canvasConfig = avp.getParameterByName("canvasConfig");
    if (canvasConfig) {
        config3d.canvasConfig = JSON.parse(canvasConfig);
    }

    var docStructureConfig = avp.getParameterByName("docConfig");
    if (docStructureConfig) {
        config3d.docStructureConfig = JSON.parse(docStructureConfig);
    }

    var documentId = avp.getParameterByName("document");
    if(!documentId) {
        documentId = avp.getDemoDocumentURN();
    }

    var initialItemId = avp.getParameterByName("item");

    var isolateObjectId = avp.getParameterByName("object");

    options.config3d = options.config3d || {};
    options.configViews = options.configViews || {};

    var headless = avp.getParameterByName('headless') === 'true';
    headless = typeof options.headless === 'boolean' ? options.headless : headless;

    var extensions = config3d['extensions'] || [];
    //extensions.push('Autodesk.Fusion360.Animation');
    //extensions.push('Autodesk.Viewing.Oculus');
    //extensions.push('Autodesk.Viewing.VR');
    //extensions.push('Autodesk.VR');
    extensions.push('Autodesk.webVR');
    extensions.push('Autodesk.Viewing.Collaboration');
    extensions.push('Autodesk.Viewing.RemoteControl');
    //extensions.push("Autodesk.Measure");
    config3d.extensions = options.config3d.extensions && options.config3d.extensions.length ? options.config3d.extensions : extensions;
    config3d.explodeScale = options.config3d.explodeScale ? options.config3d.explodeScale : explodeScale;
    config3d.showViewCube = typeof options.config3d.showViewCube === 'boolean' ? options.config3d.showViewCube : showViewCube;
    config3d.noPan = typeof options.config3d.noPan === 'boolean' ? options.config3d.noPan : noPan === 'true';
    config3d.autoVR = typeof options.config3d.autoVR === 'boolean' ? options.config3d.autoVR : autoVR;
    config3d.hostProtocol = options.config3d.hostProtocol ? options.config3d.hostProtocol : hostProtocol;
    config3d.autocamDuration = options.config3d.autocamDuration ? options.config3d.autocamDuration : autocamDuration;
    config3d.autocamDestinationPercent = options.config3d.autocamDestinationPercent ? options.config3d.autocamDestinationPercent : autocamDestinationPercent;

    configViews.hideBrowser = typeof options.configViews.hideBrowser === 'boolean' ? options.configViews.hideBrowser : hideBrowser === 'true';
    configViews.hideInspector = typeof options.configViews.hideInspector === 'boolean' ? options.configViews.hideInspector : hideInspector === 'true';
    configViews.hideHeader = typeof options.configViews.hideHeader === 'boolean' ? options.configViews.hideHeader : hideHeader === 'true';
    configViews.disableBrowser = typeof options.configViews.disableBrowser === 'boolean' ? options.configViews.disableBrowser : disableBrowser === 'true';
    configViews.disableInspector = typeof options.configViews.disableInspector === 'boolean' ? options.configVews.disableInspector : disableInspector === 'true';
    configViews.noSplash = typeof options.configViews.noSplash === 'boolean' ? options.configViews.noSplash : noSplash;

    // Use this option to hide the RTC button in viewer toolbar
    /*
     config3d.rtc = {};
     config3d.rtc.disableRTCToolbarButton = true;
     */

    if(!svfURL) {
        svfURL = avp.getParameterByName("svf");
    }
    // Switch for loading an empty app.
    // Add the parameter empty=false to the url
    // This is a temporary workaround though it is non-destructive
    if (avp.getParameterByName("empty") || options.empty) {
        svfURL = '';
    }

    //we are not using these for now
    var documentId = avp.getParameterByName("document");
    var initialItemId = avp.getParameterByName("item");
    var isolateObjectId = avp.getParameterByName("object");
    var offline = avp.getParameterByName("offline");

    // Test accessToken callbacks.
    function getAccessToken(onGetAccessToken) {
        var token = "VZ/w+AvqmpAKSwOFzDKMU7J3B8s=";
        onGetAccessToken(token, 30);
    }

    return {
        env: avp.getParameterByName("env") || "Local",
        config3d : config3d,
        documentId: documentId,
        svf: svfURL,
        mode: mode,
        configViews : configViews,
        topViews: topViews,
        initialItemId: initialItemId,
        isolateObjectId: isolateObjectId,
        userInfo : {
            name : "Joe Programmer"
        },
        libraryName: "src/globalinit.js",
        headless: headless,
        offline: offline
        // getAccessToken: getAccessToken
        //eventCallback: function(e) { console.log("XXXXXX " + JSON.stringify(e)); }
    };
};

Autodesk.Viewing.MolViewerLoader.prototype.addStyleSheet = function addStyleSheet(name) {
    var sheet = document.querySelector('#'+name);
    if(sheet) {
        return;
    }
    var head  = document.querySelector('head');
    var link  = document.createElement('link');
    link.id   = name;
    link.rel  = 'stylesheet';
    link.type = 'text/css';
    link.href = 'https://d2gqcyogkbv0l5.cloudfront.net/cdd0cfb/molviewer/res/' +  name + '.css';
    link.media = 'all';
    head.appendChild(link);
};



//# sourceMappingURL=molview.js.map
